var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(d, e, f) {
  d != Array.prototype && d != Object.prototype && (d[e] = f.value);
};
$jscomp.getGlobal = function(d) {
  return "undefined" != typeof window && window === d ? d : "undefined" != typeof global && null != global ? global : d;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.polyfill = function(d, e, f, g) {
  if (e) {
    f = $jscomp.global;
    d = d.split(".");
    for (g = 0; g < d.length - 1; g++) {
      var l = d[g];
      l in f || (f[l] = {});
      f = f[l];
    }
    d = d[d.length - 1];
    g = f[d];
    e = e(g);
    e != g && null != e && $jscomp.defineProperty(f, d, {configurable:!0, writable:!0, value:e});
  }
};
$jscomp.polyfill("Array.prototype.fill", function(d) {
  return d ? d : function(d, f, g) {
    var e = this.length || 0;
    0 > f && (f = Math.max(0, e + f));
    if (null == g || g > e) {
      g = e;
    }
    g = Number(g);
    0 > g && (g = Math.max(0, e + g));
    for (f = Number(f || 0); f < g; f++) {
      this[f] = d;
    }
    return this;
  };
}, "es6", "es3");
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function() {
  $jscomp.initSymbol = function() {
  };
  $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
};
$jscomp.Symbol = function() {
  var d = 0;
  return function(e) {
    return $jscomp.SYMBOL_PREFIX + (e || "") + d++;
  };
}();
$jscomp.initSymbolIterator = function() {
  $jscomp.initSymbol();
  var d = $jscomp.global.Symbol.iterator;
  d || (d = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
  "function" != typeof Array.prototype[d] && $jscomp.defineProperty(Array.prototype, d, {configurable:!0, writable:!0, value:function() {
    return $jscomp.arrayIterator(this);
  }});
  $jscomp.initSymbolIterator = function() {
  };
};
$jscomp.arrayIterator = function(d) {
  var e = 0;
  return $jscomp.iteratorPrototype(function() {
    return e < d.length ? {done:!1, value:d[e++]} : {done:!0};
  });
};
$jscomp.iteratorPrototype = function(d) {
  $jscomp.initSymbolIterator();
  d = {next:d};
  d[$jscomp.global.Symbol.iterator] = function() {
    return this;
  };
  return d;
};
$jscomp.iteratorFromArray = function(d, e) {
  $jscomp.initSymbolIterator();
  d instanceof String && (d += "");
  var f = 0, g = {next:function() {
    if (f < d.length) {
      var l = f++;
      return {value:e(l, d[l]), done:!1};
    }
    g.next = function() {
      return {done:!0, value:void 0};
    };
    return g.next();
  }};
  g[Symbol.iterator] = function() {
    return g;
  };
  return g;
};
$jscomp.polyfill("Array.prototype.values", function(d) {
  return d ? d : function() {
    return $jscomp.iteratorFromArray(this, function(d, f) {
      return f;
    });
  };
}, "es8", "es3");
(function(d) {
  function e(a, b) {
    return Math.sqrt((b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]));
  }
  function f(a, b, c, h, n, d) {
    return c < a && c + n > a && h < b && h + d > b ? !0 : !1;
  }
  function g(a, b) {
    return a[0] > b[2] || a[1] > b[3] || a[2] < b[0] || a[3] < b[1] ? !1 : !0;
  }
  function l(a, b) {
    this.options = b = b || {};
    var c = this;
    b.parentMenu && (b.parentMenu.constructor !== this.constructor ? (console.error("parentMenu must be of class ContextMenu, ignoring it"), b.parentMenu = null) : (this.parentMenu = b.parentMenu, this.parentMenu.lock = !0, this.parentMenu.current_submenu = this));
    b.event && b.event.constructor !== MouseEvent && b.event.constructor !== CustomEvent && (console.error("Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it."), b.event = null);
    var h = document.createElement("div");
    h.className = "litegraph litecontextmenu litemenubar-panel";
    h.style.minWidth = 100;
    h.style.minHeight = 100;
    h.style.pointerEvents = "none";
    setTimeout(function() {
      h.style.pointerEvents = "auto";
    }, 100);
    h.addEventListener("mouseup", function(a) {
      a.preventDefault();
      return !0;
    }, !0);
    h.addEventListener("contextmenu", function(a) {
      if (2 != a.button) {
        return !1;
      }
      a.preventDefault();
      return !1;
    }, !0);
    h.addEventListener("mousedown", function(a) {
      if (2 == a.button) {
        return c.close(), a.preventDefault(), !0;
      }
    }, !0);
    this.root = h;
    if (b.title) {
      var n = document.createElement("div");
      n.className = "litemenu-title";
      n.innerHTML = b.title;
      h.appendChild(n);
    }
    n = 0;
    for (var d in a) {
      var e = a.constructor == Array ? a[d] : d;
      null != e && e.constructor !== String && (e = void 0 === e.content ? String(e) : e.content);
      this.addItem(e, a[d], b);
      n++;
    }
    h.addEventListener("mouseleave", function(a) {
      c.lock || c.close(a);
    });
    a = document;
    b.event && (a = b.event.target.ownerDocument);
    a || (a = document);
    a.body.appendChild(h);
    d = b.left || 0;
    a = b.top || 0;
    b.event && (d = b.event.pageX - 10, a = b.event.pageY - 10, b.title && (a -= 20), b.parentMenu && (b = b.parentMenu.root.getBoundingClientRect(), d = b.left + b.width), b = document.body.getBoundingClientRect(), n = h.getBoundingClientRect(), d > b.width - n.width - 10 && (d = b.width - n.width - 10), a > b.height - n.height - 10 && (a = b.height - n.height - 10));
    h.style.left = d + "px";
    h.style.top = a + "px";
  }
  var k = d.LiteGraph = {NODE_TITLE_HEIGHT:16, NODE_SLOT_HEIGHT:15, NODE_WIDTH:140, NODE_MIN_WIDTH:50, NODE_COLLAPSED_RADIUS:10, NODE_COLLAPSED_WIDTH:80, CANVAS_GRID_SIZE:10, NODE_TITLE_COLOR:"#222", NODE_DEFAULT_COLOR:"#999", NODE_DEFAULT_BGCOLOR:"#444", NODE_DEFAULT_BOXCOLOR:"#AEF", NODE_DEFAULT_SHAPE:"box", MAX_NUMBER_OF_NODES:1000, DEFAULT_POSITION:[100, 100], node_images_path:"", INPUT:1, OUTPUT:2, EVENT:-1, ACTION:-1, ALWAYS:0, ON_EVENT:1, NEVER:2, proxy:null, debug:!1, throw_errors:!0, allow_scripts:!0, 
  registered_node_types:{}, node_types_by_file_extension:{}, Nodes:{}, registerNodeType:function(a, b) {
    if (!b.prototype) {
      throw "Cannot register a simple object, it must be a class with a prototype";
    }
    b.type = a;
    k.debug && console.log("Node registered: " + a);
    a.split("/");
    var c = b.constructor.name, h = a.lastIndexOf("/");
    b.category = a.substr(0, h);
    b.title || (b.title = c);
    if (b.prototype) {
      for (var n in LGraphNode.prototype) {
        b.prototype[n] || (b.prototype[n] = LGraphNode.prototype[n]);
      }
    }
    this.registered_node_types[a] = b;
    b.constructor.name && (this.Nodes[c] = b);
    b.prototype.onPropertyChange && console.warn("LiteGraph node class " + a + " has onPropertyChange method, it must be called onPropertyChanged with d at the end");
    if (b.supported_extensions) {
      for (n in b.supported_extensions) {
        this.node_types_by_file_extension[b.supported_extensions[n].toLowerCase()] = b;
      }
    }
  }, addNodeMethod:function(a, b) {
    LGraphNode.prototype[a] = b;
    for (var c in this.registered_node_types) {
      var h = this.registered_node_types[c];
      h.prototype[a] && (h.prototype["_" + a] = h.prototype[a]);
      h.prototype[a] = b;
    }
  }, createNode:function(a, b, c) {
    var h = this.registered_node_types[a];
    if (!h) {
      return k.debug && console.log('GraphNode type "' + a + '" not registered.'), null;
    }
    b = b || h.title || a;
    h = new h(name);
    h.type = a;
    h.title || (h.title = b);
    h.properties || (h.properties = {});
    h.properties_info || (h.properties_info = []);
    h.flags || (h.flags = {});
    h.size || (h.size = h.computeSize());
    h.pos || (h.pos = k.DEFAULT_POSITION.concat());
    h.mode || (h.mode = k.ALWAYS);
    if (c) {
      for (var n in c) {
        h[n] = c[n];
      }
    }
    return h;
  }, getNodeType:function(a) {
    return this.registered_node_types[a];
  }, getNodeTypesInCategory:function(a) {
    var b = [], c;
    for (c in this.registered_node_types) {
      "" == a ? null == this.registered_node_types[c].category && b.push(this.registered_node_types[c]) : this.registered_node_types[c].category == a && b.push(this.registered_node_types[c]);
    }
    return b;
  }, getNodeTypesCategories:function() {
    var a = {"":1}, b;
    for (b in this.registered_node_types) {
      this.registered_node_types[b].category && !this.registered_node_types[b].skip_list && (a[this.registered_node_types[b].category] = 1);
    }
    var c = [];
    for (b in a) {
      c.push(b);
    }
    return c;
  }, reloadNodes:function(a) {
    var b = document.getElementsByTagName("script"), c = [], h;
    for (h in b) {
      c.push(b[h]);
    }
    b = document.getElementsByTagName("head")[0];
    a = document.location.href + a;
    for (h in c) {
      var n = c[h].src;
      if (n && n.substr(0, a.length) == a) {
        try {
          k.debug && console.log("Reloading: " + n);
          var d = document.createElement("script");
          d.type = "text/javascript";
          d.src = n;
          b.appendChild(d);
          b.removeChild(c[h]);
        } catch (u) {
          if (k.throw_errors) {
            throw u;
          }
          k.debug && console.log("Error while reloading " + n);
        }
      }
    }
    k.debug && console.log("Nodes reloaded");
  }, cloneObject:function(a, b) {
    if (null == a) {
      return null;
    }
    a = JSON.parse(JSON.stringify(a));
    if (!b) {
      return a;
    }
    for (var c in a) {
      b[c] = a[c];
    }
    return b;
  }, isValidConnection:function(a, b) {
    return !a || !b || a == a || a !== k.EVENT && b !== k.EVENT && a.toLowerCase() == b.toLowerCase() ? !0 : !1;
  }};
  k.getTime = "undefined" != typeof performance ? function() {
    return performance.now();
  } : function() {
    return Date.now();
  };
  d.LGraph = k.LGraph = function() {
    k.debug && console.log("Graph created");
    this.list_of_graphcanvas = null;
    this.clear();
  };
  LGraph.supported_types = ["number", "string", "boolean"];
  LGraph.prototype.getSupportedTypes = function() {
    return this.supported_types || LGraph.supported_types;
  };
  LGraph.STATUS_STOPPED = 1;
  LGraph.STATUS_RUNNING = 2;
  LGraph.prototype.clear = function() {
    this.stop();
    this.status = LGraph.STATUS_STOPPED;
    this.last_node_id = 0;
    this._nodes = [];
    this._nodes_by_id = {};
    this._nodes_executable = this._nodes_in_order = null;
    this.last_link_id = 0;
    this.links = {};
    this.iteration = 0;
    this.config = {};
    this.fixedtime = this.runningtime = this.globaltime = 0;
    this.elapsed_time = this.fixedtime_lapse = 0.01;
    this.starttime = 0;
    this.catch_errors = !0;
    this.global_inputs = {};
    this.global_outputs = {};
    this.debug = !0;
    this.change();
    this.sendActionToCanvas("clear");
  };
  LGraph.prototype.attachCanvas = function(a) {
    if (a.constructor != LGraphCanvas) {
      throw "attachCanvas expects a LGraphCanvas instance";
    }
    a.graph && a.graph != this && a.graph.detachCanvas(a);
    a.graph = this;
    this.list_of_graphcanvas || (this.list_of_graphcanvas = []);
    this.list_of_graphcanvas.push(a);
  };
  LGraph.prototype.detachCanvas = function(a) {
    if (this.list_of_graphcanvas) {
      var b = this.list_of_graphcanvas.indexOf(a);
      -1 != b && (a.graph = null, this.list_of_graphcanvas.splice(b, 1));
    }
  };
  LGraph.prototype.start = function(a) {
    if (this.status != LGraph.STATUS_RUNNING) {
      this.status = LGraph.STATUS_RUNNING;
      if (this.onPlayEvent) {
        this.onPlayEvent();
      }
      this.sendEventToAllNodes("onStart");
      this.starttime = k.getTime();
      var b = this;
      this.execution_timer_id = setInterval(function() {
        b.runStep(1, !this.catch_errors);
      }, a || 1);
    }
  };
  LGraph.prototype.stop = function() {
    if (this.status != LGraph.STATUS_STOPPED) {
      this.status = LGraph.STATUS_STOPPED;
      if (this.onStopEvent) {
        this.onStopEvent();
      }
      null != this.execution_timer_id && clearInterval(this.execution_timer_id);
      this.execution_timer_id = null;
      this.sendEventToAllNodes("onStop");
    }
  };
  LGraph.prototype.runStep = function(a, b) {
    a = a || 1;
    var c = k.getTime();
    this.globaltime = 0.001 * (c - this.starttime);
    var h = this._nodes_executable ? this._nodes_executable : this._nodes;
    if (h) {
      if (b) {
        for (var n = 0; n < a; n++) {
          for (var d = 0, e = h.length; d < e; ++d) {
            var f = h[d];
            if (f.mode == k.ALWAYS && f.onExecute) {
              f.onExecute();
            }
          }
          this.fixedtime += this.fixedtime_lapse;
          if (this.onExecuteStep) {
            this.onExecuteStep();
          }
        }
        if (this.onAfterExecute) {
          this.onAfterExecute();
        }
      } else {
        try {
          for (n = 0; n < a; n++) {
            d = 0;
            for (e = h.length; d < e; ++d) {
              if (f = h[d], f.mode == k.ALWAYS && f.onExecute) {
                f.onExecute();
              }
            }
            this.fixedtime += this.fixedtime_lapse;
            if (this.onExecuteStep) {
              this.onExecuteStep();
            }
          }
          if (this.onAfterExecute) {
            this.onAfterExecute();
          }
          this.errors_in_execution = !1;
        } catch (t) {
          this.errors_in_execution = !0;
          if (k.throw_errors) {
            throw t;
          }
          k.debug && console.log("Error during execution: " + t);
          this.stop();
        }
      }
      a = k.getTime() - c;
      0 == a && (a = 1);
      this.elapsed_time = 0.001 * a;
      this.globaltime += 0.001 * a;
      this.iteration += 1;
    }
  };
  LGraph.prototype.updateExecutionOrder = function() {
    this._nodes_in_order = this.computeExecutionOrder(!1);
    this._nodes_executable = [];
    for (var a = 0; a < this._nodes_in_order.length; ++a) {
      this._nodes_in_order[a].onExecute && this._nodes_executable.push(this._nodes_in_order[a]);
    }
  };
  LGraph.prototype.computeExecutionOrder = function(a) {
    for (var b = [], c = [], h = {}, n = {}, d = {}, e = 0, f = this._nodes.length; e < f; ++e) {
      var g = this._nodes[e];
      if (!a || g.onExecute) {
        h[g.id] = g;
        var l = 0;
        if (g.inputs) {
          for (var q = 0, w = g.inputs.length; q < w; q++) {
            g.inputs[q] && null != g.inputs[q].link && (l += 1);
          }
        }
        0 == l ? c.push(g) : d[g.id] = l;
      }
    }
    for (; 0 != c.length;) {
      if (g = c.shift(), b.push(g), delete h[g.id], g.outputs) {
        for (e = 0; e < g.outputs.length; e++) {
          if (a = g.outputs[e], null != a && null != a.links && 0 != a.links.length) {
            for (q = 0; q < a.links.length; q++) {
              (f = this.links[a.links[q]]) && !n[f.id] && (l = this.getNodeById(f.target_id), null == l ? n[f.id] = !0 : (n[f.id] = !0, --d[l.id], 0 == d[l.id] && c.push(l)));
            }
          }
        }
      }
    }
    for (e in h) {
      b.push(h[e]);
    }
    b.length != this._nodes.length && k.debug && console.warn("something went wrong, nodes missing");
    for (e = 0; e < b.length; ++e) {
      b[e].order = e;
    }
    return b;
  };
  LGraph.prototype.getTime = function() {
    return this.globaltime;
  };
  LGraph.prototype.getFixedTime = function() {
    return this.fixedtime;
  };
  LGraph.prototype.getElapsedTime = function() {
    return this.elapsed_time;
  };
  LGraph.prototype.sendEventToAllNodes = function(a, b, c) {
    c = c || k.ALWAYS;
    var h = this._nodes_in_order ? this._nodes_in_order : this._nodes;
    if (h) {
      for (var n = 0, d = h.length; n < d; ++n) {
        var e = h[n];
        if (e[a] && e.mode == c) {
          if (void 0 === b) {
            e[a]();
          } else {
            if (b && b.constructor === Array) {
              e[a].apply(e, b);
            } else {
              e[a](b);
            }
          }
        }
      }
    }
  };
  LGraph.prototype.sendActionToCanvas = function(a, b) {
    if (this.list_of_graphcanvas) {
      for (var c = 0; c < this.list_of_graphcanvas.length; ++c) {
        var h = this.list_of_graphcanvas[c];
        h[a] && h[a].apply(h, b);
      }
    }
  };
  LGraph.prototype.add = function(a, b) {
    if (a && (-1 == a.id || null == this._nodes_by_id[a.id])) {
      if (this._nodes.length >= k.MAX_NUMBER_OF_NODES) {
        throw "LiteGraph: max number of nodes in a graph reached";
      }
      null == a.id || -1 == a.id ? a.id = ++this.last_node_id : this.last_node_id < a.id && (this.last_node_id = a.id);
      a.graph = this;
      this._nodes.push(a);
      this._nodes_by_id[a.id] = a;
      if (a.onAdded) {
        a.onAdded(this);
      }
      this.config.align_to_grid && a.alignToGrid();
      b || this.updateExecutionOrder();
      if (this.onNodeAdded) {
        this.onNodeAdded(a);
      }
      this.setDirtyCanvas(!0);
      this.change();
      return a;
    }
  };
  LGraph.prototype.remove = function(a) {
    if (null != this._nodes_by_id[a.id] && !a.ignore_remove) {
      if (a.inputs) {
        for (var b = 0; b < a.inputs.length; b++) {
          var c = a.inputs[b];
          null != c.link && a.disconnectInput(b);
        }
      }
      if (a.outputs) {
        for (b = 0; b < a.outputs.length; b++) {
          c = a.outputs[b], null != c.links && c.links.length && a.disconnectOutput(b);
        }
      }
      if (a.onRemoved) {
        a.onRemoved();
      }
      a.graph = null;
      if (this.list_of_graphcanvas) {
        for (b = 0; b < this.list_of_graphcanvas.length; ++b) {
          c = this.list_of_graphcanvas[b], c.selected_nodes[a.id] && delete c.selected_nodes[a.id], c.node_dragged == a && (c.node_dragged = null);
        }
      }
      b = this._nodes.indexOf(a);
      -1 != b && this._nodes.splice(b, 1);
      delete this._nodes_by_id[a.id];
      if (this.onNodeRemoved) {
        this.onNodeRemoved(a);
      }
      this.setDirtyCanvas(!0, !0);
      this.change();
      this.updateExecutionOrder();
    }
  };
  LGraph.prototype.getNodeById = function(a) {
    return null == a ? null : this._nodes_by_id[a];
  };
  LGraph.prototype.findNodesByClass = function(a) {
    for (var b = [], c = 0, h = this._nodes.length; c < h; ++c) {
      this._nodes[c].constructor === a && b.push(this._nodes[c]);
    }
    return b;
  };
  LGraph.prototype.findNodesByType = function(a) {
    a = a.toLowerCase();
    for (var b = [], c = 0, h = this._nodes.length; c < h; ++c) {
      this._nodes[c].type.toLowerCase() == a && b.push(this._nodes[c]);
    }
    return b;
  };
  LGraph.prototype.findNodesByTitle = function(a) {
    for (var b = [], c = 0, h = this._nodes.length; c < h; ++c) {
      this._nodes[c].title == a && b.push(this._nodes[c]);
    }
    return b;
  };
  LGraph.prototype.getNodeOnPos = function(a, b, c) {
    c = c || this._nodes;
    for (var h = c.length - 1; 0 <= h; h--) {
      var n = c[h];
      if (n.isPointInsideNode(a, b, 2)) {
        return n;
      }
    }
    return null;
  };
  LGraph.prototype.addGlobalInput = function(a, b, c) {
    this.global_inputs[a] = {name:a, type:b, value:c};
    if (this.onGlobalInputAdded) {
      this.onGlobalInputAdded(a, b);
    }
    if (this.onGlobalsChange) {
      this.onGlobalsChange();
    }
  };
  LGraph.prototype.setGlobalInputData = function(a, b) {
    if (a = this.global_inputs[a]) {
      a.value = b;
    }
  };
  LGraph.prototype.getGlobalInputData = function(a) {
    return (a = this.global_inputs[a]) ? a.value : null;
  };
  LGraph.prototype.renameGlobalInput = function(a, b) {
    if (b != a) {
      if (!this.global_inputs[a]) {
        return !1;
      }
      if (this.global_inputs[b]) {
        return console.error("there is already one input with that name"), !1;
      }
      this.global_inputs[b] = this.global_inputs[a];
      delete this.global_inputs[a];
      if (this.onGlobalInputRenamed) {
        this.onGlobalInputRenamed(a, b);
      }
      if (this.onGlobalsChange) {
        this.onGlobalsChange();
      }
    }
  };
  LGraph.prototype.changeGlobalInputType = function(a, b) {
    if (!this.global_inputs[a]) {
      return !1;
    }
    if (this.global_inputs[a].type.toLowerCase() != b.toLowerCase() && (this.global_inputs[a].type = b, this.onGlobalInputTypeChanged)) {
      this.onGlobalInputTypeChanged(a, b);
    }
  };
  LGraph.prototype.removeGlobalInput = function(a) {
    if (!this.global_inputs[a]) {
      return !1;
    }
    delete this.global_inputs[a];
    if (this.onGlobalInputRemoved) {
      this.onGlobalInputRemoved(a);
    }
    if (this.onGlobalsChange) {
      this.onGlobalsChange();
    }
    return !0;
  };
  LGraph.prototype.addGlobalOutput = function(a, b, c) {
    this.global_outputs[a] = {name:a, type:b, value:c};
    if (this.onGlobalOutputAdded) {
      this.onGlobalOutputAdded(a, b);
    }
    if (this.onGlobalsChange) {
      this.onGlobalsChange();
    }
  };
  LGraph.prototype.setGlobalOutputData = function(a, b) {
    if (a = this.global_outputs[a]) {
      a.value = b;
    }
  };
  LGraph.prototype.getGlobalOutputData = function(a) {
    return (a = this.global_outputs[a]) ? a.value : null;
  };
  LGraph.prototype.renameGlobalOutput = function(a, b) {
    if (!this.global_outputs[a]) {
      return !1;
    }
    if (this.global_outputs[b]) {
      return console.error("there is already one output with that name"), !1;
    }
    this.global_outputs[b] = this.global_outputs[a];
    delete this.global_outputs[a];
    if (this.onGlobalOutputRenamed) {
      this.onGlobalOutputRenamed(a, b);
    }
    if (this.onGlobalsChange) {
      this.onGlobalsChange();
    }
  };
  LGraph.prototype.changeGlobalOutputType = function(a, b) {
    if (!this.global_outputs[a]) {
      return !1;
    }
    if (this.global_outputs[a].type.toLowerCase() != b.toLowerCase() && (this.global_outputs[a].type = b, this.onGlobalOutputTypeChanged)) {
      this.onGlobalOutputTypeChanged(a, b);
    }
  };
  LGraph.prototype.removeGlobalOutput = function(a) {
    if (!this.global_outputs[a]) {
      return !1;
    }
    delete this.global_outputs[a];
    if (this.onGlobalOutputRemoved) {
      this.onGlobalOutputRemoved(a);
    }
    if (this.onGlobalsChange) {
      this.onGlobalsChange();
    }
    return !0;
  };
  LGraph.prototype.setInputData = function(a, b) {
    a = this.findNodesByName(a);
    for (var c = 0, h = a.length; c < h; ++c) {
      a[c].setValue(b);
    }
  };
  LGraph.prototype.getOutputData = function(a) {
    return this.findNodesByName(a).length ? m[0].getValue() : null;
  };
  LGraph.prototype.triggerInput = function(a, b) {
    a = this.findNodesByName(a);
    for (var c = 0; c < a.length; ++c) {
      a[c].onTrigger(b);
    }
  };
  LGraph.prototype.setCallback = function(a, b) {
    a = this.findNodesByName(a);
    for (var c = 0; c < a.length; ++c) {
      a[c].setTrigger(b);
    }
  };
  LGraph.prototype.connectionChange = function(a) {
    this.updateExecutionOrder();
    if (this.onConnectionChange) {
      this.onConnectionChange(a);
    }
    this.sendActionToCanvas("onConnectionChange");
  };
  LGraph.prototype.isLive = function() {
    if (!this.list_of_graphcanvas) {
      return !1;
    }
    for (var a = 0; a < this.list_of_graphcanvas.length; ++a) {
      if (this.list_of_graphcanvas[a].live_mode) {
        return !0;
      }
    }
    return !1;
  };
  LGraph.prototype.change = function() {
    k.debug && console.log("Graph changed");
    this.sendActionToCanvas("setDirty", [!0, !0]);
    if (this.on_change) {
      this.on_change(this);
    }
  };
  LGraph.prototype.setDirtyCanvas = function(a, b) {
    this.sendActionToCanvas("setDirty", [a, b]);
  };
  LGraph.prototype.serialize = function() {
    for (var a = [], b = 0, c = this._nodes.length; b < c; ++b) {
      a.push(this._nodes[b].serialize());
    }
    c = [];
    for (b in this.links) {
      var h = this.links[b];
      c.push([h.id, h.origin_id, h.origin_slot, h.target_id, h.target_slot]);
    }
    return {iteration:this.iteration, frame:this.frame, last_node_id:this.last_node_id, last_link_id:this.last_link_id, links:c, config:this.config, nodes:a};
  };
  LGraph.prototype.configure = function(a, b) {
    b || this.clear();
    b = a.nodes;
    if (a.links && a.links.constructor === Array) {
      for (var c = {}, h = 0; h < a.links.length; ++h) {
        var n = a.links[h];
        c[n[0]] = {id:n[0], origin_id:n[1], origin_slot:n[2], target_id:n[3], target_slot:n[4]};
      }
      a.links = c;
    }
    for (h in a) {
      this[h] = a[h];
    }
    a = !1;
    this._nodes = [];
    h = 0;
    for (c = b.length; h < c; ++h) {
      n = b[h];
      var e = k.createNode(n.type, n.title);
      e ? (e.id = n.id, this.add(e, !0)) : (k.debug && console.log("Node not found: " + n.type), a = !0);
    }
    h = 0;
    for (c = b.length; h < c; ++h) {
      n = b[h], (e = this.getNodeById(n.id)) && e.configure(n);
    }
    this.updateExecutionOrder();
    this.setDirtyCanvas(!0, !0);
    return a;
  };
  LGraph.prototype.load = function(a) {
    var b = this, c = new XMLHttpRequest;
    c.open("GET", a, !0);
    c.send(null);
    c.onload = function(a) {
      200 !== c.status ? console.error("Error loading graph:", c.status, c.response) : (a = JSON.parse(c.response), b.configure(a));
    };
    c.onerror = function(a) {
      console.error("Error loading graph:", a);
    };
  };
  LGraph.prototype.onNodeTrace = function(a, b, c) {
  };
  d.LGraphNode = k.LGraphNode = function(a) {
    this._ctor();
  };
  LGraphNode.prototype._ctor = function(a) {
    this.title = a || "Unnamed";
    this.size = [k.NODE_WIDTH, 60];
    this.graph = null;
    this._pos = new Float32Array(10, 10);
    Object.defineProperty(this, "pos", {set:function(a) {
      !a || 2 > !a.length || (this._pos[0] = a[0], this._pos[1] = a[1]);
    }, get:function() {
      return this._pos;
    }, enumerable:!0});
    this.id = -1;
    this.type = null;
    this.inputs = [];
    this.outputs = [];
    this.connections = [];
    this.properties = {};
    this.properties_info = [];
    this.data = null;
    this.flags = {};
  };
  LGraphNode.prototype.configure = function(a) {
    for (var b in a) {
      if ("console" != b) {
        if ("properties" == b) {
          for (var c in a.properties) {
            if (this.properties[c] = a.properties[c], this.onPropertyChanged) {
              this.onPropertyChanged(c, a.properties[c]);
            }
          }
        } else {
          null != a[b] && ("object" == typeof a[b] ? this[b] && this[b].configure ? this[b].configure(a[b]) : this[b] = k.cloneObject(a[b], this[b]) : this[b] = a[b]);
        }
      }
    }
    if (this.onConnectionsChange) {
      if (this.inputs) {
        for (var h = 0; h < this.inputs.length; ++h) {
          c = this.inputs[h];
          var n = this.graph.links[c.link];
          this.onConnectionsChange(k.INPUT, h, !0, n, c);
        }
      }
      if (this.outputs) {
        for (h = 0; h < this.outputs.length; ++h) {
          if (c = this.outputs[h], c.links) {
            for (b = 0; b < c.links.length; ++b) {
              n = this.graph.links[c.links[b]], this.onConnectionsChange(k.OUTPUT, h, !0, n, c);
            }
          }
        }
      }
    }
    for (h in this.inputs) {
      c = this.inputs[h], c.link && c.link.length && (n = c.link, "object" == typeof n && (c.link = n[0], this.graph.links[n[0]] = {id:n[0], origin_id:n[1], origin_slot:n[2], target_id:n[3], target_slot:n[4]}));
    }
    for (h in this.outputs) {
      if (c = this.outputs[h], c.links && 0 != c.links.length) {
        for (b in c.links) {
          n = c.links[b], "object" == typeof n && (c.links[b] = n[0]);
        }
      }
    }
    if (this.onConfigure) {
      this.onConfigure(a);
    }
  };
  LGraphNode.prototype.serialize = function() {
    if (this.outputs) {
      for (var a = 0; a < this.outputs.length; a++) {
        delete this.outputs[a]._data;
      }
    }
    a = {id:this.id, title:this.title, type:this.type, pos:this.pos, size:this.size, data:this.data, flags:k.cloneObject(this.flags), inputs:this.inputs, outputs:this.outputs, mode:this.mode};
    this.properties && (a.properties = k.cloneObject(this.properties));
    a.type || (a.type = this.constructor.type);
    this.color && (a.color = this.color);
    this.bgcolor && (a.bgcolor = this.bgcolor);
    this.boxcolor && (a.boxcolor = this.boxcolor);
    this.shape && (a.shape = this.shape);
    if (this.onSerialize) {
      this.onSerialize(a);
    }
    return a;
  };
  LGraphNode.prototype.clone = function() {
    var a = k.createNode(this.type), b = k.cloneObject(this.serialize());
    if (b.inputs) {
      for (var c = 0; c < b.inputs.length; ++c) {
        b.inputs[c].link = null;
      }
    }
    if (b.outputs) {
      for (c = 0; c < b.outputs.length; ++c) {
        b.outputs[c].links && (b.outputs[c].links.length = 0);
      }
    }
    delete b.id;
    a.configure(b);
    return a;
  };
  LGraphNode.prototype.toString = function() {
    return JSON.stringify(this.serialize());
  };
  LGraphNode.prototype.getTitle = function() {
    return this.title || this.constructor.title;
  };
  LGraphNode.prototype.setOutputData = function(a, b) {
    if (this.outputs && !(-1 == a || a >= this.outputs.length)) {
      var c = this.outputs[a];
      if (c && (c._data = b, this.outputs[a].links)) {
        for (c = 0; c < this.outputs[a].links.length; c++) {
          this.graph.links[this.outputs[a].links[c]].data = b;
        }
      }
    }
  };
  LGraphNode.prototype.getInputData = function(a, b) {
    if (this.inputs && !(a >= this.inputs.length || null == this.inputs[a].link)) {
      a = this.graph.links[this.inputs[a].link];
      if (!b) {
        return a.data;
      }
      b = this.graph.getNodeById(a.origin_id);
      if (!b) {
        return a.data;
      }
      if (b.updateOutputData) {
        b.updateOutputData(a.origin_slot);
      } else {
        if (b.onExecute) {
          b.onExecute();
        }
      }
      return a.data;
    }
  };
  LGraphNode.prototype.isInputConnected = function(a) {
    return this.inputs ? a < this.inputs.length && null != this.inputs[a].link : !1;
  };
  LGraphNode.prototype.getInputInfo = function(a) {
    return this.inputs ? a < this.inputs.length ? this.inputs[a] : null : null;
  };
  LGraphNode.prototype.getInputNode = function(a) {
    if (!this.inputs || a >= this.inputs.length) {
      return null;
    }
    a = this.inputs[a];
    return a && a.link ? (a = this.graph.links[a.link]) ? this.graph.getNodeById(a.origin_id) : null : null;
  };
  LGraphNode.prototype.getOutputData = function(a) {
    return !this.outputs || a >= this.outputs.length ? null : this.outputs[a]._data;
  };
  LGraphNode.prototype.getOutputInfo = function(a) {
    return this.outputs ? a < this.outputs.length ? this.outputs[a] : null : null;
  };
  LGraphNode.prototype.isOutputConnected = function(a) {
    return this.outputs ? a < this.outputs.length && this.outputs[a].links && this.outputs[a].links.length : null;
  };
  LGraphNode.prototype.getOutputNodes = function(a) {
    if (!this.outputs || 0 == this.outputs.length || a >= this.outputs.length) {
      return null;
    }
    a = this.outputs[a];
    if (!a.links || 0 == a.links.length) {
      return null;
    }
    for (var b = [], c = 0; c < a.links.length; c++) {
      var h = this.graph.links[a.links[c]];
      h && (h = this.graph.getNodeById(h.target_id)) && b.push(h);
    }
    return b;
  };
  LGraphNode.prototype.trigger = function(a, b) {
    if (this.outputs && this.outputs.length) {
      this.graph && (this.graph._last_trigger_time = k.getTime());
      for (var c = 0; c < this.outputs.length; ++c) {
        var h = this.outputs[c];
        if (!(h.type !== k.EVENT || a && h.name != a) && (h = h.links) && h.length) {
          for (var n = 0; n < h.length; ++n) {
            var e = this.graph.links[h[n]];
            if (e) {
              var d = this.graph.getNodeById(e.target_id);
              if (d) {
                if (e._last_time = k.getTime(), e = d.inputs[e.target_slot], d.onAction) {
                  d.onAction(e.name, b);
                } else {
                  if (d.mode === k.ON_TRIGGER && d.onExecute) {
                    d.onExecute(b);
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  LGraphNode.prototype.addProperty = function(a, b, c, h) {
    c = {name:a, type:c, default_value:b};
    if (h) {
      for (var e in h) {
        c[e] = h[e];
      }
    }
    this.properties_info || (this.properties_info = []);
    this.properties_info.push(c);
    this.properties || (this.properties = {});
    this.properties[a] = b;
    return c;
  };
  LGraphNode.prototype.addOutput = function(a, b, c) {
    a = {name:a, type:b, links:null};
    if (c) {
      for (var h in c) {
        a[h] = c[h];
      }
    }
    this.outputs || (this.outputs = []);
    this.outputs.push(a);
    if (this.onOutputAdded) {
      this.onOutputAdded(a);
    }
    this.size = this.computeSize();
    return a;
  };
  LGraphNode.prototype.addOutputs = function(a) {
    for (var b = 0; b < a.length; ++b) {
      var c = a[b], h = {name:c[0], type:c[1], link:null};
      if (a[2]) {
        for (var e in c[2]) {
          h[e] = c[2][e];
        }
      }
      this.outputs || (this.outputs = []);
      this.outputs.push(h);
      if (this.onOutputAdded) {
        this.onOutputAdded(h);
      }
    }
    this.size = this.computeSize();
  };
  LGraphNode.prototype.removeOutput = function(a) {
    this.disconnectOutput(a);
    this.outputs.splice(a, 1);
    this.size = this.computeSize();
    if (this.onOutputRemoved) {
      this.onOutputRemoved(a);
    }
  };
  LGraphNode.prototype.addInput = function(a, b, c) {
    a = {name:a, type:b || 0, link:null};
    if (c) {
      for (var h in c) {
        a[h] = c[h];
      }
    }
    this.inputs || (this.inputs = []);
    this.inputs.push(a);
    this.size = this.computeSize();
    if (this.onInputAdded) {
      this.onInputAdded(a);
    }
    return a;
  };
  LGraphNode.prototype.addInputs = function(a) {
    for (var b = 0; b < a.length; ++b) {
      var c = a[b], h = {name:c[0], type:c[1], link:null};
      if (a[2]) {
        for (var e in c[2]) {
          h[e] = c[2][e];
        }
      }
      this.inputs || (this.inputs = []);
      this.inputs.push(h);
      if (this.onInputAdded) {
        this.onInputAdded(h);
      }
    }
    this.size = this.computeSize();
  };
  LGraphNode.prototype.removeInput = function(a) {
    this.disconnectInput(a);
    this.inputs.splice(a, 1);
    this.size = this.computeSize();
    if (this.onInputRemoved) {
      this.onInputRemoved(a);
    }
  };
  LGraphNode.prototype.addConnection = function(a, b, c, h) {
    a = {name:a, type:b, pos:c, direction:h, links:null};
    this.connections.push(a);
    return a;
  };
  LGraphNode.prototype.computeSize = function(a, b) {
    a = Math.max(this.inputs ? this.inputs.length : 1, this.outputs ? this.outputs.length : 1);
    b = b || new Float32Array([0, 0]);
    a = Math.max(a, 1);
    b[1] = 14 * a + 6;
    a = (a = this.title) ? 8.4 * a.length : 0;
    var c = 0, h = 0;
    if (this.inputs) {
      for (var e = 0, d = this.inputs.length; e < d; ++e) {
        var f = this.inputs[e];
        f = (f = f.label || f.name || "") ? 8.4 * f.length : 0;
        c < f && (c = f);
      }
    }
    if (this.outputs) {
      for (e = 0, d = this.outputs.length; e < d; ++e) {
        f = this.outputs[e], f = (f = f.label || f.name || "") ? 8.4 * f.length : 0, h < f && (h = f);
      }
    }
    b[0] = Math.max(c + h + 10, a);
    b[0] = Math.max(b[0], k.NODE_WIDTH);
    return b;
  };
  LGraphNode.prototype.getBounding = function() {
    return new Float32Array([this.pos[0] - 4, this.pos[1] - k.NODE_TITLE_HEIGHT, this.pos[0] + this.size[0] + 4, this.pos[1] + this.size[1] + LGraph.NODE_TITLE_HEIGHT]);
  };
  LGraphNode.prototype.isPointInsideNode = function(a, b, c) {
    c = c || 0;
    var h = this.graph && this.graph.isLive() ? 0 : 20;
    if (this.flags.collapsed) {
      if (f(a, b, this.pos[0] - c, this.pos[1] - k.NODE_TITLE_HEIGHT - c, k.NODE_COLLAPSED_WIDTH + 2 * c, k.NODE_TITLE_HEIGHT + 2 * c)) {
        return !0;
      }
    } else {
      if (this.pos[0] - 4 - c < a && this.pos[0] + this.size[0] + 4 + c > a && this.pos[1] - h - c < b && this.pos[1] + this.size[1] + c > b) {
        return !0;
      }
    }
    return !1;
  };
  LGraphNode.prototype.getSlotInPosition = function(a, b) {
    if (this.inputs) {
      for (var c = 0, h = this.inputs.length; c < h; ++c) {
        var e = this.inputs[c], d = this.getConnectionPos(!0, c);
        if (f(a, b, d[0] - 10, d[1] - 5, 20, 10)) {
          return {input:e, slot:c, link_pos:d, locked:e.locked};
        }
      }
    }
    if (this.outputs) {
      for (c = 0, h = this.outputs.length; c < h; ++c) {
        if (e = this.outputs[c], d = this.getConnectionPos(!1, c), f(a, b, d[0] - 10, d[1] - 5, 20, 10)) {
          return {output:e, slot:c, link_pos:d, locked:e.locked};
        }
      }
    }
    return null;
  };
  LGraphNode.prototype.findInputSlot = function(a) {
    if (!this.inputs) {
      return -1;
    }
    for (var b = 0, c = this.inputs.length; b < c; ++b) {
      if (a == this.inputs[b].name) {
        return b;
      }
    }
    return -1;
  };
  LGraphNode.prototype.findOutputSlot = function(a) {
    if (!this.outputs) {
      return -1;
    }
    for (var b = 0, c = this.outputs.length; b < c; ++b) {
      if (a == this.outputs[b].name) {
        return b;
      }
    }
    return -1;
  };
  LGraphNode.prototype.connect = function(a, b, c) {
    c = c || 0;
    if (a.constructor === String) {
      if (a = this.findOutputSlot(a), -1 == a) {
        return k.debug && console.log("Connect: Error, no slot of name " + a), !1;
      }
    } else {
      if (!this.outputs || a >= this.outputs.length) {
        return k.debug && console.log("Connect: Error, slot number not found"), !1;
      }
    }
    b && b.constructor === Number && (b = this.graph.getNodeById(b));
    if (!b) {
      throw "Node not found";
    }
    if (b == this) {
      return !1;
    }
    if (c.constructor === String) {
      if (c = b.findInputSlot(c), -1 == c) {
        return k.debug && console.log("Connect: Error, no slot of name " + c), !1;
      }
    } else {
      if (c === k.EVENT) {
        return !1;
      }
      if (!b.inputs || c >= b.inputs.length) {
        return k.debug && console.log("Connect: Error, slot number not found"), !1;
      }
    }
    null != b.inputs[c].link && b.disconnectInput(c);
    this.setDirtyCanvas(!1, !0);
    this.graph.connectionChange(this);
    var h = this.outputs[a];
    if (b.onConnectInput && !1 === b.onConnectInput(c, h.type, h)) {
      return !1;
    }
    var e = b.inputs[c];
    if (k.isValidConnection(h.type, e.type)) {
      var d = {id:this.graph.last_link_id++, type:e.type, origin_id:this.id, origin_slot:a, target_id:b.id, target_slot:c};
      this.graph.links[d.id] = d;
      null == h.links && (h.links = []);
      h.links.push(d.id);
      b.inputs[c].link = d.id;
      if (this.onConnectionsChange) {
        this.onConnectionsChange(k.OUTPUT, a, !0, d, h);
      }
      if (b.onConnectionsChange) {
        b.onConnectionsChange(k.INPUT, c, !0, d, e);
      }
    }
    this.setDirtyCanvas(!1, !0);
    this.graph.connectionChange(this);
    return !0;
  };
  LGraphNode.prototype.disconnectOutput = function(a, b) {
    if (a.constructor === String) {
      if (a = this.findOutputSlot(a), -1 == a) {
        return k.debug && console.log("Connect: Error, no slot of name " + a), !1;
      }
    } else {
      if (!this.outputs || a >= this.outputs.length) {
        return k.debug && console.log("Connect: Error, slot number not found"), !1;
      }
    }
    var c = this.outputs[a];
    if (!c.links || 0 == c.links.length) {
      return !1;
    }
    if (b) {
      b.constructor === Number && (b = this.graph.getNodeById(b));
      if (!b) {
        throw "Target Node not found";
      }
      for (var h = 0, e = c.links.length; h < e; h++) {
        var d = c.links[h], f = this.graph.links[d];
        if (f.target_id == b.id) {
          c.links.splice(h, 1);
          var g = b.inputs[f.target_slot];
          g.link = null;
          delete this.graph.links[d];
          if (b.onConnectionsChange) {
            b.onConnectionsChange(k.INPUT, f.target_slot, !1, f, g);
          }
          if (this.onConnectionsChange) {
            this.onConnectionsChange(k.OUTPUT, a, !1, f, c);
          }
          break;
        }
      }
    } else {
      h = 0;
      for (e = c.links.length; h < e; h++) {
        d = c.links[h];
        f = this.graph.links[d];
        b = this.graph.getNodeById(f.target_id);
        g = null;
        b && (g = b.inputs[f.target_slot], g.link = null);
        delete this.graph.links[d];
        if (b.onConnectionsChange) {
          b.onConnectionsChange(k.INPUT, f.target_slot, !1, f, g);
        }
        if (this.onConnectionsChange) {
          this.onConnectionsChange(k.OUTPUT, a, !1, f, c);
        }
      }
      c.links = null;
    }
    this.setDirtyCanvas(!1, !0);
    this.graph.connectionChange(this);
    return !0;
  };
  LGraphNode.prototype.disconnectInput = function(a) {
    if (a.constructor === String) {
      if (a = this.findInputSlot(a), -1 == a) {
        return k.debug && console.log("Connect: Error, no slot of name " + a), !1;
      }
    } else {
      if (!this.inputs || a >= this.inputs.length) {
        return k.debug && console.log("Connect: Error, slot number not found"), !1;
      }
    }
    var b = this.inputs[a];
    if (!b) {
      return !1;
    }
    var c = this.inputs[a].link;
    this.inputs[a].link = null;
    var h = this.graph.links[c];
    if (h) {
      var e = this.graph.getNodeById(h.origin_id);
      if (!e) {
        return !1;
      }
      var d = e.outputs[h.origin_slot];
      if (!d || !d.links || 0 == d.links.length) {
        return !1;
      }
      for (var f = 0, g = d.links.length; f < g; f++) {
        if (c = d.links[f], h.target_id == this.id) {
          d.links.splice(f, 1);
          break;
        }
      }
      delete this.graph.links[c];
      if (this.onConnectionsChange) {
        this.onConnectionsChange(k.INPUT, a, !1, h, b);
      }
      if (e.onConnectionsChange) {
        e.onConnectionsChange(k.OUTPUT, f, !1, h, d);
      }
    }
    this.setDirtyCanvas(!1, !0);
    this.graph.connectionChange(this);
    return !0;
  };
  LGraphNode.prototype.getConnectionPos = function(a, b) {
    return this.flags.collapsed ? a ? [this.pos[0], this.pos[1] - 0.5 * k.NODE_TITLE_HEIGHT] : [this.pos[0] + k.NODE_COLLAPSED_WIDTH, this.pos[1] - 0.5 * k.NODE_TITLE_HEIGHT] : a && -1 == b ? [this.pos[0] + 10, this.pos[1] + 10] : a && this.inputs.length > b && this.inputs[b].pos ? [this.pos[0] + this.inputs[b].pos[0], this.pos[1] + this.inputs[b].pos[1]] : !a && this.outputs.length > b && this.outputs[b].pos ? [this.pos[0] + this.outputs[b].pos[0], this.pos[1] + this.outputs[b].pos[1]] : a ? [this.pos[0], 
    this.pos[1] + 10 + b * k.NODE_SLOT_HEIGHT] : [this.pos[0] + this.size[0] + 1, this.pos[1] + 10 + b * k.NODE_SLOT_HEIGHT];
  };
  LGraphNode.prototype.alignToGrid = function() {
    this.pos[0] = k.CANVAS_GRID_SIZE * Math.round(this.pos[0] / k.CANVAS_GRID_SIZE);
    this.pos[1] = k.CANVAS_GRID_SIZE * Math.round(this.pos[1] / k.CANVAS_GRID_SIZE);
  };
  LGraphNode.prototype.trace = function(a) {
    this.console || (this.console = []);
    this.console.push(a);
    this.console.length > LGraphNode.MAX_CONSOLE && this.console.shift();
    this.graph.onNodeTrace(this, a);
  };
  LGraphNode.prototype.setDirtyCanvas = function(a, b) {
    this.graph && this.graph.sendActionToCanvas("setDirty", [a, b]);
  };
  LGraphNode.prototype.loadImage = function(a) {
    var b = new Image;
    b.src = k.node_images_path + a;
    b.ready = !1;
    var c = this;
    b.onload = function() {
      this.ready = !0;
      c.setDirtyCanvas(!0);
    };
    return b;
  };
  LGraphNode.prototype.captureInput = function(a) {
    if (this.graph && this.graph.list_of_graphcanvas) {
      for (var b = this.graph.list_of_graphcanvas, c = 0; c < b.length; ++c) {
        var h = b[c];
        if (a || h.node_capturing_input == this) {
          h.node_capturing_input = a ? this : null;
        }
      }
    }
  };
  LGraphNode.prototype.collapse = function() {
    this.flags.collapsed = this.flags.collapsed ? !1 : !0;
    this.setDirtyCanvas(!0, !0);
  };
  LGraphNode.prototype.pin = function(a) {
    this.flags.pinned = void 0 === a ? !this.flags.pinned : a;
  };
  LGraphNode.prototype.localToScreen = function(a, b, c) {
    return [(a + this.pos[0]) * c.scale + c.offset[0], (b + this.pos[1]) * c.scale + c.offset[1]];
  };
  d.LGraphCanvas = k.LGraphCanvas = function(a, b, c) {
    c = c || {};
    this.background_image = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=";
    a && a.constructor === String && (a = document.querySelector(a));
    this.max_zoom = 10;
    this.min_zoom = 0.1;
    this.title_text_font = "bold 14px Arial";
    this.inner_text_font = "normal 12px Arial";
    this.default_link_color = "#AAC";
    this.highquality_render = !0;
    this.editor_alpha = 1;
    this.pause_rendering = !1;
    this.render_only_selected = this.clear_background = this.render_shadows = !0;
    this.live_mode = !1;
    this.allow_interaction = this.allow_dragnodes = this.allow_dragcanvas = this.show_info = !0;
    this.render_connections_shadows = this.always_render_background = !1;
    this.render_connection_arrows = this.render_curved_connections = this.render_connections_border = !0;
    this.connections_width = 3;
    b && b.attachCanvas(this);
    this.setCanvas(a);
    this.clear();
    c.skip_render || this.startRendering();
    this.autoresize = c.autoresize;
  };
  LGraphCanvas.link_type_colors = {"-1":"#F85", number:"#AAC", node:"#DCA"};
  LGraphCanvas.prototype.clear = function() {
    this.fps = this.render_time = this.last_draw_time = this.frame = 0;
    this.scale = 1;
    this.offset = [0, 0];
    this.selected_nodes = {};
    this.connecting_node = this.node_capturing_input = this.node_over = this.node_dragged = null;
    this.dirty_bgcanvas = this.dirty_canvas = !0;
    this.node_in_panel = this.dirty_area = null;
    this.last_mouse = [0, 0];
    this.last_mouseclick = 0;
    if (this.onClear) {
      this.onClear();
    }
  };
  LGraphCanvas.prototype.setGraph = function(a, b) {
    this.graph != a && (b || this.clear(), !a && this.graph ? this.graph.detachCanvas(this) : (a.attachCanvas(this), this.setDirty(!0, !0)));
  };
  LGraphCanvas.prototype.openSubgraph = function(a) {
    if (!a) {
      throw "graph cannot be null";
    }
    if (this.graph == a) {
      throw "graph cannot be the same";
    }
    this.clear();
    this.graph && (this._graph_stack || (this._graph_stack = []), this._graph_stack.push(this.graph));
    a.attachCanvas(this);
    this.setDirty(!0, !0);
  };
  LGraphCanvas.prototype.closeSubgraph = function() {
    this._graph_stack && 0 != this._graph_stack.length && (this._graph_stack.pop().attachCanvas(this), this.setDirty(!0, !0));
  };
  LGraphCanvas.prototype.setCanvas = function(a, b) {
    if (a && a.constructor === String && (a = document.getElementById(a), !a)) {
      throw "Error creating LiteGraph canvas: Canvas not found";
    }
    if (a !== this.canvas && (!a && this.canvas && (b || this.unbindEvents()), this.canvas = a)) {
      a.className += " lgraphcanvas";
      a.data = this;
      this.bgcanvas = null;
      this.bgcanvas || (this.bgcanvas = document.createElement("canvas"), this.bgcanvas.width = this.canvas.width, this.bgcanvas.height = this.canvas.height);
      if (null == a.getContext) {
        if ("canvas" != a.localName) {
          throw "Element supplied for LGraphCanvas must be a <canvas> element, you passed a " + a.localName;
        }
        throw "This browser doesnt support Canvas";
      }
      null == (this.ctx = a.getContext("2d")) && (console.warn("This canvas seems to be WebGL, enabling WebGL renderer"), this.enableWebGL());
      this._mousemove_callback = this.processMouseMove.bind(this);
      this._mouseup_callback = this.processMouseUp.bind(this);
      b || this.bindEvents();
    }
  };
  LGraphCanvas.prototype._doNothing = function(a) {
    a.preventDefault();
    return !1;
  };
  LGraphCanvas.prototype._doReturnTrue = function(a) {
    a.preventDefault();
    return !0;
  };
  LGraphCanvas.prototype.bindEvents = function() {
    if (this._events_binded) {
      console.warn("LGraphCanvas: events already binded");
    } else {
      var a = this.canvas;
      this._mousedown_callback = this.processMouseDown.bind(this);
      this._mousewheel_callback = this.processMouseWheel.bind(this);
      a.addEventListener("mousedown", this._mousedown_callback, !0);
      a.addEventListener("mousemove", this._mousemove_callback);
      a.addEventListener("mousewheel", this._mousewheel_callback, !1);
      a.addEventListener("contextmenu", this._doNothing);
      a.addEventListener("DOMMouseScroll", this._mousewheel_callback, !1);
      a.addEventListener("touchstart", this.touchHandler, !0);
      a.addEventListener("touchmove", this.touchHandler, !0);
      a.addEventListener("touchend", this.touchHandler, !0);
      a.addEventListener("touchcancel", this.touchHandler, !0);
      this._key_callback = this.processKey.bind(this);
      a.addEventListener("keydown", this._key_callback);
      a.addEventListener("keyup", this._key_callback);
      this._ondrop_callback = this.processDrop.bind(this);
      a.addEventListener("dragover", this._doNothing, !1);
      a.addEventListener("dragend", this._doNothing, !1);
      a.addEventListener("drop", this._ondrop_callback, !1);
      a.addEventListener("dragenter", this._doReturnTrue, !1);
      this._events_binded = !0;
    }
  };
  LGraphCanvas.prototype.unbindEvents = function() {
    this._events_binded ? (this.canvas.removeEventListener("mousedown", this._mousedown_callback), this.canvas.removeEventListener("mousewheel", this._mousewheel_callback), this.canvas.removeEventListener("DOMMouseScroll", this._mousewheel_callback), this.canvas.removeEventListener("keydown", this._key_callback), this.canvas.removeEventListener("keyup", this._key_callback), this.canvas.removeEventListener("contextmenu", this._doNothing), this.canvas.removeEventListener("drop", this._ondrop_callback), 
    this.canvas.removeEventListener("dragenter", this._doReturnTrue), this.canvas.removeEventListener("touchstart", this.touchHandler), this.canvas.removeEventListener("touchmove", this.touchHandler), this.canvas.removeEventListener("touchend", this.touchHandler), this.canvas.removeEventListener("touchcancel", this.touchHandler), this._ondrop_callback = this._key_callback = this._mousewheel_callback = this._mousedown_callback = null, this._events_binded = !1) : console.warn("LGraphCanvas: no events binded");
  };
  LGraphCanvas.getFileExtension = function(a) {
    var b = a.indexOf("?");
    -1 != b && (a = a.substr(0, b));
    b = a.lastIndexOf(".");
    return -1 == b ? "" : a.substr(b + 1).toLowerCase();
  };
  LGraphCanvas.prototype.enableWebGL = function() {
    this.gl = this.ctx = enableWebGLCanvas(this.canvas);
    this.ctx.webgl = !0;
    this.bgcanvas = this.canvas;
    this.bgctx = this.gl;
  };
  LGraphCanvas.prototype.setDirty = function(a, b) {
    a && (this.dirty_canvas = !0);
    b && (this.dirty_bgcanvas = !0);
  };
  LGraphCanvas.prototype.getCanvasWindow = function() {
    if (!this.canvas) {
      return window;
    }
    var a = this.canvas.ownerDocument;
    return a.defaultView || a.parentWindow;
  };
  LGraphCanvas.prototype.startRendering = function() {
    function a() {
      this.pause_rendering || this.draw();
      var b = this.getCanvasWindow();
      this.is_rendering && b.requestAnimationFrame(a.bind(this));
    }
    this.is_rendering || (this.is_rendering = !0, a.call(this));
  };
  LGraphCanvas.prototype.stopRendering = function() {
    this.is_rendering = !1;
  };
  LGraphCanvas.prototype.processMouseDown = function(a) {
    if (this.graph) {
      this.adjustMouseEvent(a);
      var b = this.getCanvasWindow();
      LGraphCanvas.active_canvas = this;
      this.canvas.removeEventListener("mousemove", this._mousemove_callback);
      b.document.addEventListener("mousemove", this._mousemove_callback, !0);
      b.document.addEventListener("mouseup", this._mouseup_callback, !0);
      var c = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes);
      k.closeAllContextMenus(b);
      if (1 == a.which) {
        if (!(a.shiftKey || c && this.selected_nodes[c.id])) {
          var h = [];
          for (d in this.selected_nodes) {
            this.selected_nodes[d] != c && h.push(this.selected_nodes[d]);
          }
          for (d in h) {
            this.processNodeDeselected(h[d]);
          }
        }
        h = !1;
        if (c && this.allow_interaction) {
          this.live_mode || c.flags.pinned || this.bringToFront(c);
          var e = !1;
          if (!this.connecting_node && !c.flags.collapsed && !this.live_mode) {
            if (c.outputs) {
              var d = 0;
              for (var g = c.outputs.length; d < g; ++d) {
                var l = c.outputs[d], t = c.getConnectionPos(!1, d);
                if (f(a.canvasX, a.canvasY, t[0] - 10, t[1] - 5, 20, 10)) {
                  this.connecting_node = c;
                  this.connecting_output = l;
                  this.connecting_pos = c.getConnectionPos(!1, d);
                  this.connecting_slot = d;
                  e = !0;
                  break;
                }
              }
            }
            if (c.inputs) {
              for (d = 0, g = c.inputs.length; d < g; ++d) {
                l = c.inputs[d], t = c.getConnectionPos(!0, d), f(a.canvasX, a.canvasY, t[0] - 10, t[1] - 5, 20, 10) && null !== l.link && (c.disconnectInput(d), e = this.dirty_bgcanvas = !0);
              }
            }
            !e && f(a.canvasX, a.canvasY, c.pos[0] + c.size[0] - 5, c.pos[1] + c.size[1] - 5, 5, 5) && (this.resizing_node = c, this.canvas.style.cursor = "se-resize", e = !0);
          }
          !e && f(a.canvasX, a.canvasY, c.pos[0], c.pos[1] - k.NODE_TITLE_HEIGHT, k.NODE_TITLE_HEIGHT, k.NODE_TITLE_HEIGHT) && (c.collapse(), e = !0);
          if (!e) {
            d = !1;
            if (300 > k.getTime() - this.last_mouseclick && this.selected_nodes[c.id]) {
              if (c.onDblClick) {
                c.onDblClick(a);
              }
              this.processNodeDblClicked(c);
              d = !0;
            }
            c.onMouseDown && c.onMouseDown(a, [a.canvasX - c.pos[0], a.canvasY - c.pos[1]]) ? d = !0 : this.live_mode && (d = h = !0);
            d || (this.allow_dragnodes && (this.node_dragged = c), this.selected_nodes[c.id] || this.processNodeSelected(c, a));
            this.dirty_canvas = !0;
          }
        } else {
          h = !0;
        }
        h && this.allow_dragcanvas && (this.dragging_canvas = !0);
      } else {
        2 != a.which && 3 == a.which && this.processContextMenu(c, a);
      }
      this.last_mouse[0] = a.localX;
      this.last_mouse[1] = a.localY;
      this.last_mouseclick = k.getTime();
      this.canvas_mouse = [a.canvasX, a.canvasY];
      this.graph.change();
      (!b.document.activeElement || "input" != b.document.activeElement.nodeName.toLowerCase() && "textarea" != b.document.activeElement.nodeName.toLowerCase()) && a.preventDefault();
      a.stopPropagation();
      if (this.onMouseDown) {
        this.onMouseDown(a);
      }
      return !1;
    }
  };
  LGraphCanvas.prototype.processMouseMove = function(a) {
    this.autoresize && this.resize();
    if (this.graph) {
      LGraphCanvas.active_canvas = this;
      this.adjustMouseEvent(a);
      var b = [a.localX, a.localY], c = [b[0] - this.last_mouse[0], b[1] - this.last_mouse[1]];
      this.last_mouse = b;
      this.canvas_mouse = [a.canvasX, a.canvasY];
      if (this.dragging_canvas) {
        this.offset[0] += c[0] / this.scale, this.offset[1] += c[1] / this.scale, this.dirty_bgcanvas = this.dirty_canvas = !0;
      } else {
        if (this.allow_interaction) {
          this.connecting_node && (this.dirty_canvas = !0);
          b = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes);
          for (var h = 0, d = this.graph._nodes.length; h < d; ++h) {
            if (this.graph._nodes[h].mouseOver && b != this.graph._nodes[h]) {
              this.graph._nodes[h].mouseOver = !1;
              if (this.node_over && this.node_over.onMouseLeave) {
                this.node_over.onMouseLeave(a);
              }
              this.node_over = null;
              this.dirty_canvas = !0;
            }
          }
          if (b) {
            if (!b.mouseOver && (b.mouseOver = !0, this.node_over = b, this.dirty_canvas = !0, b.onMouseEnter)) {
              b.onMouseEnter(a);
            }
            if (b.onMouseMove) {
              b.onMouseMove(a);
            }
            if (this.connecting_node && (d = this._highlight_input || [0, 0], !this.isOverNodeBox(b, a.canvasX, a.canvasY))) {
              var e = this.isOverNodeInput(b, a.canvasX, a.canvasY, d);
              -1 != e && b.inputs[e] ? k.isValidConnection(this.connecting_output.type, b.inputs[e].type) && (this._highlight_input = d) : this._highlight_input = null;
            }
            f(a.canvasX, a.canvasY, b.pos[0] + b.size[0] - 5, b.pos[1] + b.size[1] - 5, 5, 5) ? this.canvas.style.cursor = "se-resize" : this.canvas.style.cursor = null;
          } else {
            this.canvas.style.cursor = null;
          }
          if (this.node_capturing_input && this.node_capturing_input != b && this.node_capturing_input.onMouseMove) {
            this.node_capturing_input.onMouseMove(a);
          }
          if (this.node_dragged && !this.live_mode) {
            for (h in this.selected_nodes) {
              b = this.selected_nodes[h], b.pos[0] += c[0] / this.scale, b.pos[1] += c[1] / this.scale;
            }
            this.dirty_bgcanvas = this.dirty_canvas = !0;
          }
          this.resizing_node && !this.live_mode && (this.resizing_node.size[0] += c[0] / this.scale, this.resizing_node.size[1] += c[1] / this.scale, c = Math.max(this.resizing_node.inputs ? this.resizing_node.inputs.length : 0, this.resizing_node.outputs ? this.resizing_node.outputs.length : 0), this.resizing_node.size[1] < c * k.NODE_SLOT_HEIGHT + 4 && (this.resizing_node.size[1] = c * k.NODE_SLOT_HEIGHT + 4), this.resizing_node.size[0] < k.NODE_MIN_WIDTH && (this.resizing_node.size[0] = k.NODE_MIN_WIDTH), 
          this.canvas.style.cursor = "se-resize", this.dirty_bgcanvas = this.dirty_canvas = !0);
        }
      }
      a.preventDefault();
      return !1;
    }
  };
  LGraphCanvas.prototype.processMouseUp = function(a) {
    if (this.graph) {
      var b = this.getCanvasWindow().document;
      LGraphCanvas.active_canvas = this;
      b.removeEventListener("mousemove", this._mousemove_callback, !0);
      this.canvas.addEventListener("mousemove", this._mousemove_callback, !0);
      b.removeEventListener("mouseup", this._mouseup_callback, !0);
      this.adjustMouseEvent(a);
      if (1 == a.which) {
        if (this.connecting_node) {
          this.dirty_bgcanvas = this.dirty_canvas = !0;
          if (b = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes)) {
            if (this.connecting_output.type == k.EVENT && this.isOverNodeBox(b, a.canvasX, a.canvasY)) {
              this.connecting_node.connect(this.connecting_slot, b, k.EVENT);
            } else {
              var c = this.isOverNodeInput(b, a.canvasX, a.canvasY);
              -1 != c ? this.connecting_node.connect(this.connecting_slot, b, c) : (c = b.getInputInfo(0), this.connecting_output.type == k.EVENT ? this.connecting_node.connect(this.connecting_slot, b, k.EVENT) : c && !c.link && c.type == this.connecting_output.type && this.connecting_node.connect(this.connecting_slot, b, 0));
            }
          }
          this.connecting_node = this.connecting_pos = this.connecting_output = null;
          this.connecting_slot = -1;
        } else {
          if (this.resizing_node) {
            this.dirty_bgcanvas = this.dirty_canvas = !0, this.resizing_node = null;
          } else {
            if (this.node_dragged) {
              this.dirty_bgcanvas = this.dirty_canvas = !0, this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]), this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]), this.graph.config.align_to_grid && this.node_dragged.alignToGrid(), this.node_dragged = null;
            } else {
              this.dirty_canvas = !0;
              this.dragging_canvas = !1;
              if (this.node_over && this.node_over.onMouseUp) {
                this.node_over.onMouseUp(a, [a.canvasX - this.node_over.pos[0], a.canvasY - this.node_over.pos[1]]);
              }
              if (this.node_capturing_input && this.node_capturing_input.onMouseUp) {
                this.node_capturing_input.onMouseUp(a, [a.canvasX - this.node_capturing_input.pos[0], a.canvasY - this.node_capturing_input.pos[1]]);
              }
            }
          }
        }
      } else {
        2 == a.which ? (this.dirty_canvas = !0, this.dragging_canvas = !1) : 3 == a.which && (this.dirty_canvas = !0, this.dragging_canvas = !1);
      }
      this.graph.change();
      a.stopPropagation();
      a.preventDefault();
      return !1;
    }
  };
  LGraphCanvas.prototype.processMouseWheel = function(a) {
    if (this.graph && this.allow_dragcanvas) {
      var b = null != a.wheelDeltaY ? a.wheelDeltaY : -60 * a.detail;
      this.adjustMouseEvent(a);
      var c = this.scale;
      0 < b ? c *= 1.1 : 0 > b && (c *= 1 / 1.1);
      this.setZoom(c, [a.localX, a.localY]);
      this.graph.change();
      a.preventDefault();
      return !1;
    }
  };
  LGraphCanvas.prototype.isOverNodeBox = function(a, b, c) {
    var h = k.NODE_TITLE_HEIGHT;
    return f(b, c, a.pos[0] + 2, a.pos[1] + 2 - h, h - 4, h - 4) ? !0 : !1;
  };
  LGraphCanvas.prototype.isOverNodeInput = function(a, b, c, h) {
    if (a.inputs) {
      for (var d = 0, e = a.inputs.length; d < e; ++d) {
        var g = a.getConnectionPos(!0, d);
        if (f(b, c, g[0] - 10, g[1] - 5, 20, 10)) {
          return h && (h[0] = g[0], h[1] = g[1]), d;
        }
      }
    }
    return -1;
  };
  LGraphCanvas.prototype.processKey = function(a) {
    if (this.graph) {
      var b = !1;
      if ("keydown" == a.type) {
        65 == a.keyCode && a.ctrlKey && (this.selectAllNodes(), b = !0);
        if (46 == a.keyCode || 8 == a.keyCode) {
          this.deleteSelectedNodes(), b = !0;
        }
        if (this.selected_nodes) {
          for (var c in this.selected_nodes) {
            if (this.selected_nodes[c].onKeyDown) {
              this.selected_nodes[c].onKeyDown(a);
            }
          }
        }
      } else {
        if ("keyup" == a.type && this.selected_nodes) {
          for (c in this.selected_nodes) {
            if (this.selected_nodes[c].onKeyUp) {
              this.selected_nodes[c].onKeyUp(a);
            }
          }
        }
      }
      this.graph.change();
      if (b) {
        return a.preventDefault(), !1;
      }
    }
  };
  LGraphCanvas.prototype.processDrop = function(a) {
    a.preventDefault();
    this.adjustMouseEvent(a);
    var b = [a.canvasX, a.canvasY], c = this.graph.getNodeOnPos(b[0], b[1]);
    if (c) {
      if ((c.onDropFile || c.onDropData) && (b = a.dataTransfer.files) && b.length) {
        for (var h = 0; h < b.length; h++) {
          var d = a.dataTransfer.files[0], e = d.name;
          LGraphCanvas.getFileExtension(e);
          if (c.onDropFile) {
            c.onDropFile(d);
          }
          if (c.onDropData) {
            var f = new FileReader;
            f.onload = function(a) {
              c.onDropData(a.target.result, e, d);
            };
            var g = d.type.split("/")[0];
            "text" == g || "" == g ? f.readAsText(d) : "image" == g ? f.readAsDataURL(d) : f.readAsArrayBuffer(d);
          }
        }
      }
      return c.onDropItem && c.onDropItem(event) ? !0 : this.onDropItem ? this.onDropItem(event) : !1;
    }
    b = null;
    this.onDropItem && (b = this.onDropItem(event));
    b || this.checkDropItem(a);
  };
  LGraphCanvas.prototype.checkDropItem = function(a) {
    if (a.dataTransfer.files.length) {
      var b = a.dataTransfer.files[0], c = LGraphCanvas.getFileExtension(b.name).toLowerCase();
      if (c = k.node_types_by_file_extension[c]) {
        if (c = k.createNode(c.type), c.pos = [a.canvasX, a.canvasY], this.graph.add(c), c.onDropFile) {
          c.onDropFile(b);
        }
      }
    }
  };
  LGraphCanvas.prototype.processNodeSelected = function(a, b) {
    a.selected = !0;
    if (a.onSelected) {
      a.onSelected();
    }
    b && b.shiftKey || (this.selected_nodes = {});
    this.selected_nodes[a.id] = a;
    this.dirty_canvas = !0;
    if (this.onNodeSelected) {
      this.onNodeSelected(a);
    }
  };
  LGraphCanvas.prototype.processNodeDeselected = function(a) {
    a.selected = !1;
    if (a.onDeselected) {
      a.onDeselected();
    }
    delete this.selected_nodes[a.id];
    if (this.onNodeDeselected) {
      this.onNodeDeselected(a);
    }
    this.dirty_canvas = !0;
  };
  LGraphCanvas.prototype.processNodeDblClicked = function(a) {
    if (this.onShowNodePanel) {
      this.onShowNodePanel(a);
    }
    if (this.onNodeDblClicked) {
      this.onNodeDblClicked(a);
    }
    this.setDirty(!0);
  };
  LGraphCanvas.prototype.selectNode = function(a) {
    this.deselectAllNodes();
    if (a) {
      if (!a.selected && a.onSelected) {
        a.onSelected();
      }
      a.selected = !0;
      this.selected_nodes[a.id] = a;
      this.setDirty(!0);
    }
  };
  LGraphCanvas.prototype.selectAllNodes = function() {
    for (var a = 0; a < this.graph._nodes.length; ++a) {
      var b = this.graph._nodes[a];
      if (!b.selected && b.onSelected) {
        b.onSelected();
      }
      b.selected = !0;
      this.selected_nodes[this.graph._nodes[a].id] = b;
    }
    this.setDirty(!0);
  };
  LGraphCanvas.prototype.deselectAllNodes = function() {
    for (var a in this.selected_nodes) {
      var b = this.selected_nodes;
      if (b.onDeselected) {
        b.onDeselected();
      }
      b.selected = !1;
    }
    this.selected_nodes = {};
    this.setDirty(!0);
  };
  LGraphCanvas.prototype.deleteSelectedNodes = function() {
    for (var a in this.selected_nodes) {
      this.graph.remove(this.selected_nodes[a]);
    }
    this.selected_nodes = {};
    this.setDirty(!0);
  };
  LGraphCanvas.prototype.centerOnNode = function(a) {
    this.offset[0] = -a.pos[0] - 0.5 * a.size[0] + 0.5 * this.canvas.width / this.scale;
    this.offset[1] = -a.pos[1] - 0.5 * a.size[1] + 0.5 * this.canvas.height / this.scale;
    this.setDirty(!0, !0);
  };
  LGraphCanvas.prototype.adjustMouseEvent = function(a) {
    var b = this.canvas.getBoundingClientRect();
    a.localX = a.pageX - b.left;
    a.localY = a.pageY - b.top;
    a.canvasX = a.localX / this.scale - this.offset[0];
    a.canvasY = a.localY / this.scale - this.offset[1];
  };
  LGraphCanvas.prototype.setZoom = function(a, b) {
    b || (b = [0.5 * this.canvas.width, 0.5 * this.canvas.height]);
    var c = this.convertOffsetToCanvas(b);
    this.scale = a;
    this.scale > this.max_zoom ? this.scale = this.max_zoom : this.scale < this.min_zoom && (this.scale = this.min_zoom);
    a = this.convertOffsetToCanvas(b);
    c = [a[0] - c[0], a[1] - c[1]];
    this.offset[0] += c[0];
    this.offset[1] += c[1];
    this.dirty_bgcanvas = this.dirty_canvas = !0;
  };
  LGraphCanvas.prototype.convertOffsetToCanvas = function(a) {
    return [a[0] / this.scale - this.offset[0], a[1] / this.scale - this.offset[1]];
  };
  LGraphCanvas.prototype.convertCanvasToOffset = function(a) {
    return [(a[0] + this.offset[0]) * this.scale, (a[1] + this.offset[1]) * this.scale];
  };
  LGraphCanvas.prototype.convertEventToCanvas = function(a) {
    var b = this.canvas.getClientRects()[0];
    return this.convertOffsetToCanvas([a.pageX - b.left, a.pageY - b.top]);
  };
  LGraphCanvas.prototype.bringToFront = function(a) {
    var b = this.graph._nodes.indexOf(a);
    -1 != b && (this.graph._nodes.splice(b, 1), this.graph._nodes.push(a));
  };
  LGraphCanvas.prototype.sendToBack = function(a) {
    var b = this.graph._nodes.indexOf(a);
    -1 != b && (this.graph._nodes.splice(b, 1), this.graph._nodes.unshift(a));
  };
  LGraphCanvas.prototype.computeVisibleNodes = function() {
    for (var a = [], b = 0, c = this.graph._nodes.length; b < c; ++b) {
      var h = this.graph._nodes[b];
      (!this.live_mode || h.onDrawBackground || h.onDrawForeground) && g(this.visible_area, h.getBounding()) && a.push(h);
    }
    return a;
  };
  LGraphCanvas.prototype.draw = function(a, b) {
    if (this.canvas) {
      var c = k.getTime();
      this.render_time = 0.001 * (c - this.last_draw_time);
      this.last_draw_time = c;
      if (this.graph) {
        var h = [-this.offset[0], -this.offset[1]], d = [h[0] + this.canvas.width / this.scale, h[1] + this.canvas.height / this.scale];
        this.visible_area = new Float32Array([h[0], h[1], d[0], d[1]]);
      }
      (this.dirty_bgcanvas || b || this.always_render_background || this.graph && this.graph._last_trigger_time && 1000 > c - this.graph._last_trigger_time) && this.drawBackCanvas();
      (this.dirty_canvas || a) && this.drawFrontCanvas();
      this.fps = this.render_time ? 1.0 / this.render_time : 0;
      this.frame += 1;
    }
  };
  LGraphCanvas.prototype.drawFrontCanvas = function() {
    this.ctx || (this.ctx = this.bgcanvas.getContext("2d"));
    var a = this.ctx;
    if (a) {
      a.start2D && a.start2D();
      var b = this.canvas;
      a.restore();
      a.setTransform(1, 0, 0, 1, 0, 0);
      this.dirty_area && (a.save(), a.beginPath(), a.rect(this.dirty_area[0], this.dirty_area[1], this.dirty_area[2], this.dirty_area[3]), a.clip());
      this.clear_background && a.clearRect(0, 0, b.width, b.height);
      this.bgcanvas == this.canvas ? this.drawBackCanvas() : a.drawImage(this.bgcanvas, 0, 0);
      if (this.onRender) {
        this.onRender(b, a);
      }
      this.show_info && this.renderInfo(a);
      if (this.graph) {
        a.save();
        a.scale(this.scale, this.scale);
        a.translate(this.offset[0], this.offset[1]);
        this.visible_nodes = b = this.computeVisibleNodes();
        for (var c = 0; c < b.length; ++c) {
          var h = b[c];
          a.save();
          a.translate(h.pos[0], h.pos[1]);
          this.drawNode(h, a);
          a.restore();
        }
        this.graph.config.links_ontop && (this.live_mode || this.drawConnections(a));
        if (null != this.connecting_pos) {
          a.lineWidth = this.connections_width;
          switch(this.connecting_output.type) {
            case k.EVENT:
              b = "#F85";
              break;
            default:
              b = "#AFA";
          }
          this.renderLink(a, this.connecting_pos, [this.canvas_mouse[0], this.canvas_mouse[1]], null, !1, null, b);
          a.beginPath();
          this.connecting_output.type === k.EVENT ? a.rect(this.connecting_pos[0] - 6 + 0.5, this.connecting_pos[1] - 5 + 0.5, 14, 10) : a.arc(this.connecting_pos[0], this.connecting_pos[1], 4, 0, 2 * Math.PI);
          a.fill();
          a.fillStyle = "#ffcc00";
          this._highlight_input && (a.beginPath(), a.arc(this._highlight_input[0], this._highlight_input[1], 6, 0, 2 * Math.PI), a.fill());
        }
        a.restore();
      }
      this.dirty_area && a.restore();
      a.finish2D && a.finish2D();
      this.dirty_canvas = !1;
    }
  };
  LGraphCanvas.prototype.renderInfo = function(a, b, c) {
    b = b || 0;
    c = c || 0;
    a.save();
    a.translate(b, c);
    a.font = "10px Arial";
    a.fillStyle = "#888";
    this.graph ? (a.fillText("T: " + this.graph.globaltime.toFixed(2) + "s", 5, 13), a.fillText("I: " + this.graph.iteration, 5, 26), a.fillText("F: " + this.frame, 5, 39), a.fillText("FPS:" + this.fps.toFixed(2), 5, 52)) : a.fillText("No graph selected", 5, 13);
    a.restore();
  };
  LGraphCanvas.prototype.drawBackCanvas = function() {
    var a = this.bgcanvas;
    if (a.width != this.canvas.width || a.height != this.canvas.height) {
      a.width = this.canvas.width, a.height = this.canvas.height;
    }
    this.bgctx || (this.bgctx = this.bgcanvas.getContext("2d"));
    var b = this.bgctx;
    b.start && b.start();
    this.clear_background && b.clearRect(0, 0, a.width, a.height);
    b.restore();
    b.setTransform(1, 0, 0, 1, 0, 0);
    if (this.graph) {
      b.save();
      b.scale(this.scale, this.scale);
      b.translate(this.offset[0], this.offset[1]);
      if (this.background_image && 0.5 < this.scale) {
        b.globalAlpha = (1.0 - 0.5 / this.scale) * this.editor_alpha;
        b.imageSmoothingEnabled = b.mozImageSmoothingEnabled = b.imageSmoothingEnabled = !1;
        if (!this._bg_img || this._bg_img.name != this.background_image) {
          this._bg_img = new Image;
          this._bg_img.name = this.background_image;
          this._bg_img.src = this.background_image;
          var c = this;
          this._bg_img.onload = function() {
            c.draw(!0, !0);
          };
        }
        var h = null;
        null == this._pattern && 0 < this._bg_img.width ? (h = b.createPattern(this._bg_img, "repeat"), this._pattern_img = this._bg_img, this._pattern = h) : h = this._pattern;
        h && (b.fillStyle = h, b.fillRect(this.visible_area[0], this.visible_area[1], this.visible_area[2] - this.visible_area[0], this.visible_area[3] - this.visible_area[1]), b.fillStyle = "transparent");
        b.globalAlpha = 1.0;
        b.imageSmoothingEnabled = b.mozImageSmoothingEnabled = b.imageSmoothingEnabled = !0;
      }
      if (this.onBackgroundRender) {
        this.onBackgroundRender(a, b);
      }
      b.strokeStyle = "#235";
      b.strokeRect(0, 0, a.width, a.height);
      this.render_connections_shadows ? (b.shadowColor = "#000", b.shadowOffsetX = 0, b.shadowOffsetY = 0, b.shadowBlur = 6) : b.shadowColor = "rgba(0,0,0,0)";
      this.live_mode || this.drawConnections(b);
      b.shadowColor = "rgba(0,0,0,0)";
      b.restore();
    }
    b.finish && b.finish();
    this.dirty_bgcanvas = !1;
    this.dirty_canvas = !0;
  };
  LGraphCanvas.prototype.drawNode = function(a, b) {
    var c = a.color || k.NODE_DEFAULT_COLOR, h = !0;
    if (a.flags.skip_title_render || a.graph.isLive()) {
      h = !1;
    }
    a.mouseOver && (h = !0);
    a.selected || (this.render_shadows ? (b.shadowColor = "rgba(0,0,0,0.5)", b.shadowOffsetX = 2, b.shadowOffsetY = 2, b.shadowBlur = 3) : b.shadowColor = "transparent");
    if (this.live_mode) {
      if (!a.flags.collapsed && (b.shadowColor = "transparent", a.onDrawForeground)) {
        a.onDrawForeground(b);
      }
    } else {
      var d = this.editor_alpha;
      b.globalAlpha = d;
      var e = a.shape || "box", f = new Float32Array(a.size);
      a.flags.collapsed && (f[0] = k.NODE_COLLAPSED_WIDTH, f[1] = 0);
      a.flags.clip_area && (b.save(), "box" == e ? (b.beginPath(), b.rect(0, 0, f[0], f[1])) : "round" == e ? b.roundRect(0, 0, f[0], f[1], 10) : "circle" == e && (b.beginPath(), b.arc(0.5 * f[0], 0.5 * f[1], 0.5 * f[0], 0, 2 * Math.PI)), b.clip());
      this.drawNodeShape(a, b, f, c, a.bgcolor, !h, a.selected);
      b.shadowColor = "transparent";
      b.textAlign = "left";
      b.font = this.inner_text_font;
      h = 0.6 < this.scale;
      e = this.connecting_output;
      if (!a.flags.collapsed) {
        if (a.inputs) {
          for (f = 0; f < a.inputs.length; f++) {
            var g = a.inputs[f];
            b.globalAlpha = d;
            this.connecting_node && k.isValidConnection(g.type && e.type) && (b.globalAlpha = 0.4 * d);
            b.fillStyle = null != g.link ? "#7F7" : "#AAA";
            var l = a.getConnectionPos(!0, f);
            l[0] -= a.pos[0];
            l[1] -= a.pos[1];
            b.beginPath();
            g.type === k.EVENT ? b.rect(l[0] - 6 + 0.5, l[1] - 5 + 0.5, 14, 10) : b.arc(l[0], l[1], 4, 0, 2 * Math.PI);
            b.fill();
            h && (g = null != g.label ? g.label : g.name) && (b.fillStyle = c, b.fillText(g, l[0] + 10, l[1] + 5));
          }
        }
        this.connecting_node && (b.globalAlpha = 0.4 * d);
        b.lineWidth = 1;
        b.textAlign = "right";
        b.strokeStyle = "black";
        if (a.outputs) {
          for (f = 0; f < a.outputs.length; f++) {
            if (g = a.outputs[f], l = a.getConnectionPos(!1, f), l[0] -= a.pos[0], l[1] -= a.pos[1], b.fillStyle = g.links && g.links.length ? "#7F7" : "#AAA", b.beginPath(), g.type === k.EVENT ? b.rect(l[0] - 6 + 0.5, l[1] - 5 + 0.5, 14, 10) : b.arc(l[0], l[1], 4, 0, 2 * Math.PI), b.fill(), b.stroke(), h && (g = null != g.label ? g.label : g.name)) {
              b.fillStyle = c, b.fillText(g, l[0] - 10, l[1] + 5);
            }
          }
        }
        b.textAlign = "left";
        b.globalAlpha = 1;
        if (a.onDrawForeground) {
          a.onDrawForeground(b);
        }
      }
      a.flags.clip_area && b.restore();
      b.globalAlpha = 1.0;
    }
  };
  LGraphCanvas.prototype.drawNodeShape = function(a, b, c, h, d, e, f) {
    b.strokeStyle = h || k.NODE_DEFAULT_COLOR;
    b.fillStyle = d || k.NODE_DEFAULT_BGCOLOR;
    d = k.NODE_TITLE_HEIGHT;
    var n = a.shape || "box";
    "box" == n ? (b.beginPath(), b.rect(0, e ? 0 : -d, c[0] + 1, e ? c[1] : c[1] + d), b.fill(), b.shadowColor = "transparent", f && (b.strokeStyle = "#CCC", b.strokeRect(-0.5, e ? -0.5 : -d + -0.5, c[0] + 2, e ? c[1] + 2 : c[1] + d + 2 - 1), b.strokeStyle = h)) : "round" == a.shape ? (b.roundRect(0, e ? 0 : -d, c[0], e ? c[1] : c[1] + d, 10), b.fill()) : "circle" == a.shape && (b.beginPath(), b.arc(0.5 * c[0], 0.5 * c[1], 0.5 * c[0], 0, 2 * Math.PI), b.fill());
    b.shadowColor = "transparent";
    a.bgImage && a.bgImage.width && b.drawImage(a.bgImage, 0.5 * (c[0] - a.bgImage.width), 0.5 * (c[1] - a.bgImage.height));
    a.bgImageUrl && !a.bgImage && (a.bgImage = a.loadImage(a.bgImageUrl));
    if (a.onDrawBackground) {
      a.onDrawBackground(b);
    }
    e || (b.fillStyle = h || k.NODE_DEFAULT_COLOR, h = b.globalAlpha, b.globalAlpha = 0.5 * h, "box" == n ? (b.beginPath(), b.rect(0, -d, c[0] + 1, d), b.fill()) : "round" == n && (b.roundRect(0, -d, c[0], d, 10, 0), b.fill()), b.fillStyle = a.boxcolor || k.NODE_DEFAULT_BOXCOLOR, b.beginPath(), "round" == n ? b.arc(0.5 * d, -0.5 * d, 0.5 * (d - 6), 0, 2 * Math.PI) : b.rect(3, -d + 3, d - 6, d - 6), b.fill(), b.globalAlpha = h, b.font = this.title_text_font, (a = a.getTitle()) && 0.5 < this.scale && 
    (b.fillStyle = k.NODE_TITLE_COLOR, b.fillText(a, 16, 13 - d)));
  };
  LGraphCanvas.prototype.drawNodeCollapsed = function(a, b, c, d) {
    b.strokeStyle = c || k.NODE_DEFAULT_COLOR;
    b.fillStyle = d || k.NODE_DEFAULT_BGCOLOR;
    c = k.NODE_COLLAPSED_RADIUS;
    d = a.shape || "box";
    "circle" == d ? (b.beginPath(), b.arc(0.5 * a.size[0], 0.5 * a.size[1], c, 0, 2 * Math.PI), b.fill(), b.shadowColor = "rgba(0,0,0,0)", b.stroke(), b.fillStyle = a.boxcolor || k.NODE_DEFAULT_BOXCOLOR, b.beginPath(), b.arc(0.5 * a.size[0], 0.5 * a.size[1], 0.5 * c, 0, 2 * Math.PI)) : "round" == d ? (b.beginPath(), b.roundRect(0.5 * a.size[0] - c, 0.5 * a.size[1] - c, 2 * c, 2 * c, 5), b.fill(), b.shadowColor = "rgba(0,0,0,0)", b.stroke(), b.fillStyle = a.boxcolor || k.NODE_DEFAULT_BOXCOLOR, b.beginPath(), 
    b.roundRect(0.5 * a.size[0] - 0.5 * c, 0.5 * a.size[1] - 0.5 * c, c, c, 2)) : (b.beginPath(), b.rect(0, 0, a.size[0], 2 * c), b.fill(), b.shadowColor = "rgba(0,0,0,0)", b.stroke(), b.fillStyle = a.boxcolor || k.NODE_DEFAULT_BOXCOLOR, b.beginPath(), b.rect(0.5 * c, 0.5 * c, c, c));
    b.fill();
  };
  LGraphCanvas.prototype.drawConnections = function(a) {
    var b = k.getTime();
    a.lineWidth = this.connections_width;
    a.fillStyle = "#AAA";
    a.strokeStyle = "#AAA";
    a.globalAlpha = this.editor_alpha;
    for (var c = 0, d = this.graph._nodes.length; c < d; ++c) {
      var e = this.graph._nodes[c];
      if (e.inputs && e.inputs.length) {
        for (var f = 0; f < e.inputs.length; ++f) {
          var g = e.inputs[f];
          if (g && null != g.link && (g = this.graph.links[g.link])) {
            var l = this.graph.getNodeById(g.origin_id);
            if (null != l) {
              var t = g.origin_slot;
              l = -1 == t ? [l.pos[0] + 10, l.pos[1] + 10] : l.getConnectionPos(!1, t);
              this.renderLink(a, l, e.getConnectionPos(!0, f), g);
              if (g && g._last_time && 1000 > b - g._last_time) {
                t = 2.0 - 0.002 * (b - g._last_time);
                var p = "rgba(255,255,255, " + t.toFixed(2) + ")";
                this.renderLink(a, l, e.getConnectionPos(!0, f), g, !0, t, p);
              }
            }
          }
        }
      }
    }
    a.globalAlpha = 1;
  };
  LGraphCanvas.prototype.renderLink = function(a, b, c, d, n, f, g) {
    if (this.highquality_render) {
      var h = e(b, c);
      this.render_connections_border && 0.6 < this.scale && (a.lineWidth = this.connections_width + 4);
      !g && d && (g = LGraphCanvas.link_type_colors[d.type]);
      g || (g = this.default_link_color);
      a.beginPath();
      this.render_curved_connections ? (a.moveTo(b[0], b[1]), a.bezierCurveTo(b[0] + 0.25 * h, b[1], c[0] - 0.25 * h, c[1], c[0], c[1])) : (a.moveTo(b[0] + 10, b[1]), a.lineTo(0.5 * (b[0] + 10 + (c[0] - 10)), b[1]), a.lineTo(0.5 * (b[0] + 10 + (c[0] - 10)), c[1]), a.lineTo(c[0] - 10, c[1]));
      this.render_connections_border && 0.6 < this.scale && !n && (a.strokeStyle = "rgba(0,0,0,0.5)", a.stroke());
      a.lineWidth = this.connections_width;
      a.fillStyle = a.strokeStyle = g;
      a.stroke();
      this.render_connection_arrows && 0.6 <= this.scale && this.render_connection_arrows && 0.6 < this.scale && (d = this.computeConnectionPoint(b, c, 0.5), n = this.computeConnectionPoint(b, c, 0.51), n = this.render_curved_connections ? -Math.atan2(n[0] - d[0], n[1] - d[1]) : c[1] > b[1] ? 0 : Math.PI, a.save(), a.translate(d[0], d[1]), a.rotate(n), a.beginPath(), a.moveTo(-5, -5), a.lineTo(0, 5), a.lineTo(5, -5), a.fill(), a.restore());
      if (f) {
        for (f = 0; 5 > f; ++f) {
          d = (0.001 * k.getTime() + 0.2 * f) % 1, d = this.computeConnectionPoint(b, c, d), a.beginPath(), a.arc(d[0], d[1], 5, 0, 2 * Math.PI), a.fill();
        }
      }
    } else {
      a.beginPath(), a.moveTo(b[0], b[1]), a.lineTo(c[0], c[1]), a.stroke();
    }
  };
  LGraphCanvas.prototype.computeConnectionPoint = function(a, b, c) {
    var d = e(a, b), f = [a[0] + 0.25 * d, a[1]];
    d = [b[0] - 0.25 * d, b[1]];
    var g = (1 - c) * (1 - c) * (1 - c), k = 3 * (1 - c) * (1 - c) * c, l = 3 * (1 - c) * c * c;
    c *= c * c;
    return [g * a[0] + k * f[0] + l * d[0] + c * b[0], g * a[1] + k * f[1] + l * d[1] + c * b[1]];
  };
  LGraphCanvas.prototype.resize = function(a, b) {
    a || b || (b = this.canvas.parentNode, a = b.offsetWidth, b = b.offsetHeight);
    if (this.canvas.width != a || this.canvas.height != b) {
      this.canvas.width = a, this.canvas.height = b, this.bgcanvas.width = this.canvas.width, this.bgcanvas.height = this.canvas.height, this.setDirty(!0, !0);
    }
  };
  LGraphCanvas.prototype.switchLiveMode = function(a) {
    if (a) {
      var b = this, c = this.live_mode ? 1.1 : 0.9;
      this.live_mode && (this.live_mode = !1, this.editor_alpha = 0.1);
      var d = setInterval(function() {
        b.editor_alpha *= c;
        b.dirty_canvas = !0;
        b.dirty_bgcanvas = !0;
        1 > c && 0.01 > b.editor_alpha && (clearInterval(d), 1 > c && (b.live_mode = !0));
        1 < c && 0.99 < b.editor_alpha && (clearInterval(d), b.editor_alpha = 1);
      }, 1);
    } else {
      this.live_mode = !this.live_mode, this.dirty_bgcanvas = this.dirty_canvas = !0;
    }
  };
  LGraphCanvas.prototype.onNodeSelectionChange = function(a) {
  };
  LGraphCanvas.prototype.touchHandler = function(a) {
    var b = a.changedTouches[0];
    switch(a.type) {
      case "touchstart":
        var c = "mousedown";
        break;
      case "touchmove":
        c = "mousemove";
        break;
      case "touchend":
        c = "mouseup";
        break;
      default:
        return;
    }
    var d = this.getCanvasWindow(), e = d.document.createEvent("MouseEvent");
    e.initMouseEvent(c, !0, !0, d, 1, b.screenX, b.screenY, b.clientX, b.clientY, !1, !1, !1, !1, 0, null);
    b.target.dispatchEvent(e);
    a.preventDefault();
  };
  LGraphCanvas.onMenuAdd = function(a, b, c, d) {
    function e(a, b) {
      b = d.getFirstEvent();
      if (a = k.createNode(a.value)) {
        a.pos = h.convertEventToCanvas(b), h.graph.add(a);
      }
    }
    var h = LGraphCanvas.active_canvas, f = h.getCanvasWindow();
    a = k.getNodeTypesCategories();
    b = [];
    for (var g in a) {
      a[g] && b.push({value:a[g], content:a[g], has_submenu:!0});
    }
    var l = new k.ContextMenu(b, {event:c, callback:function(a, b, c) {
      a = k.getNodeTypesInCategory(a.value);
      b = [];
      for (var d in a) {
        b.push({content:a[d].title, value:a[d].type});
      }
      new k.ContextMenu(b, {event:c, callback:e, parentMenu:l}, f);
      return !1;
    }, parentMenu:d}, f);
    return !1;
  };
  LGraphCanvas.onMenuCollapseAll = function() {
  };
  LGraphCanvas.onMenuNodeEdit = function() {
  };
  LGraphCanvas.showMenuNodeOptionalInputs = function(a, b, c, d, e) {
    if (e) {
      var h = this;
      a = LGraphCanvas.active_canvas.getCanvasWindow();
      b = e.optional_inputs;
      e.onGetInputs && (b = e.onGetInputs());
      var f = [];
      if (b) {
        for (var n in b) {
          var g = b[n];
          if (g) {
            var l = g[0];
            g[2] && g[2].label && (l = g[2].label);
            f.push({content:l, value:g});
          } else {
            f.push(null);
          }
        }
      }
      this.onMenuNodeInputs && (f = this.onMenuNodeInputs(f));
      if (f.length) {
        return new k.ContextMenu(f, {event:c, callback:function(a, b, c) {
          e && (a.callback && a.callback.call(h, e, a, b, c), a.value && e.addInput(a.value[0], a.value[1], a.value[2]));
        }, parentMenu:d, node:e}, a), !1;
      }
    }
  };
  LGraphCanvas.showMenuNodeOptionalOutputs = function(a, b, c, d, e) {
    function h(a, b, c) {
      if (e && (a.callback && a.callback.call(f, e, a, b, c), a.value)) {
        if (c = a.value[1], !c || c.constructor !== Object && c.constructor !== Array) {
          e.addOutput(a.value[0], a.value[1], a.value[2]);
        } else {
          a = [];
          for (var n in c) {
            a.push({content:n, value:c[n]});
          }
          new k.ContextMenu(a, {event:b, callback:h, parentMenu:d, node:e});
          return !1;
        }
      }
    }
    if (e) {
      var f = this;
      a = LGraphCanvas.active_canvas.getCanvasWindow();
      b = e.optional_outputs;
      e.onGetOutputs && (b = e.onGetOutputs());
      var n = [];
      if (b) {
        for (var g in b) {
          var l = b[g];
          if (!l) {
            n.push(null);
          } else {
            if (-1 == e.findOutputSlot(l[0])) {
              var q = l[0];
              l[2] && l[2].label && (q = l[2].label);
              q = {content:q, value:l};
              l[1] == k.EVENT && (q.className = "event");
              n.push(q);
            }
          }
        }
      }
      this.onMenuNodeOutputs && (n = this.onMenuNodeOutputs(n));
      if (n.length) {
        return new k.ContextMenu(n, {event:c, callback:h, parentMenu:d, node:e}, a), !1;
      }
    }
  };
  LGraphCanvas.onShowMenuNodeProperties = function(a, b, c, d, e) {
    if (e && e.properties) {
      var h = LGraphCanvas.active_canvas;
      b = h.getCanvasWindow();
      var f = [], n;
      for (n in e.properties) {
        a = void 0 !== e.properties[n] ? e.properties[n] : " ", a = LGraphCanvas.decodeHTML(a), f.push({content:"<span class='property_name'>" + n + "</span><span class='property_value'>" + a + "</span>", value:n});
      }
      if (f.length) {
        return new k.ContextMenu(f, {event:c, callback:function(a, b, c, d) {
          e && (b = this.getBoundingClientRect(), h.showEditPropertyValue(e, a.value, {position:[b.left, b.top]}));
        }, parentMenu:d, allow_html:!0, node:e}, b), !1;
      }
    }
  };
  LGraphCanvas.decodeHTML = function(a) {
    var b = document.createElement("div");
    b.innerText = a;
    return b.innerHTML;
  };
  LGraphCanvas.onResizeNode = function(a, b, c, d, e) {
    e && (e.size = e.computeSize(), e.setDirtyCanvas(!0, !0));
  };
  LGraphCanvas.onShowTitleEditor = function(a, b, c, d, e) {
    function h() {
      e.title = n.value;
      f.parentNode.removeChild(f);
      e.setDirtyCanvas(!0, !0);
    }
    var f = document.createElement("div");
    f.className = "graphdialog";
    f.innerHTML = "<span class='name'>Title</span><input autofocus type='text' class='value'/><button>OK</button>";
    var n = f.querySelector("input");
    n && (n.value = e.title, n.addEventListener("keydown", function(a) {
      13 == a.keyCode && (h(), a.preventDefault(), a.stopPropagation());
    }));
    a = LGraphCanvas.active_canvas.canvas;
    b = a.getBoundingClientRect();
    d = c = -20;
    b && (c -= b.left, d -= b.top);
    event ? (f.style.left = event.pageX + c + "px", f.style.top = event.pageY + d + "px") : (f.style.left = 0.5 * a.width + c + "px", f.style.top = 0.5 * a.height + d + "px");
    f.querySelector("button").addEventListener("click", h);
    a.parentNode.appendChild(f);
  };
  LGraphCanvas.prototype.showEditPropertyValue = function(a, b, c) {
    function d() {
      e(w.value);
    }
    function e(c) {
      "number" == typeof a.properties[b] && (c = Number(c));
      a.properties[b] = c;
      if (a.onPropertyChanged) {
        a.onPropertyChanged(b, c);
      }
      q.parentNode.removeChild(q);
      a.setDirtyCanvas(!0, !0);
    }
    if (a && void 0 !== a.properties[b]) {
      c = c || {};
      var f = "string";
      null !== a.properties[b] && (f = typeof a.properties[b]);
      var g = null;
      a.getPropertyInfo && (g = a.getPropertyInfo(b));
      if (a.properties_info) {
        for (var k = 0; k < a.properties_info.length; ++k) {
          if (a.properties_info[k].name == b) {
            g = a.properties_info[k];
            break;
          }
        }
      }
      void 0 !== g && null !== g && g.type && (f = g.type);
      var l = "";
      if ("string" == f || "number" == f) {
        l = "<input autofocus type='text' class='value'/>";
      } else {
        if ("enum" == f && g.values) {
          l = "<select autofocus type='text' class='value'>";
          for (k in g.values) {
            var p = g.values.constructor === Array ? g.values[k] : k;
            l += "<option value='" + p + "' " + (p == a.properties[b] ? "selected" : "") + ">" + g.values[k] + "</option>";
          }
          l += "</select>";
        } else {
          "boolean" == f && (l = "<input autofocus type='checkbox' class='value' " + (a.properties[b] ? "checked" : "") + "/>");
        }
      }
      var q = document.createElement("div");
      q.className = "graphdialog";
      q.innerHTML = "<span class='name'>" + b + "</span>" + l + "<button>OK</button>";
      if ("enum" == f && g.values) {
        var w = q.querySelector("select");
        w.addEventListener("change", function(a) {
          e(a.target.value);
        });
      } else {
        if ("boolean" == f) {
          (w = q.querySelector("input")) && w.addEventListener("click", function(a) {
            e(!!w.checked);
          });
        } else {
          if (w = q.querySelector("input")) {
            w.value = void 0 !== a.properties[b] ? a.properties[b] : "", w.addEventListener("keydown", function(a) {
              13 == a.keyCode && (d(), a.preventDefault(), a.stopPropagation());
            });
          }
        }
      }
      f = this.canvas.getClientRects()[0];
      k = g = -20;
      f && (g -= f.left, k -= f.top);
      c.position ? (g += c.position[0], k += c.position[1]) : c.event ? (g += c.event.pageX, k += c.event.pageY) : (g += 0.5 * this.canvas.width, k += 0.5 * this.canvas.height);
      q.style.left = g + "px";
      q.style.top = k + "px";
      q.querySelector("button").addEventListener("click", d);
      this.canvas.parentNode.appendChild(q);
    }
  };
  LGraphCanvas.onMenuNodeCollapse = function(a, b, c, d, e) {
    e.flags.collapsed = !e.flags.collapsed;
    e.setDirtyCanvas(!0, !0);
  };
  LGraphCanvas.onMenuNodePin = function(a, b, c, d, e) {
    e.pin();
  };
  LGraphCanvas.onMenuNodeMode = function(a, b, c, d, e) {
    new k.ContextMenu(["Always", "On Event", "Never"], {event:c, callback:function(a) {
      if (e) {
        switch(a) {
          case "On Event":
            e.mode = k.ON_EVENT;
            break;
          case "Never":
            e.mode = k.NEVER;
            break;
          default:
            e.mode = k.ALWAYS;
        }
      }
    }, parentMenu:prev_menu, node:e});
    return !1;
  };
  LGraphCanvas.onMenuNodeColors = function(a, b, c, d, e) {
    if (!e) {
      throw "no node for color";
    }
    b = [];
    for (var h in LGraphCanvas.node_colors) {
      a = LGraphCanvas.node_colors[h], a = {value:h, content:"<span style='display: block; color:" + a.color + "; background-color:" + a.bgcolor + "'>" + h + "</span>"}, b.push(a);
    }
    new k.ContextMenu(b, {event:c, callback:function(a) {
      e && (a = LGraphCanvas.node_colors[a.value]) && (e.color = a.color, e.bgcolor = a.bgcolor, e.setDirtyCanvas(!0));
    }, parentMenu:d, node:e});
    return !1;
  };
  LGraphCanvas.onMenuNodeShapes = function(a, b, c, d, e) {
    if (!e) {
      throw "no node passed";
    }
    new k.ContextMenu(["box", "round"], {event:c, callback:function(a) {
      e && (e.shape = a, e.setDirtyCanvas(!0));
    }, parentMenu:d, node:e});
    return !1;
  };
  LGraphCanvas.onMenuNodeRemove = function(a, b, c, d, e) {
    if (!e) {
      throw "no node passed";
    }
    0 != e.removable && (e.graph.remove(e), e.setDirtyCanvas(!0, !0));
  };
  LGraphCanvas.onMenuNodeClone = function(a, b, c, d, e) {
    0 != e.clonable && (a = e.clone()) && (a.pos = [e.pos[0] + 5, e.pos[1] + 5], e.graph.add(a), e.setDirtyCanvas(!0, !0));
  };
  LGraphCanvas.node_colors = {red:{color:"#FAA", bgcolor:"#A44"}, green:{color:"#AFA", bgcolor:"#4A4"}, blue:{color:"#AAF", bgcolor:"#44A"}, white:{color:"#FFF", bgcolor:"#AAA"}};
  LGraphCanvas.prototype.getCanvasMenuOptions = function() {
    if (this.getMenuOptions) {
      var a = this.getMenuOptions();
    } else {
      a = [{content:"Add Node", has_submenu:!0, callback:LGraphCanvas.onMenuAdd}], this._graph_stack && 0 < this._graph_stack.length && (a = [{content:"Close subgraph", callback:this.closeSubgraph.bind(this)}, null].concat(a));
    }
    if (this.getExtraMenuOptions) {
      var b = this.getExtraMenuOptions(this, a);
      b && (a = a.concat(b));
    }
    return a;
  };
  LGraphCanvas.prototype.getNodeMenuOptions = function(a) {
    var b = a.getMenuOptions ? a.getMenuOptions(this) : [{content:"Inputs", has_submenu:!0, disabled:!0, callback:LGraphCanvas.showMenuNodeOptionalInputs}, {content:"Outputs", has_submenu:!0, disabled:!0, callback:LGraphCanvas.showMenuNodeOptionalOutputs}, null, {content:"Properties", has_submenu:!0, callback:LGraphCanvas.onShowMenuNodeProperties}, null, {content:"Title", callback:LGraphCanvas.onShowTitleEditor}, {content:"Mode", has_submenu:!0, callback:LGraphCanvas.onMenuNodeMode}, {content:"Resize", 
    callback:LGraphCanvas.onResizeNode}, {content:"Collapse", callback:LGraphCanvas.onMenuNodeCollapse}, {content:"Pin", callback:LGraphCanvas.onMenuNodePin}, {content:"Colors", has_submenu:!0, callback:LGraphCanvas.onMenuNodeColors}, {content:"Shapes", has_submenu:!0, callback:LGraphCanvas.onMenuNodeShapes}, null];
    if (a.getExtraMenuOptions) {
      var c = a.getExtraMenuOptions(this);
      c && (c.push(null), b = c.concat(b));
    }
    !1 !== a.clonable && b.push({content:"Clone", callback:LGraphCanvas.onMenuNodeClone});
    !1 !== a.removable && b.push(null, {content:"Remove", callback:LGraphCanvas.onMenuNodeRemove});
    a.onGetInputs && (c = a.onGetInputs()) && c.length && (b[0].disabled = !1);
    a.onGetOutputs && (c = a.onGetOutputs()) && c.length && (b[1].disabled = !1);
    if (a.graph && a.graph.onGetNodeMenuOptions) {
      a.graph.onGetNodeMenuOptions(b, a);
    }
    return b;
  };
  LGraphCanvas.prototype.processContextMenu = function(a, b) {
    var c = LGraphCanvas.active_canvas.getCanvasWindow(), d = null, e = {event:b, callback:function(b, c, d) {
      b && b == f && (b.input ? a.removeInput(f.slot) : b.output && a.removeOutput(f.slot));
    }, node:a}, f = null;
    a && (f = a.getSlotInPosition(b.canvasX, b.canvasY), LGraphCanvas.active_node = a);
    f ? (d = f.locked ? ["Cannot remove"] : {"Remove Slot":f}, e.title = f.input ? f.input.type : f.output.type, f.input && f.input.type == k.EVENT && (e.title = "Event")) : d = a ? this.getNodeMenuOptions(a) : this.getCanvasMenuOptions();
    d && new k.ContextMenu(d, e, c);
  };
  this.CanvasRenderingContext2D && (CanvasRenderingContext2D.prototype.roundRect = function(a, b, c, d, e, f) {
    void 0 === e && (e = 5);
    void 0 === f && (f = e);
    this.beginPath();
    this.moveTo(a + e, b);
    this.lineTo(a + c - e, b);
    this.quadraticCurveTo(a + c, b, a + c, b + e);
    this.lineTo(a + c, b + d - f);
    this.quadraticCurveTo(a + c, b + d, a + c - f, b + d);
    this.lineTo(a + f, b + d);
    this.quadraticCurveTo(a, b + d, a, b + d - f);
    this.lineTo(a, b + e);
    this.quadraticCurveTo(a, b, a + e, b);
  });
  k.compareObjects = function(a, b) {
    for (var c in a) {
      if (a[c] != b[c]) {
        return !1;
      }
    }
    return !0;
  };
  k.distance = e;
  k.colorToString = function(a) {
    return "rgba(" + Math.round(255 * a[0]).toFixed() + "," + Math.round(255 * a[1]).toFixed() + "," + Math.round(255 * a[2]).toFixed() + "," + (4 == a.length ? a[3].toFixed(2) : "1.0") + ")";
  };
  k.isInsideRectangle = f;
  k.growBounding = function(a, b, c) {
    b < a[0] ? a[0] = b : b > a[2] && (a[2] = b);
    c < a[1] ? a[1] = c : c > a[3] && (a[3] = c);
  };
  k.isInsideBounding = function(a, b) {
    return a[0] < b[0][0] || a[1] < b[0][1] || a[0] > b[1][0] || a[1] > b[1][1] ? !1 : !0;
  };
  k.overlapBounding = g;
  k.hex2num = function(a) {
    "#" == a.charAt(0) && (a = a.slice(1));
    a = a.toUpperCase();
    for (var b = Array(3), c = 0, d, e, f = 0; 6 > f; f += 2) {
      d = "0123456789ABCDEF".indexOf(a.charAt(f)), e = "0123456789ABCDEF".indexOf(a.charAt(f + 1)), b[c] = 16 * d + e, c++;
    }
    return b;
  };
  k.num2hex = function(a) {
    for (var b = "#", c, d, e = 0; 3 > e; e++) {
      c = a[e] / 16, d = a[e] % 16, b += "0123456789ABCDEF".charAt(c) + "0123456789ABCDEF".charAt(d);
    }
    return b;
  };
  l.prototype.addItem = function(a, b, c) {
    function e(a) {
      var b = this.value;
      b && b.has_submenu && d.call(this, a);
    }
    function d(a) {
      var b = this.value, d = !0;
      f.current_submenu && f.current_submenu.close(a);
      if (c.callback) {
        var e = c.callback.call(this, b, c, a, f, c.node);
        !0 === e && (d = !1);
      }
      if (b && (b.callback && !c.ignore_item_callbacks && !0 !== b.disabled && (e = b.callback.call(this, b, c, a, f, c.node), !0 === e && (d = !1)), b.submenu)) {
        if (!b.submenu.options) {
          throw "ContextMenu submenu needs options";
        }
        new f.constructor(b.submenu.options, {callback:b.submenu.callback, event:a, parentMenu:f, ignore_item_callbacks:b.submenu.ignore_item_callbacks, title:b.submenu.title, autoopen:c.autoopen});
        d = !1;
      }
      d && !f.lock && f.close();
    }
    var f = this;
    c = c || {};
    var g = document.createElement("div");
    g.className = "litemenu-entry submenu";
    var k = !1;
    if (null === b) {
      g.classList.add("separator");
    } else {
      g.innerHTML = b && b.title ? b.title : a;
      if (g.value = b) {
        b.disabled && (k = !0, g.classList.add("disabled")), (b.submenu || b.has_submenu) && g.classList.add("has_submenu");
      }
      "function" == typeof b ? (g.dataset.value = a, g.onclick_callback = b) : g.dataset.value = b;
    }
    this.root.appendChild(g);
    k || g.addEventListener("click", d);
    c.autoopen && g.addEventListener("mouseenter", e);
    return g;
  };
  l.prototype.close = function(a, b) {
    this.root.parentNode && this.root.parentNode.removeChild(this.root);
    this.parentMenu && !b && (this.parentMenu.lock = !1, this.parentMenu.current_submenu = null, void 0 === a ? this.parentMenu.close() : a && !l.isCursorOverElement(a, this.parentMenu.root) && l.trigger(this.parentMenu.root, "mouseleave", a));
    this.current_submenu && this.current_submenu.close(a, !0);
  };
  l.trigger = function(a, b, c, d) {
    var e = document.createEvent("CustomEvent");
    e.initCustomEvent(b, !0, !0, c);
    e.srcElement = d;
    a.dispatchEvent ? a.dispatchEvent(e) : a.__events && a.__events.dispatchEvent(e);
    return e;
  };
  l.prototype.getTopMenu = function() {
    return this.options.parentMenu ? this.options.parentMenu.getTopMenu() : this;
  };
  l.prototype.getFirstEvent = function() {
    return this.options.parentMenu ? this.options.parentMenu.getFirstEvent() : this.options.event;
  };
  l.isCursorOverElement = function(a, b) {
    var c = a.pageX;
    a = a.pageY;
    return (b = b.getBoundingClientRect()) ? a > b.top && a < b.top + b.height && c > b.left && c < b.left + b.width ? !0 : !1 : !1;
  };
  k.ContextMenu = l;
  k.closeAllContextMenus = function(a) {
    a = a || window;
    a = a.document.querySelectorAll(".litecontextmenu");
    if (a.length) {
      for (var b = [], c = 0; c < a.length; c++) {
        b.push(a[c]);
      }
      for (c in b) {
        b[c].close ? b[c].close() : b[c].parentNode && b[c].parentNode.removeChild(b[c]);
      }
    }
  };
  k.extendClass = function(a, b) {
    for (var c in b) {
      a.hasOwnProperty(c) || (a[c] = b[c]);
    }
    if (b.prototype) {
      for (c in b.prototype) {
        b.prototype.hasOwnProperty(c) && !a.prototype.hasOwnProperty(c) && (b.prototype.__lookupGetter__(c) ? a.prototype.__defineGetter__(c, b.prototype.__lookupGetter__(c)) : a.prototype[c] = b.prototype[c], b.prototype.__lookupSetter__(c) && a.prototype.__defineSetter__(c, b.prototype.__lookupSetter__(c)));
      }
    }
  };
  window.requestAnimationFrame || (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(a) {
    window.setTimeout(a, 1000 / 60);
  });
})(this);
(function() {
  function d() {
    this.addOutput("in ms", "number");
    this.addOutput("in sec", "number");
  }
  function e() {
    this.size = [120, 60];
    this.subgraph = new LGraph;
    this.subgraph._subgraph_node = this;
    this.subgraph._is_subgraph = !0;
    this.subgraph.onGlobalInputAdded = this.onSubgraphNewGlobalInput.bind(this);
    this.subgraph.onGlobalInputRenamed = this.onSubgraphRenamedGlobalInput.bind(this);
    this.subgraph.onGlobalInputTypeChanged = this.onSubgraphTypeChangeGlobalInput.bind(this);
    this.subgraph.onGlobalOutputAdded = this.onSubgraphNewGlobalOutput.bind(this);
    this.subgraph.onGlobalOutputRenamed = this.onSubgraphRenamedGlobalOutput.bind(this);
    this.subgraph.onGlobalOutputTypeChanged = this.onSubgraphTypeChangeGlobalOutput.bind(this);
    this.bgcolor = "#940";
  }
  function f() {
    var a = "input_" + (1000 * Math.random()).toFixed();
    this.addOutput(a, null);
    this.properties = {name:a, type:null};
    var b = this;
    Object.defineProperty(this.properties, "name", {get:function() {
      return a;
    }, set:function(c) {
      if ("" != c) {
        var e = b.getOutputInfo(0);
        e.name != c && (e.name = c, b.graph && b.graph.renameGlobalInput(a, c), a = c);
      }
    }, enumerable:!0});
    Object.defineProperty(this.properties, "type", {get:function() {
      return b.outputs[0].type;
    }, set:function(c) {
      b.outputs[0].type = c;
      b.graph && b.graph.changeGlobalInputType(a, b.outputs[0].type);
    }, enumerable:!0});
  }
  function g() {
    var a = "output_" + (1000 * Math.random()).toFixed();
    this.addInput(a, null);
    this.properties = {name:a, type:null};
    var b = this;
    Object.defineProperty(this.properties, "name", {get:function() {
      return a;
    }, set:function(c) {
      if ("" != c) {
        var e = b.getInputInfo(0);
        e.name != c && (e.name = c, b.graph && b.graph.renameGlobalOutput(a, c), a = c);
      }
    }, enumerable:!0});
    Object.defineProperty(this.properties, "type", {get:function() {
      return b.inputs[0].type;
    }, set:function(c) {
      b.inputs[0].type = c;
      b.graph && b.graph.changeGlobalInputType(a, b.inputs[0].type);
    }, enumerable:!0});
  }
  function l() {
    this.addOutput("value", "number");
    this.addProperty("value", 1.0);
    this.editable = {property:"value", type:"number"};
  }
  function k() {
    this.size = [60, 20];
    this.addInput("value", 0, {label:""});
    this.addOutput("value", 0, {label:""});
    this.addProperty("value", "");
  }
  function a() {
    this.mode = LiteGraph.ON_EVENT;
    this.size = [60, 20];
    this.addProperty("msg", "");
    this.addInput("log", LiteGraph.EVENT);
    this.addInput("msg", 0);
  }
  function b() {
    this.size = [60, 20];
    this.addProperty("onExecute", "");
    this.addInput("in", "");
    this.addInput("in2", "");
    this.addOutput("out", "");
    this.addOutput("out2", "");
    this._func = null;
  }
  d.title = "Time";
  d.desc = "Time";
  d.prototype.onExecute = function() {
    this.setOutputData(0, 1000 * this.graph.globaltime);
    this.setOutputData(1, this.graph.globaltime);
  };
  LiteGraph.registerNodeType("basic/time", d);
  e.title = "Subgraph";
  e.desc = "Graph inside a node";
  e.prototype.onSubgraphNewGlobalInput = function(a, b) {
    this.addInput(a, b);
  };
  e.prototype.onSubgraphRenamedGlobalInput = function(a, b) {
    a = this.findInputSlot(a);
    -1 != a && (this.getInputInfo(a).name = b);
  };
  e.prototype.onSubgraphTypeChangeGlobalInput = function(a, b) {
    a = this.findInputSlot(a);
    -1 != a && (this.getInputInfo(a).type = b);
  };
  e.prototype.onSubgraphNewGlobalOutput = function(a, b) {
    this.addOutput(a, b);
  };
  e.prototype.onSubgraphRenamedGlobalOutput = function(a, b) {
    a = this.findOutputSlot(a);
    -1 != a && (this.getOutputInfo(a).name = b);
  };
  e.prototype.onSubgraphTypeChangeGlobalOutput = function(a, b) {
    a = this.findOutputSlot(a);
    -1 != a && (this.getOutputInfo(a).type = b);
  };
  e.prototype.getExtraMenuOptions = function(a) {
    var b = this;
    return [{content:"Open", callback:function() {
      a.openSubgraph(b.subgraph);
    }}];
  };
  e.prototype.onExecute = function() {
    if (this.inputs) {
      for (var a = 0; a < this.inputs.length; a++) {
        var b = this.inputs[a], e = this.getInputData(a);
        this.subgraph.setGlobalInputData(b.name, e);
      }
    }
    this.subgraph.runStep();
    if (this.outputs) {
      for (a = 0; a < this.outputs.length; a++) {
        e = this.subgraph.getGlobalOutputData(this.outputs[a].name), this.setOutputData(a, e);
      }
    }
  };
  e.prototype.configure = function(a) {
    LGraphNode.prototype.configure.call(this, a);
  };
  e.prototype.serialize = function() {
    var a = LGraphNode.prototype.serialize.call(this);
    a.subgraph = this.subgraph.serialize();
    return a;
  };
  e.prototype.clone = function() {
    var a = LiteGraph.createNode(this.type), b = this.serialize();
    delete b.id;
    delete b.inputs;
    delete b.outputs;
    a.configure(b);
    return a;
  };
  LiteGraph.registerNodeType("graph/subgraph", e);
  f.title = "Input";
  f.desc = "Input of the graph";
  f.prototype.onAdded = function() {
    this.graph.addGlobalInput(this.properties.name, this.properties.type);
  };
  f.prototype.onExecute = function() {
    var a = this.graph.global_inputs[this.properties.name];
    a && this.setOutputData(0, a.value);
  };
  LiteGraph.registerNodeType("graph/input", f);
  g.title = "Ouput";
  g.desc = "Output of the graph";
  g.prototype.onAdded = function() {
    this.graph.addGlobalOutput(this.properties.name, this.properties.type);
  };
  g.prototype.onExecute = function() {
    this.graph.setGlobalOutputData(this.properties.name, this.getInputData(0));
  };
  LiteGraph.registerNodeType("graph/output", g);
  l.title = "Const";
  l.desc = "Constant value";
  l.prototype.setValue = function(a) {
    "string" == typeof a && (a = parseFloat(a));
    this.properties.value = a;
    this.setDirtyCanvas(!0);
  };
  l.prototype.onExecute = function() {
    this.setOutputData(0, parseFloat(this.properties.value));
  };
  l.prototype.onDrawBackground = function(a) {
    this.outputs[0].label = this.properties.value.toFixed(3);
  };
  l.prototype.onWidget = function(a, b) {
    "value" == b.name && this.setValue(b.value);
  };
  LiteGraph.registerNodeType("basic/const", l);
  k.title = "Watch";
  k.desc = "Show value of input";
  k.prototype.onExecute = function() {
    this.properties.value = this.getInputData(0);
    this.setOutputData(0, this.properties.value);
  };
  k.prototype.onDrawBackground = function(a) {
    this.inputs[0] && null != this.properties.value && (this.properties.value.constructor === Number ? this.inputs[0].label = this.properties.value.toFixed(3) : ((a = this.properties.value) && a.length && (a = Array.prototype.slice.call(a).join(",")), this.inputs[0].label = a));
  };
  LiteGraph.registerNodeType("basic/watch", k);
  a.title = "Console";
  a.desc = "Show value inside the console";
  a.prototype.onAction = function(a, b) {
    "log" == a ? console.log(b) : "warn" == a ? console.warn(b) : "error" == a && console.error(b);
  };
  a.prototype.onExecute = function() {
    var a = this.getInputData(1);
    null !== a && (this.properties.msg = a);
    console.log(a);
  };
  a.prototype.onGetInputs = function() {
    return [["log", LiteGraph.ACTION], ["warn", LiteGraph.ACTION], ["error", LiteGraph.ACTION]];
  };
  LiteGraph.registerNodeType("basic/console", a);
  b.title = "Script";
  b.desc = "executes a code";
  b.widgets_info = {onExecute:{type:"code"}};
  b.prototype.onPropertyChanged = function(a, b) {
    if ("onExecute" == a && LiteGraph.allow_scripts) {
      this._func = null;
      try {
        this._func = new Function(b);
      } catch (n) {
        console.error("Error parsing script"), console.error(n);
      }
    }
  };
  b.prototype.onExecute = function() {
    if (this._func) {
      try {
        this._func.call(this);
      } catch (c) {
        console.error("Error in script"), console.error(c);
      }
    }
  };
  LiteGraph.registerNodeType("basic/script", b);
})();
(function() {
  function d() {
    this.size = [60, 20];
    this.addProperty("time", 1000);
    this.addInput("event", LiteGraph.ACTION);
    this.addOutput("on_time", LiteGraph.EVENT);
    this._pending = [];
  }
  d.title = "Delay";
  d.desc = "Delays one event";
  d.prototype.onAction = function(e, d) {
    this._pending.push([this.properties.time, d]);
  };
  d.prototype.onExecute = function() {
    for (var e = 1000 * this.graph.elapsed_time, d = 0; d < this._pending.length; ++d) {
      var g = this._pending[d];
      g[0] -= e;
      0 < g[0] || (this._pending.splice(d, 1), --d, this.trigger(null, g[1]));
    }
  };
  d.prototype.onGetInputs = function() {
    return [["event", LiteGraph.ACTION]];
  };
  LiteGraph.registerNodeType("events/delay", d);
})();
(function() {
  function d() {
    this.addOutput("clicked", LiteGraph.EVENT);
    this.addProperty("text", "");
    this.addProperty("font", "40px Arial");
    this.addProperty("message", "");
    this.size = [64, 84];
  }
  function e() {
    this.addOutput("", "number");
    this.size = [64, 84];
    this.properties = {min:0, max:1, value:0.5, wcolor:"#7AF", size:50};
  }
  function f() {
    this.size = [160, 26];
    this.addOutput("", "number");
    this.properties = {wcolor:"#7AF", min:0, max:1, value:0.5};
  }
  function g() {
    this.size = [160, 26];
    this.addInput("", "number");
    this.properties = {min:0, max:1, value:0, wcolor:"#AAF"};
  }
  function l() {
    this.addInputs("", 0);
    this.properties = {value:"...", font:"Arial", fontsize:18, color:"#AAA", align:"left", glowSize:0, decimals:1};
  }
  function k() {
    this.size = [200, 100];
    this.properties = {borderColor:"#ffffff", bgcolorTop:"#f0f0f0", bgcolorBottom:"#e0e0e0", shadowSize:2, borderRadius:3};
  }
  d.title = "Button";
  d.desc = "Triggers an event";
  d.prototype.onDrawForeground = function(a) {
    !this.flags.collapsed && (a.fillStyle = "black", a.fillRect(1, 1, this.size[0] - 3, this.size[1] - 3), a.fillStyle = "#AAF", a.fillRect(0, 0, this.size[0] - 3, this.size[1] - 3), a.fillStyle = this.clicked ? "white" : this.mouseOver ? "#668" : "#334", a.fillRect(1, 1, this.size[0] - 4, this.size[1] - 4), this.properties.text || 0 === this.properties.text) && (a.textAlign = "center", a.fillStyle = this.clicked ? "black" : "white", this.properties.font && (a.font = this.properties.font), a.fillText(this.properties.text, 
    0.5 * this.size[0], 0.85 * this.size[1]), a.textAlign = "left");
  };
  d.prototype.onMouseDown = function(a, b) {
    if (1 < b[0] && 1 < b[1] && b[0] < this.size[0] - 2 && b[1] < this.size[1] - 2) {
      return this.clicked = !0, this.trigger("clicked", this.properties.message), !0;
    }
  };
  d.prototype.onMouseUp = function(a) {
    this.clicked = !1;
  };
  LiteGraph.registerNodeType("widget/button", d);
  e.title = "Knob";
  e.desc = "Circular controller";
  e.widgets = [{name:"increase", text:"+", type:"minibutton"}, {name:"decrease", text:"-", type:"minibutton"}];
  e.prototype.onAdded = function() {
    this.value = (this.properties.value - this.properties.min) / (this.properties.max - this.properties.min);
    this.imgbg = this.loadImage("imgs/knob_bg.png");
    this.imgfg = this.loadImage("imgs/knob_fg.png");
  };
  e.prototype.onDrawImageKnob = function(a) {
    if (this.imgfg && this.imgfg.width) {
      var b = 0.5 * this.imgbg.width, c = this.size[0] / this.imgfg.width;
      a.save();
      a.translate(0, 20);
      a.scale(c, c);
      a.drawImage(this.imgbg, 0, 0);
      a.translate(b, b);
      a.rotate(2 * this.value * Math.PI * 6 / 8 + 10 * Math.PI / 8);
      a.translate(-b, -b);
      a.drawImage(this.imgfg, 0, 0);
      a.restore();
      this.title && (a.font = "bold 16px Criticized,Tahoma", a.fillStyle = "rgba(100,100,100,0.8)", a.textAlign = "center", a.fillText(this.title.toUpperCase(), 0.5 * this.size[0], 18), a.textAlign = "left");
    }
  };
  e.prototype.onDrawVectorKnob = function(a) {
    if (this.imgfg && this.imgfg.width) {
      a.lineWidth = 1;
      a.strokeStyle = this.mouseOver ? "#FFF" : "#AAA";
      a.fillStyle = "#000";
      a.beginPath();
      a.arc(0.5 * this.size[0], 0.5 * this.size[1] + 10, 0.5 * this.properties.size, 0, 2 * Math.PI, !0);
      a.stroke();
      0 < this.value && (a.strokeStyle = this.properties.wcolor, a.lineWidth = 0.2 * this.properties.size, a.beginPath(), a.arc(0.5 * this.size[0], 0.5 * this.size[1] + 10, 0.35 * this.properties.size, -0.5 * Math.PI + 2 * Math.PI * this.value, -0.5 * Math.PI, !0), a.stroke(), a.lineWidth = 1);
      a.font = 0.2 * this.properties.size + "px Arial";
      a.fillStyle = "#AAA";
      a.textAlign = "center";
      var b = this.properties.value;
      "number" == typeof b && (b = b.toFixed(2));
      a.fillText(b, 0.5 * this.size[0], 0.65 * this.size[1]);
      a.textAlign = "left";
    }
  };
  e.prototype.onDrawForeground = function(a) {
    this.onDrawImageKnob(a);
  };
  e.prototype.onExecute = function() {
    this.setOutputData(0, this.properties.value);
    this.boxcolor = LiteGraph.colorToString([this.value, this.value, this.value]);
  };
  e.prototype.onMouseDown = function(a) {
    if (this.imgfg && this.imgfg.width) {
      this.center = [0.5 * this.size[0], 0.5 * this.size[1] + 20];
      this.radius = 0.5 * this.size[0];
      if (20 > a.canvasY - this.pos[1] || LiteGraph.distance([a.canvasX, a.canvasY], [this.pos[0] + this.center[0], this.pos[1] + this.center[1]]) > this.radius) {
        return !1;
      }
      this.oldmouse = [a.canvasX - this.pos[0], a.canvasY - this.pos[1]];
      this.captureInput(!0);
      return !0;
    }
  };
  e.prototype.onMouseMove = function(a) {
    if (this.oldmouse) {
      a = [a.canvasX - this.pos[0], a.canvasY - this.pos[1]];
      var b = this.value;
      b -= 0.01 * (a[1] - this.oldmouse[1]);
      1.0 < b ? b = 1.0 : 0.0 > b && (b = 0.0);
      this.value = b;
      this.properties.value = this.properties.min + (this.properties.max - this.properties.min) * this.value;
      this.oldmouse = a;
      this.setDirtyCanvas(!0);
    }
  };
  e.prototype.onMouseUp = function(a) {
    this.oldmouse && (this.oldmouse = null, this.captureInput(!1));
  };
  e.prototype.onMouseLeave = function(a) {
  };
  e.prototype.onWidget = function(a, b) {
    if ("increase" == b.name) {
      this.onPropertyChanged("size", this.properties.size + 10);
    } else {
      if ("decrease" == b.name) {
        this.onPropertyChanged("size", this.properties.size - 10);
      }
    }
  };
  e.prototype.onPropertyChanged = function(a, b) {
    if ("wcolor" == a) {
      this.properties[a] = b;
    } else {
      if ("size" == a) {
        b = parseInt(b), this.properties[a] = b, this.size = [b + 4, b + 24], this.setDirtyCanvas(!0, !0);
      } else {
        if ("min" == a || "max" == a || "value" == a) {
          this.properties[a] = parseFloat(b);
        } else {
          return !1;
        }
      }
    }
    return !0;
  };
  LiteGraph.registerNodeType("widget/knob", e);
  f.title = "H.Slider";
  f.desc = "Linear slider controller";
  f.prototype.onInit = function() {
    this.value = 0.5;
    this.imgfg = this.loadImage("imgs/slider_fg.png");
  };
  f.prototype.onDrawVectorial = function(a) {
    this.imgfg && this.imgfg.width && (a.lineWidth = 1, a.strokeStyle = this.mouseOver ? "#FFF" : "#AAA", a.fillStyle = "#000", a.beginPath(), a.rect(2, 0, this.size[0] - 4, 20), a.stroke(), a.fillStyle = this.properties.wcolor, a.beginPath(), a.rect(2 + (this.size[0] - 4 - 20) * this.value, 0, 20, 20), a.fill());
  };
  f.prototype.onDrawImage = function(a) {
    this.imgfg && this.imgfg.width && (a.lineWidth = 1, a.fillStyle = "#000", a.fillRect(2, 9, this.size[0] - 4, 2), a.strokeStyle = "#333", a.beginPath(), a.moveTo(2, 9), a.lineTo(this.size[0] - 4, 9), a.stroke(), a.strokeStyle = "#AAA", a.beginPath(), a.moveTo(2, 11), a.lineTo(this.size[0] - 4, 11), a.stroke(), a.drawImage(this.imgfg, 2 + (this.size[0] - 4) * this.value - 0.5 * this.imgfg.width, 0.5 * -this.imgfg.height + 10));
  };
  f.prototype.onDrawForeground = function(a) {
    this.onDrawImage(a);
  };
  f.prototype.onExecute = function() {
    this.properties.value = this.properties.min + (this.properties.max - this.properties.min) * this.value;
    this.setOutputData(0, this.properties.value);
    this.boxcolor = LiteGraph.colorToString([this.value, this.value, this.value]);
  };
  f.prototype.onMouseDown = function(a) {
    if (0 > a.canvasY - this.pos[1]) {
      return !1;
    }
    this.oldmouse = [a.canvasX - this.pos[0], a.canvasY - this.pos[1]];
    this.captureInput(!0);
    return !0;
  };
  f.prototype.onMouseMove = function(a) {
    if (this.oldmouse) {
      a = [a.canvasX - this.pos[0], a.canvasY - this.pos[1]];
      var b = this.value;
      b += (a[0] - this.oldmouse[0]) / this.size[0];
      1.0 < b ? b = 1.0 : 0.0 > b && (b = 0.0);
      this.value = b;
      this.oldmouse = a;
      this.setDirtyCanvas(!0);
    }
  };
  f.prototype.onMouseUp = function(a) {
    this.oldmouse = null;
    this.captureInput(!1);
  };
  f.prototype.onMouseLeave = function(a) {
  };
  f.prototype.onPropertyChanged = function(a, b) {
    if ("wcolor" == a) {
      this.properties[a] = b;
    } else {
      return !1;
    }
    return !0;
  };
  LiteGraph.registerNodeType("widget/hslider", f);
  g.title = "Progress";
  g.desc = "Shows data in linear progress";
  g.prototype.onExecute = function() {
    var a = this.getInputData(0);
    void 0 != a && (this.properties.value = a);
  };
  g.prototype.onDrawForeground = function(a) {
    a.lineWidth = 1;
    a.fillStyle = this.properties.wcolor;
    var b = (this.properties.value - this.properties.min) / (this.properties.max - this.properties.min);
    b = Math.min(1, b);
    b = Math.max(0, b);
    a.fillRect(2, 2, (this.size[0] - 4) * b, this.size[1] - 4);
  };
  LiteGraph.registerNodeType("widget/progress", g);
  l.title = "Text";
  l.desc = "Shows the input value";
  l.widgets = [{name:"resize", text:"Resize box", type:"button"}, {name:"led_text", text:"LED", type:"minibutton"}, {name:"normal_text", text:"Normal", type:"minibutton"}];
  l.prototype.onDrawForeground = function(a) {
    a.fillStyle = this.properties.color;
    var b = this.properties.value;
    this.properties.glowSize ? (a.shadowColor = this.properties.color, a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = this.properties.glowSize) : a.shadowColor = "transparent";
    var c = this.properties.fontsize;
    a.textAlign = this.properties.align;
    a.font = c.toString() + "px " + this.properties.font;
    this.str = "number" == typeof b ? b.toFixed(this.properties.decimals) : b;
    if ("string" == typeof this.str) {
      b = this.str.split("\\n");
      for (var e in b) {
        a.fillText(b[e], "left" == this.properties.align ? 15 : this.size[0] - 15, -0.15 * c + c * (parseInt(e) + 1));
      }
    }
    a.shadowColor = "transparent";
    this.last_ctx = a;
    a.textAlign = "left";
  };
  l.prototype.onExecute = function() {
    var a = this.getInputData(0);
    this.properties.value = null != a ? a : "";
    this.setDirtyCanvas(!0);
  };
  l.prototype.resize = function() {
    if (this.last_ctx) {
      var a = this.str.split("\\n");
      this.last_ctx.font = this.properties.fontsize + "px " + this.properties.font;
      var b = 0, c;
      for (c in a) {
        var e = this.last_ctx.measureText(a[c]).width;
        b < e && (b = e);
      }
      this.size[0] = b + 20;
      this.size[1] = 4 + a.length * this.properties.fontsize;
      this.setDirtyCanvas(!0);
    }
  };
  l.prototype.onWidget = function(a, b) {
    "resize" == b.name ? this.resize() : "led_text" == b.name ? (this.properties.font = "Digital", this.properties.glowSize = 4, this.setDirtyCanvas(!0)) : "normal_text" == b.name && (this.properties.font = "Arial", this.setDirtyCanvas(!0));
  };
  l.prototype.onPropertyChanged = function(a, b) {
    this.properties[a] = b;
    this.str = "number" == typeof b ? b.toFixed(3) : b;
    return !0;
  };
  LiteGraph.registerNodeType("widget/text", l);
  k.title = "Panel";
  k.desc = "Non interactive panel";
  k.widgets = [{name:"update", text:"Update", type:"button"}];
  k.prototype.createGradient = function(a) {
    "" == this.properties.bgcolorTop || "" == this.properties.bgcolorBottom ? this.lineargradient = 0 : (this.lineargradient = a.createLinearGradient(0, 0, 0, this.size[1]), this.lineargradient.addColorStop(0, this.properties.bgcolorTop), this.lineargradient.addColorStop(1, this.properties.bgcolorBottom));
  };
  k.prototype.onDrawForeground = function(a) {
    null == this.lineargradient && this.createGradient(a);
    this.lineargradient && (a.lineWidth = 1, a.strokeStyle = this.properties.borderColor, a.fillStyle = this.lineargradient, this.properties.shadowSize ? (a.shadowColor = "#000", a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = this.properties.shadowSize) : a.shadowColor = "transparent", a.roundRect(0, 0, this.size[0] - 1, this.size[1] - 1, this.properties.shadowSize), a.fill(), a.shadowColor = "transparent", a.stroke());
  };
  k.prototype.onWidget = function(a, b) {
    "update" == b.name && (this.lineargradient = null, this.setDirtyCanvas(!0));
  };
  LiteGraph.registerNodeType("widget/panel", k);
})();
(function() {
  function d() {
    this.addOutput("left_x_axis", "number");
    this.addOutput("left_y_axis", "number");
    this.properties = {};
  }
  d.title = "Gamepad";
  d.desc = "gets the input of the gamepad";
  d.prototype.onExecute = function() {
    var e = this.getGamepad();
    if (this.outputs) {
      for (var d = 0; d < this.outputs.length; d++) {
        var g = this.outputs[d], l = null;
        if (e) {
          switch(g.name) {
            case "left_axis":
              l = [e.xbox.axes.lx, e.xbox.axes.ly];
              break;
            case "right_axis":
              l = [e.xbox.axes.rx, e.xbox.axes.ry];
              break;
            case "left_x_axis":
              l = e.xbox.axes.lx;
              break;
            case "left_y_axis":
              l = e.xbox.axes.ly;
              break;
            case "right_x_axis":
              l = e.xbox.axes.rx;
              break;
            case "right_y_axis":
              l = e.xbox.axes.ry;
              break;
            case "trigger_left":
              l = e.xbox.axes.ltrigger;
              break;
            case "trigger_right":
              l = e.xbox.axes.rtrigger;
              break;
            case "a_button":
              l = e.xbox.buttons.a ? 1 : 0;
              break;
            case "b_button":
              l = e.xbox.buttons.b ? 1 : 0;
              break;
            case "x_button":
              l = e.xbox.buttons.x ? 1 : 0;
              break;
            case "y_button":
              l = e.xbox.buttons.y ? 1 : 0;
              break;
            case "lb_button":
              l = e.xbox.buttons.lb ? 1 : 0;
              break;
            case "rb_button":
              l = e.xbox.buttons.rb ? 1 : 0;
              break;
            case "ls_button":
              l = e.xbox.buttons.ls ? 1 : 0;
              break;
            case "rs_button":
              l = e.xbox.buttons.rs ? 1 : 0;
              break;
            case "start_button":
              l = e.xbox.buttons.start ? 1 : 0;
              break;
            case "back_button":
              l = e.xbox.buttons.back ? 1 : 0;
          }
        } else {
          switch(g.name) {
            case "left_axis":
            case "right_axis":
              l = [0, 0];
              break;
            default:
              l = 0;
          }
        }
        this.setOutputData(d, l);
      }
    }
  };
  d.prototype.getGamepad = function() {
    var e = navigator.getGamepads || navigator.webkitGetGamepads || navigator.mozGetGamepads;
    if (!e) {
      return null;
    }
    var d = e.call(navigator);
    for (e = 0; 4 > e; e++) {
      if (d[e]) {
        d = d[e];
        var g = this.xbox_mapping;
        g || (g = this.xbox_mapping = {axes:[], buttons:{}, hat:""});
        g.axes.lx = d.axes[0];
        g.axes.ly = d.axes[1];
        g.axes.rx = d.axes[2];
        g.axes.ry = d.axes[3];
        g.axes.ltrigger = d.buttons[6].value;
        g.axes.rtrigger = d.buttons[7].value;
        for (e = 0; e < d.buttons.length; e++) {
          switch(e) {
            case 0:
              g.buttons.a = d.buttons[e].pressed;
              break;
            case 1:
              g.buttons.b = d.buttons[e].pressed;
              break;
            case 2:
              g.buttons.x = d.buttons[e].pressed;
              break;
            case 3:
              g.buttons.y = d.buttons[e].pressed;
              break;
            case 4:
              g.buttons.lb = d.buttons[e].pressed;
              break;
            case 5:
              g.buttons.rb = d.buttons[e].pressed;
              break;
            case 6:
              g.buttons.lt = d.buttons[e].pressed;
              break;
            case 7:
              g.buttons.rt = d.buttons[e].pressed;
              break;
            case 8:
              g.buttons.back = d.buttons[e].pressed;
              break;
            case 9:
              g.buttons.start = d.buttons[e].pressed;
              break;
            case 10:
              g.buttons.ls = d.buttons[e].pressed;
              break;
            case 11:
              g.buttons.rs = d.buttons[e].pressed;
              break;
            case 12:
              d.buttons[e].pressed && (g.hat += "up");
              break;
            case 13:
              d.buttons[e].pressed && (g.hat += "down");
              break;
            case 14:
              d.buttons[e].pressed && (g.hat += "left");
              break;
            case 15:
              d.buttons[e].pressed && (g.hat += "right");
              break;
            case 16:
              g.buttons.home = d.buttons[e].pressed;
          }
        }
        d.xbox = g;
        return d;
      }
    }
  };
  d.prototype.onDrawBackground = function(d) {
  };
  d.prototype.onGetOutputs = function() {
    return [["left_axis", "vec2"], ["right_axis", "vec2"], ["left_x_axis", "number"], ["left_y_axis", "number"], ["right_x_axis", "number"], ["right_y_axis", "number"], ["trigger_left", "number"], ["trigger_right", "number"], ["a_button", "number"], ["b_button", "number"], ["x_button", "number"], ["y_button", "number"], ["lb_button", "number"], ["rb_button", "number"], ["ls_button", "number"], ["rs_button", "number"], ["start", "number"], ["back", "number"]];
  };
  LiteGraph.registerNodeType("input/gamepad", d);
})();
(function() {
  function d() {
    this.addInput("in", "*");
    this.size = [60, 20];
  }
  function e() {
    this.addInput("in");
    this.addOutput("out");
    this.size = [60, 20];
  }
  function f() {
    this.addInput("in", "number", {locked:!0});
    this.addOutput("out", "number", {locked:!0});
    this.addProperty("in", 0);
    this.addProperty("in_min", 0);
    this.addProperty("in_max", 1);
    this.addProperty("out_min", 0);
    this.addProperty("out_max", 1);
  }
  function g() {
    this.addOutput("value", "number");
    this.addProperty("min", 0);
    this.addProperty("max", 1);
    this.size = [60, 20];
  }
  function l() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [60, 20];
    this.addProperty("min", 0);
    this.addProperty("max", 1);
  }
  function k() {
    this.properties = {f:0.5};
    this.addInput("A", "number");
    this.addInput("B", "number");
    this.addOutput("out", "number");
  }
  function a() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [60, 20];
  }
  function b() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [60, 20];
  }
  function c() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [60, 20];
  }
  function h() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [60, 20];
    this.properties = {A:0, B:1};
  }
  function n() {
    this.addInput("in", "number", {label:""});
    this.addOutput("out", "number", {label:""});
    this.size = [60, 20];
    this.addProperty("factor", 1);
  }
  function v() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [60, 20];
    this.addProperty("samples", 10);
    this._values = new Float32Array(10);
    this._current = 0;
  }
  function u() {
    this.addInput("A", "number");
    this.addInput("B", "number");
    this.addOutput("=", "number");
    this.addProperty("A", 1);
    this.addProperty("B", 1);
    this.addProperty("OP", "+", "string", {values:u.values});
  }
  function r() {
    this.addInput("A", "number");
    this.addInput("B", "number");
    this.addOutput("A==B", "boolean");
    this.addOutput("A!=B", "boolean");
    this.addProperty("A", 0);
    this.addProperty("B", 0);
  }
  function t() {
    this.addInput("A", "number");
    this.addInput("B", "number");
    this.addOutput("out", "boolean");
    this.addProperty("A", 1);
    this.addProperty("B", 1);
    this.addProperty("OP", ">", "string", {values:t.values});
    this.size = [60, 40];
  }
  function p() {
    this.addInput("inc", "number");
    this.addOutput("total", "number");
    this.addProperty("increment", 1);
    this.addProperty("value", 0);
  }
  function q() {
    this.addInput("v", "number");
    this.addOutput("sin", "number");
    this.addProperty("amplitude", 1);
    this.addProperty("offset", 0);
    this.bgImageUrl = "nodes/imgs/icon-sin.png";
  }
  function w() {
    this.addInput("vec2", "vec2");
    this.addOutput("x", "number");
    this.addOutput("y", "number");
  }
  function y() {
    this.addInputs([["x", "number"], ["y", "number"]]);
    this.addOutput("vec2", "vec2");
    this.properties = {x:0, y:0};
    this._data = new Float32Array(2);
  }
  function z() {
    this.addInput("vec3", "vec3");
    this.addOutput("x", "number");
    this.addOutput("y", "number");
    this.addOutput("z", "number");
  }
  function A() {
    this.addInputs([["x", "number"], ["y", "number"], ["z", "number"]]);
    this.addOutput("vec3", "vec3");
    this.properties = {x:0, y:0, z:0};
    this._data = new Float32Array(3);
  }
  function B() {
    this.addInput("vec4", "vec4");
    this.addOutput("x", "number");
    this.addOutput("y", "number");
    this.addOutput("z", "number");
    this.addOutput("w", "number");
  }
  function C() {
    this.addInputs([["x", "number"], ["y", "number"], ["z", "number"], ["w", "number"]]);
    this.addOutput("vec4", "vec4");
    this.properties = {x:0, y:0, z:0, w:0};
    this._data = new Float32Array(4);
  }
  d.title = "Converter";
  d.desc = "type A to type B";
  d.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (null != a && this.outputs) {
      for (var b = 0; b < this.outputs.length; b++) {
        var c = this.outputs[b];
        if (c.links && c.links.length) {
          var d = null;
          switch(c.name) {
            case "number":
              d = a.length ? a[0] : parseFloat(a);
              break;
            case "vec2":
            case "vec3":
            case "vec4":
              d = 1;
              switch(c.name) {
                case "vec2":
                  d = 2;
                  break;
                case "vec3":
                  d = 3;
                  break;
                case "vec4":
                  d = 4;
              }d = new Float32Array(d);
              if (a.length) {
                for (c = 0; c < a.length && c < d.length; c++) {
                  d[c] = a[c];
                }
              } else {
                d[0] = parseFloat(a);
              }
          }
          this.setOutputData(b, d);
        }
      }
    }
  };
  d.prototype.onGetOutputs = function() {
    return [["number", "number"], ["vec2", "vec2"], ["vec3", "vec3"], ["vec4", "vec4"]];
  };
  LiteGraph.registerNodeType("math/converter", d);
  e.title = "Bypass";
  e.desc = "removes the type";
  e.prototype.onExecute = function() {
    var a = this.getInputData(0);
    this.setOutputData(0, a);
  };
  LiteGraph.registerNodeType("math/bypass", e);
  f.title = "Range";
  f.desc = "Convert a number from one range to another";
  f.prototype.onExecute = function() {
    if (this.inputs) {
      for (var a = 0; a < this.inputs.length; a++) {
        var b = this.inputs[a], c = this.getInputData(a);
        void 0 !== c && (this.properties[b.name] = c);
      }
    }
    c = this.properties["in"];
    if (void 0 === c || null === c || c.constructor !== Number) {
      c = 0;
    }
    a = this.properties.in_min;
    b = this.properties.out_min;
    this._last_v = (c - a) / (this.properties.in_max - a) * (this.properties.out_max - b) + b;
    this.setOutputData(0, this._last_v);
  };
  f.prototype.onDrawBackground = function(a) {
    this.outputs[0].label = this._last_v ? this._last_v.toFixed(3) : "?";
  };
  f.prototype.onGetInputs = function() {
    return [["in_min", "number"], ["in_max", "number"], ["out_min", "number"], ["out_max", "number"]];
  };
  LiteGraph.registerNodeType("math/range", f);
  g.title = "Rand";
  g.desc = "Random number";
  g.prototype.onExecute = function() {
    if (this.inputs) {
      for (var a = 0; a < this.inputs.length; a++) {
        var b = this.inputs[a], c = this.getInputData(a);
        void 0 !== c && (this.properties[b.name] = c);
      }
    }
    a = this.properties.min;
    this._last_v = Math.random() * (this.properties.max - a) + a;
    this.setOutputData(0, this._last_v);
  };
  g.prototype.onDrawBackground = function(a) {
    this.outputs[0].label = this._last_v ? this._last_v.toFixed(3) : "?";
  };
  g.prototype.onGetInputs = function() {
    return [["min", "number"], ["max", "number"]];
  };
  LiteGraph.registerNodeType("math/rand", g);
  l.title = "Clamp";
  l.desc = "Clamp number between min and max";
  l.filter = "shader";
  l.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (a = Math.max(this.properties.min, a), a = Math.min(this.properties.max, a), this.setOutputData(0, a));
  };
  l.prototype.getCode = function(a) {
    a = "";
    this.isInputConnected(0) && (a += "clamp({{0}}," + this.properties.min + "," + this.properties.max + ")");
    return a;
  };
  LiteGraph.registerNodeType("math/clamp", l);
  k.title = "Lerp";
  k.desc = "Linear Interpolation";
  k.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = 0);
    var b = this.getInputData(1);
    null == b && (b = 0);
    var c = this.properties.f, d = this.getInputData(2);
    void 0 !== d && (c = d);
    this.setOutputData(0, a * (1 - c) + b * c);
  };
  k.prototype.onGetInputs = function() {
    return [["f", "number"]];
  };
  LiteGraph.registerNodeType("math/lerp", k);
  a.title = "Abs";
  a.desc = "Absolute";
  a.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, Math.abs(a));
  };
  LiteGraph.registerNodeType("math/abs", a);
  b.title = "Floor";
  b.desc = "Floor number to remove fractional part";
  b.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, Math.floor(a));
  };
  LiteGraph.registerNodeType("math/floor", b);
  c.title = "Frac";
  c.desc = "Returns fractional part";
  c.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, a % 1);
  };
  LiteGraph.registerNodeType("math/frac", c);
  h.title = "Smoothstep";
  h.desc = "Smoothstep";
  h.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (void 0 !== a) {
      var b = this.properties.A;
      a = Math.clamp((a - b) / (this.properties.B - b), 0.0, 1.0);
      this.setOutputData(0, a * a * (3 - 2 * a));
    }
  };
  LiteGraph.registerNodeType("math/smoothstep", h);
  n.title = "Scale";
  n.desc = "v * factor";
  n.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, a * this.properties.factor);
  };
  LiteGraph.registerNodeType("math/scale", n);
  v.title = "Average";
  v.desc = "Average Filter";
  v.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = 0);
    var b = this._values.length;
    this._values[this._current % b] = a;
    this._current += 1;
    this._current > b && (this._current = 0);
    for (var c = a = 0; c < b; ++c) {
      a += this._values[c];
    }
    this.setOutputData(0, a / b);
  };
  v.prototype.onPropertyChanged = function(a, b) {
    1 > b && (b = 1);
    this.properties.samples = Math.round(b);
    a = this._values;
    this._values = new Float32Array(this.properties.samples);
    a.length <= this._values.length ? this._values.set(a) : this._values.set(a.subarray(0, this._values.length));
  };
  LiteGraph.registerNodeType("math/average", v);
  u.values = "+-*/%^".split("");
  u.title = "Operation";
  u.desc = "Easy math operators";
  u["@OP"] = {type:"enum", title:"operation", values:u.values};
  u.prototype.setValue = function(a) {
    "string" == typeof a && (a = parseFloat(a));
    this.properties.value = a;
  };
  u.prototype.onExecute = function() {
    var a = this.getInputData(0), b = this.getInputData(1);
    null != a ? this.properties.A = a : a = this.properties.A;
    null != b ? this.properties.B = b : b = this.properties.B;
    var c = 0;
    switch(this.properties.OP) {
      case "+":
        c = a + b;
        break;
      case "-":
        c = a - b;
        break;
      case "x":
      case "X":
      case "*":
        c = a * b;
        break;
      case "/":
        c = a / b;
        break;
      case "%":
        c = a % b;
        break;
      case "^":
        c = Math.pow(a, b);
        break;
      default:
        console.warn("Unknown operation: " + this.properties.OP);
    }
    this.setOutputData(0, c);
  };
  u.prototype.onDrawBackground = function(a) {
    this.flags.collapsed || (a.font = "40px Arial", a.fillStyle = "black", a.textAlign = "center", a.fillText(this.properties.OP, 0.5 * this.size[0], 0.5 * this.size[1] + LiteGraph.NODE_TITLE_HEIGHT), a.textAlign = "left");
  };
  LiteGraph.registerNodeType("math/operation", u);
  r.title = "Compare";
  r.desc = "compares between two values";
  r.prototype.onExecute = function() {
    var a = this.getInputData(0), b = this.getInputData(1);
    void 0 !== a ? this.properties.A = a : a = this.properties.A;
    void 0 !== b ? this.properties.B = b : b = this.properties.B;
    for (var c = 0, d = this.outputs.length; c < d; ++c) {
      var e = this.outputs[c];
      if (e.links && e.links.length) {
        switch(e.name) {
          case "A==B":
            value = a == b;
            break;
          case "A!=B":
            value = a != b;
            break;
          case "A>B":
            value = a > b;
            break;
          case "A<B":
            value = a < b;
            break;
          case "A<=B":
            value = a <= b;
            break;
          case "A>=B":
            value = a >= b;
        }
        this.setOutputData(c, value);
      }
    }
  };
  r.prototype.onGetOutputs = function() {
    return [["A==B", "boolean"], ["A!=B", "boolean"], ["A>B", "boolean"], ["A<B", "boolean"], ["A>=B", "boolean"], ["A<=B", "boolean"]];
  };
  LiteGraph.registerNodeType("math/compare", r);
  t.values = "> < == != <= >=".split(" ");
  t["@OP"] = {type:"enum", title:"operation", values:t.values};
  t.title = "Condition";
  t.desc = "evaluates condition between A and B";
  t.prototype.onExecute = function() {
    var a = this.getInputData(0);
    void 0 === a ? a = this.properties.A : this.properties.A = a;
    var b = this.getInputData(1);
    void 0 === b ? b = this.properties.B : this.properties.B = b;
    var c = !0;
    switch(this.properties.OP) {
      case ">":
        c = a > b;
        break;
      case "<":
        c = a < b;
        break;
      case "==":
        c = a == b;
        break;
      case "!=":
        c = a != b;
        break;
      case "<=":
        c = a <= b;
        break;
      case ">=":
        c = a >= b;
    }
    this.setOutputData(0, c);
  };
  LiteGraph.registerNodeType("math/condition", t);
  p.title = "Accumulate";
  p.desc = "Increments a value every time";
  p.prototype.onExecute = function() {
    null === this.properties.value && (this.properties.value = 0);
    var a = this.getInputData(0);
    this.properties.value = null !== a ? this.properties.value + a : this.properties.value + this.properties.increment;
    this.setOutputData(0, this.properties.value);
  };
  LiteGraph.registerNodeType("math/accumulate", p);
  q.title = "Trigonometry";
  q.desc = "Sin Cos Tan";
  q.filter = "shader";
  q.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = 0);
    var b = this.properties.amplitude, c = this.findInputSlot("amplitude");
    -1 != c && (b = this.getInputData(c));
    var d = this.properties.offset;
    c = this.findInputSlot("offset");
    -1 != c && (d = this.getInputData(c));
    c = 0;
    for (var e = this.outputs.length; c < e; ++c) {
      switch(this.outputs[c].name) {
        case "sin":
          value = Math.sin(a);
          break;
        case "cos":
          value = Math.cos(a);
          break;
        case "tan":
          value = Math.tan(a);
          break;
        case "asin":
          value = Math.asin(a);
          break;
        case "acos":
          value = Math.acos(a);
          break;
        case "atan":
          value = Math.atan(a);
      }
      this.setOutputData(c, b * value + d);
    }
  };
  q.prototype.onGetInputs = function() {
    return [["v", "number"], ["amplitude", "number"], ["offset", "number"]];
  };
  q.prototype.onGetOutputs = function() {
    return [["sin", "number"], ["cos", "number"], ["tan", "number"], ["asin", "number"], ["acos", "number"], ["atan", "number"]];
  };
  LiteGraph.registerNodeType("math/trigonometry", q);
  if (window.math) {
    var x = function() {
      this.addInputs("x", "number");
      this.addInputs("y", "number");
      this.addOutputs("", "number");
      this.properties = {x:1.0, y:1.0, formula:"x+y"};
    };
    x.title = "Formula";
    x.desc = "Compute safe formula";
    x.prototype.onExecute = function() {
      var a = this.getInputData(0), b = this.getInputData(1);
      null != a ? this.properties.x = a : a = this.properties.x;
      null != b ? this.properties.y = b : b = this.properties.y;
      a = math.eval(this.properties.formula, {x:a, y:b, T:this.graph.globaltime});
      this.setOutputData(0, a);
    };
    x.prototype.onDrawBackground = function() {
      this.outputs[0].label = this.properties.formula;
    };
    x.prototype.onGetOutputs = function() {
      return [["A-B", "number"], ["A*B", "number"], ["A/B", "number"]];
    };
    LiteGraph.registerNodeType("math/formula", x);
  }
  w.title = "Vec2->XY";
  w.desc = "vector 2 to components";
  w.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (this.setOutputData(0, a[0]), this.setOutputData(1, a[1]));
  };
  LiteGraph.registerNodeType("math3d/vec2-to-xyz", w);
  y.title = "XY->Vec2";
  y.desc = "components to vector2";
  y.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = this.properties.x);
    var b = this.getInputData(1);
    null == b && (b = this.properties.y);
    var c = this._data;
    c[0] = a;
    c[1] = b;
    this.setOutputData(0, c);
  };
  LiteGraph.registerNodeType("math3d/xy-to-vec2", y);
  z.title = "Vec3->XYZ";
  z.desc = "vector 3 to components";
  z.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (this.setOutputData(0, a[0]), this.setOutputData(1, a[1]), this.setOutputData(2, a[2]));
  };
  LiteGraph.registerNodeType("math3d/vec3-to-xyz", z);
  A.title = "XYZ->Vec3";
  A.desc = "components to vector3";
  A.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = this.properties.x);
    var b = this.getInputData(1);
    null == b && (b = this.properties.y);
    var c = this.getInputData(2);
    null == c && (c = this.properties.z);
    var d = this._data;
    d[0] = a;
    d[1] = b;
    d[2] = c;
    this.setOutputData(0, d);
  };
  LiteGraph.registerNodeType("math3d/xyz-to-vec3", A);
  B.title = "Vec4->XYZW";
  B.desc = "vector 4 to components";
  B.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (this.setOutputData(0, a[0]), this.setOutputData(1, a[1]), this.setOutputData(2, a[2]), this.setOutputData(3, a[3]));
  };
  LiteGraph.registerNodeType("math3d/vec4-to-xyzw", B);
  C.title = "XYZW->Vec4";
  C.desc = "components to vector4";
  C.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = this.properties.x);
    var b = this.getInputData(1);
    null == b && (b = this.properties.y);
    var c = this.getInputData(2);
    null == c && (c = this.properties.z);
    var d = this.getInputData(3);
    null == d && (d = this.properties.w);
    var e = this._data;
    e[0] = a;
    e[1] = b;
    e[2] = c;
    e[3] = d;
    this.setOutputData(0, e);
  };
  LiteGraph.registerNodeType("math3d/xyzw-to-vec4", C);
  if (window.glMatrix) {
    x = function() {
      this.addInputs([["A", "quat"], ["B", "quat"], ["factor", "number"]]);
      this.addOutput("slerp", "quat");
      this.addProperty("factor", 0.5);
      this._value = quat.create();
    };
    var D = function() {
      this.addInputs([["A", "quat"], ["B", "quat"]]);
      this.addOutput("A*B", "quat");
      this._value = quat.create();
    }, E = function() {
      this.addInputs([["vec3", "vec3"], ["quat", "quat"]]);
      this.addOutput("result", "vec3");
      this.properties = {vec:[0, 0, 1]};
    }, F = function() {
      this.addInputs([["degrees", "number"], ["axis", "vec3"]]);
      this.addOutput("quat", "quat");
      this.properties = {angle:90.0, axis:vec3.fromValues(0, 1, 0)};
      this._value = quat.create();
    }, G = function() {
      this.addOutput("quat", "quat");
      this.properties = {x:0, y:0, z:0, w:1};
      this._value = quat.create();
    };
    G.title = "Quaternion";
    G.desc = "quaternion";
    G.prototype.onExecute = function() {
      this._value[0] = this.properties.x;
      this._value[1] = this.properties.y;
      this._value[2] = this.properties.z;
      this._value[3] = this.properties.w;
      this.setOutputData(0, this._value);
    };
    LiteGraph.registerNodeType("math3d/quaternion", G);
    F.title = "Rotation";
    F.desc = "quaternion rotation";
    F.prototype.onExecute = function() {
      var a = this.getInputData(0);
      null == a && (a = this.properties.angle);
      var b = this.getInputData(1);
      null == b && (b = this.properties.axis);
      a = quat.setAxisAngle(this._value, b, 0.0174532925 * a);
      this.setOutputData(0, a);
    };
    LiteGraph.registerNodeType("math3d/rotation", F);
    E.title = "Rot. Vec3";
    E.desc = "rotate a point";
    E.prototype.onExecute = function() {
      var a = this.getInputData(0);
      null == a && (a = this.properties.vec);
      var b = this.getInputData(1);
      null == b ? this.setOutputData(a) : this.setOutputData(0, vec3.transformQuat(vec3.create(), a, b));
    };
    LiteGraph.registerNodeType("math3d/rotate_vec3", E);
    D.title = "Mult. Quat";
    D.desc = "rotate quaternion";
    D.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (null != a) {
        var b = this.getInputData(1);
        null != b && (a = quat.multiply(this._value, a, b), this.setOutputData(0, a));
      }
    };
    LiteGraph.registerNodeType("math3d/mult-quat", D);
    x.title = "Quat Slerp";
    x.desc = "quaternion spherical interpolation";
    x.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (null != a) {
        var b = this.getInputData(1);
        if (null != b) {
          var c = this.properties.factor;
          null != this.getInputData(2) && (c = this.getInputData(2));
          a = quat.slerp(this._value, a, b, c);
          this.setOutputData(0, a);
        }
      }
    };
    LiteGraph.registerNodeType("math3d/quat-slerp", x);
  }
})();
function Selector() {
  this.addInput("sel", "boolean");
  this.addOutput("value", "number");
  this.properties = {A:0, B:1};
  this.size = [60, 20];
}
Selector.title = "Selector";
Selector.desc = "outputs A if selector is true, B if selector is false";
Selector.prototype.onExecute = function() {
  var d = this.getInputData(0);
  if (void 0 !== d) {
    for (var e = 1; e < this.inputs.length; e++) {
      var f = this.inputs[e], g = this.getInputData(e);
      void 0 !== g && (this.properties[f.name] = g);
    }
    e = this.properties.A;
    f = this.properties.B;
    this.setOutputData(0, d ? e : f);
  }
};
Selector.prototype.onGetInputs = function() {
  return [["A", 0], ["B", 0]];
};
LiteGraph.registerNodeType("logic/selector", Selector);
(function() {
  function d() {
    this.inputs = [];
    this.addOutput("frame", "image");
    this.properties = {url:""};
  }
  function e() {
    this.addInput("f", "number");
    this.addOutput("Color", "color");
    this.properties = {colorA:"#444444", colorB:"#44AAFF", colorC:"#44FFAA", colorD:"#FFFFFF"};
  }
  function f() {
    this.addInput("", "image");
    this.size = [200, 200];
  }
  function g() {
    this.addInputs([["img1", "image"], ["img2", "image"], ["fade", "number"]]);
    this.addOutput("", "image");
    this.properties = {fade:0.5, width:512, height:512};
  }
  function l() {
    this.addInput("", "image");
    this.addOutput("", "image");
    this.properties = {width:256, height:256, x:0, y:0, scale:1.0};
    this.size = [50, 20];
  }
  function k() {
    this.addInput("t", "number");
    this.addOutputs([["frame", "image"], ["t", "number"], ["d", "number"]]);
    this.properties = {url:""};
  }
  function a() {
    this.addOutput("Webcam", "image");
    this.properties = {};
  }
  d.title = "Image";
  d.desc = "Image loader";
  d.widgets = [{name:"load", text:"Load", type:"button"}];
  d.supported_extensions = ["jpg", "jpeg", "png", "gif"];
  d.prototype.onAdded = function() {
    "" != this.properties.url && null == this.img && this.loadImage(this.properties.url);
  };
  d.prototype.onDrawBackground = function(a) {
    this.img && 5 < this.size[0] && 5 < this.size[1] && a.drawImage(this.img, 0, 0, this.size[0], this.size[1]);
  };
  d.prototype.onExecute = function() {
    this.img || (this.boxcolor = "#000");
    this.img && this.img.width ? this.setOutputData(0, this.img) : this.setOutputData(0, null);
    this.img && this.img.dirty && (this.img.dirty = !1);
  };
  d.prototype.onPropertyChanged = function(a, c) {
    this.properties[a] = c;
    "url" == a && "" != c && this.loadImage(c);
    return !0;
  };
  d.prototype.loadImage = function(a, c) {
    if ("" == a) {
      this.img = null;
    } else {
      this.img = document.createElement("img");
      "http://" == a.substr(0, 7) && LiteGraph.proxy && (a = LiteGraph.proxy + a.substr(7));
      this.img.src = a;
      this.boxcolor = "#F95";
      var b = this;
      this.img.onload = function() {
        c && c(this);
        b.trace("Image loaded, size: " + b.img.width + "x" + b.img.height);
        this.dirty = !0;
        b.boxcolor = "#9F9";
        b.setDirtyCanvas(!0);
      };
    }
  };
  d.prototype.onWidget = function(a, c) {
    "load" == c.name && this.loadImage(this.properties.url);
  };
  d.prototype.onDropFile = function(a) {
    var b = this;
    this._url && URL.revokeObjectURL(this._url);
    this._url = URL.createObjectURL(a);
    this.properties.url = this._url;
    this.loadImage(this._url, function(a) {
      b.size[1] = a.height / a.width * b.size[0];
    });
  };
  LiteGraph.registerNodeType("graphics/image", d);
  e.title = "Palette";
  e.desc = "Generates a color";
  e.prototype.onExecute = function() {
    var a = [];
    null != this.properties.colorA && a.push(hex2num(this.properties.colorA));
    null != this.properties.colorB && a.push(hex2num(this.properties.colorB));
    null != this.properties.colorC && a.push(hex2num(this.properties.colorC));
    null != this.properties.colorD && a.push(hex2num(this.properties.colorD));
    var c = this.getInputData(0);
    null == c && (c = 0.5);
    1.0 < c ? c = 1.0 : 0.0 > c && (c = 0.0);
    if (0 != a.length) {
      var d = [0, 0, 0];
      if (0 == c) {
        d = a[0];
      } else {
        if (1 == c) {
          d = a[a.length - 1];
        } else {
          var e = (a.length - 1) * c;
          c = a[Math.floor(e)];
          a = a[Math.floor(e) + 1];
          e -= Math.floor(e);
          d[0] = c[0] * (1 - e) + a[0] * e;
          d[1] = c[1] * (1 - e) + a[1] * e;
          d[2] = c[2] * (1 - e) + a[2] * e;
        }
      }
      for (var f in d) {
        d[f] /= 255;
      }
      this.boxcolor = colorToString(d);
      this.setOutputData(0, d);
    }
  };
  LiteGraph.registerNodeType("color/palette", e);
  f.title = "Frame";
  f.desc = "Frame viewerew";
  f.widgets = [{name:"resize", text:"Resize box", type:"button"}, {name:"view", text:"View Image", type:"button"}];
  f.prototype.onDrawBackground = function(a) {
    this.frame && a.drawImage(this.frame, 0, 0, this.size[0], this.size[1]);
  };
  f.prototype.onExecute = function() {
    this.frame = this.getInputData(0);
    this.setDirtyCanvas(!0);
  };
  f.prototype.onWidget = function(a, c) {
    "resize" == c.name && this.frame ? (a = this.frame.width, c = this.frame.height, a || null == this.frame.videoWidth || (a = this.frame.videoWidth, c = this.frame.videoHeight), a && c && (this.size = [a, c]), this.setDirtyCanvas(!0, !0)) : "view" == c.name && this.show();
  };
  f.prototype.show = function() {
    showElement && this.frame && showElement(this.frame);
  };
  LiteGraph.registerNodeType("graphics/frame", f);
  g.title = "Image fade";
  g.desc = "Fades between images";
  g.widgets = [{name:"resizeA", text:"Resize to A", type:"button"}, {name:"resizeB", text:"Resize to B", type:"button"}];
  g.prototype.onAdded = function() {
    this.createCanvas();
    var a = this.canvas.getContext("2d");
    a.fillStyle = "#000";
    a.fillRect(0, 0, this.properties.width, this.properties.height);
  };
  g.prototype.createCanvas = function() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.properties.width;
    this.canvas.height = this.properties.height;
  };
  g.prototype.onExecute = function() {
    var a = this.canvas.getContext("2d");
    this.canvas.width = this.canvas.width;
    var c = this.getInputData(0);
    null != c && a.drawImage(c, 0, 0, this.canvas.width, this.canvas.height);
    c = this.getInputData(2);
    null == c ? c = this.properties.fade : this.properties.fade = c;
    a.globalAlpha = c;
    c = this.getInputData(1);
    null != c && a.drawImage(c, 0, 0, this.canvas.width, this.canvas.height);
    a.globalAlpha = 1.0;
    this.setOutputData(0, this.canvas);
    this.setDirtyCanvas(!0);
  };
  LiteGraph.registerNodeType("graphics/imagefade", g);
  l.title = "Crop";
  l.desc = "Crop Image";
  l.prototype.onAdded = function() {
    this.createCanvas();
  };
  l.prototype.createCanvas = function() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.properties.width;
    this.canvas.height = this.properties.height;
  };
  l.prototype.onExecute = function() {
    var a = this.getInputData(0);
    a && (a.width ? (this.canvas.getContext("2d").drawImage(a, -this.properties.x, -this.properties.y, a.width * this.properties.scale, a.height * this.properties.scale), this.setOutputData(0, this.canvas)) : this.setOutputData(0, null));
  };
  l.prototype.onDrawBackground = function(a) {
    this.flags.collapsed || this.canvas && a.drawImage(this.canvas, 0, 0, this.canvas.width, this.canvas.height, 0, 0, this.size[0], this.size[1]);
  };
  l.prototype.onPropertyChanged = function(a, c) {
    this.properties[a] = c;
    "scale" == a ? (this.properties[a] = parseFloat(c), 0 == this.properties[a] && (this.trace("Error in scale"), this.properties[a] = 1.0)) : this.properties[a] = parseInt(c);
    this.createCanvas();
    return !0;
  };
  LiteGraph.registerNodeType("graphics/cropImage", l);
  k.title = "Video";
  k.desc = "Video playback";
  k.widgets = [{name:"play", text:"PLAY", type:"minibutton"}, {name:"stop", text:"STOP", type:"minibutton"}, {name:"demo", text:"Demo video", type:"button"}, {name:"mute", text:"Mute video", type:"button"}];
  k.prototype.onExecute = function() {
    if (this.properties.url && (this.properties.url != this._video_url && this.loadVideo(this.properties.url), this._video && 0 != this._video.width)) {
      var a = this.getInputData(0);
      a && 0 <= a && 1.0 >= a && (this._video.currentTime = a * this._video.duration, this._video.pause());
      this._video.dirty = !0;
      this.setOutputData(0, this._video);
      this.setOutputData(1, this._video.currentTime);
      this.setOutputData(2, this._video.duration);
      this.setDirtyCanvas(!0);
    }
  };
  k.prototype.onStart = function() {
    this.play();
  };
  k.prototype.onStop = function() {
    this.stop();
  };
  k.prototype.loadVideo = function(a) {
    this._video_url = a;
    this._video = document.createElement("video");
    this._video.src = a;
    this._video.type = "type=video/mp4";
    this._video.muted = !0;
    this._video.autoplay = !0;
    var b = this;
    this._video.addEventListener("loadedmetadata", function(a) {
      b.trace("Duration: " + this.duration + " seconds");
      b.trace("Size: " + this.videoWidth + "," + this.videoHeight);
      b.setDirtyCanvas(!0);
      this.width = this.videoWidth;
      this.height = this.videoHeight;
    });
    this._video.addEventListener("progress", function(a) {
    });
    this._video.addEventListener("error", function(a) {
      console.log("Error loading video: " + this.src);
      b.trace("Error loading video: " + this.src);
      if (this.error) {
        switch(this.error.code) {
          case this.error.MEDIA_ERR_ABORTED:
            b.trace("You stopped the video.");
            break;
          case this.error.MEDIA_ERR_NETWORK:
            b.trace("Network error - please try again later.");
            break;
          case this.error.MEDIA_ERR_DECODE:
            b.trace("Video is broken..");
            break;
          case this.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
            b.trace("Sorry, your browser can't play this video.");
        }
      }
    });
    this._video.addEventListener("ended", function(a) {
      b.trace("Ended.");
      this.play();
    });
  };
  k.prototype.onPropertyChanged = function(a, c) {
    this.properties[a] = c;
    "url" == a && "" != c && this.loadVideo(c);
    return !0;
  };
  k.prototype.play = function() {
    this._video && this._video.play();
  };
  k.prototype.playPause = function() {
    this._video && (this._video.paused ? this.play() : this.pause());
  };
  k.prototype.stop = function() {
    this._video && (this._video.pause(), this._video.currentTime = 0);
  };
  k.prototype.pause = function() {
    this._video && (this.trace("Video paused"), this._video.pause());
  };
  k.prototype.onWidget = function(a, c) {
  };
  LiteGraph.registerNodeType("graphics/video", k);
  a.title = "Webcam";
  a.desc = "Webcam image";
  a.prototype.openStream = function() {
    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
    window.URL = window.URL || window.webkitURL;
    if (navigator.getUserMedia) {
      this._waiting_confirmation = !0;
      navigator.getUserMedia({video:!0}, this.streamReady.bind(this), function(b) {
        console.log("Webcam rejected", b);
        a._webcam_stream = !1;
        a.box_color = "red";
      });
      var a = this;
    }
  };
  a.prototype.onRemoved = function() {
    this._webcam_stream && (this._webcam_stream.stop(), this._video = this._webcam_stream = null);
  };
  a.prototype.streamReady = function(a) {
    this._webcam_stream = a;
    var b = this._video;
    b || (b = document.createElement("video"), b.autoplay = !0, b.src = window.URL.createObjectURL(a), this._video = b, b.onloadedmetadata = function(a) {
      console.log(a);
    });
  };
  a.prototype.onExecute = function() {
    null != this._webcam_stream || this._waiting_confirmation || this.openStream();
    this._video && this._video.videoWidth && (this._video.width = this._video.videoWidth, this._video.height = this._video.videoHeight, this.setOutputData(0, this._video));
  };
  a.prototype.getExtraMenuOptions = function(a) {
    var b = this;
    return [{content:b.properties.show ? "Hide Frame" : "Show Frame", callback:function() {
      b.properties.show = !b.properties.show;
    }}];
  };
  a.prototype.onDrawBackground = function(a) {
    this.flags.collapsed || 20 >= this.size[1] || !this.properties.show || !this._video || (a.save(), a.drawImage(this._video, 0, 0, this.size[0], this.size[1]), a.restore());
  };
  LiteGraph.registerNodeType("graphics/webcam", a);
})();
var LGraphTexture;
if ("undefined" != typeof LiteGraph) {
  var LGraphCubemap = function() {
    this.addOutput("Cubemap", "Cubemap");
    this.properties = {name:""};
    this.size = [LGraphTexture.image_preview_size, LGraphTexture.image_preview_size];
  }, LGraphTextureMatte = function() {
    this.addInput("in", "Texture");
    this.addOutput("out", "Texture");
    this.properties = {key_color:vec3.fromValues(0., 1., 0.), threshold:0.8, slope:0.2, precision:LGraphTexture.DEFAULT};
    LGraphTextureMatte._shader || (LGraphTextureMatte._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureMatte.pixel_shader));
  }, LGraphTextureWebcam = function() {
    this.addOutput("Webcam", "Texture");
    this.properties = {texture_name:""};
  }, LGraphTextureKuwaharaFilter = function() {
    this.addInput("Texture", "Texture");
    this.addOutput("Filtered", "Texture");
    this.properties = {intensity:1, radius:5};
  }, LGraphTextureBlur = function() {
    this.addInput("Texture", "Texture");
    this.addInput("Iterations", "number");
    this.addInput("Intensity", "number");
    this.addOutput("Blurred", "Texture");
    this.properties = {intensity:1, iterations:1, preserve_aspect:!1, scale:[1, 1]};
  }, LGraphTextureDepthRange = function() {
    this.addInput("Texture", "Texture");
    this.addInput("Distance", "number");
    this.addInput("Range", "number");
    this.addOutput("Texture", "Texture");
    this.properties = {distance:100, range:50, high_precision:!1};
  }, LGraphTextureEdges = function() {
    this.addInput("Tex.", "Texture");
    this.addOutput("Edges", "Texture");
    this.properties = {invert:!0, factor:1, precision:LGraphTexture.DEFAULT};
    LGraphTextureEdges._shader || (LGraphTextureEdges._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, LGraphTextureEdges.pixel_shader));
  }, LGraphTextureMix = function() {
    this.addInput("A", "Texture");
    this.addInput("B", "Texture");
    this.addInput("Mixer", "Texture");
    this.addOutput("Texture", "Texture");
    this.properties = {precision:LGraphTexture.DEFAULT};
    LGraphTextureMix._shader || (LGraphTextureMix._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, LGraphTextureMix.pixel_shader));
  }, LGraphTextureGradient = function() {
    this.addInput("A", "color");
    this.addInput("B", "color");
    this.addOutput("Texture", "Texture");
    this.properties = {angle:0, scale:1, A:[0, 0, 0], B:[1, 1, 1], texture_size:32};
    LGraphTextureGradient._shader || (LGraphTextureGradient._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, LGraphTextureGradient.pixel_shader));
    this._uniforms = {u_angle:0, u_colorA:vec3.create(), u_colorB:vec3.create()};
  }, LGraphChannelsTexture = function() {
    this.addInput("R", "Texture");
    this.addInput("G", "Texture");
    this.addInput("B", "Texture");
    this.addInput("A", "Texture");
    this.addOutput("Texture", "Texture");
    this.properties = {};
    LGraphChannelsTexture._shader || (LGraphChannelsTexture._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, LGraphChannelsTexture.pixel_shader));
  }, LGraphTextureChannels = function() {
    this.addInput("Texture", "Texture");
    this.addOutput("R", "Texture");
    this.addOutput("G", "Texture");
    this.addOutput("B", "Texture");
    this.addOutput("A", "Texture");
    this.properties = {};
    LGraphTextureChannels._shader || (LGraphTextureChannels._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, LGraphTextureChannels.pixel_shader));
  }, LGraphTextureLUT = function() {
    this.addInput("Texture", "Texture");
    this.addInput("LUT", "Texture");
    this.addInput("Intensity", "number");
    this.addOutput("", "Texture");
    this.properties = {intensity:1, precision:LGraphTexture.DEFAULT, texture:null};
    LGraphTextureLUT._shader || (LGraphTextureLUT._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, LGraphTextureLUT.pixel_shader));
  }, LGraphImageToTexture = function() {
    this.addInput("Image", "image");
    this.addOutput("", "Texture");
    this.properties = {};
  }, LGraphTextureAverage = function() {
    this.addInput("Texture", "Texture");
    this.addOutput("", "Texture");
    this.properties = {mipmap_offset:0, low_precision:!1};
    this._uniforms = {u_texture:0, u_mipmap_offset:this.properties.mipmap_offset};
  }, LGraphTextureDownsample = function() {
    this.addInput("Texture", "Texture");
    this.addOutput("", "Texture");
    this.properties = {iterations:1, generate_mipmaps:!1, precision:LGraphTexture.DEFAULT};
  }, LGraphTextureCopy = function() {
    this.addInput("Texture", "Texture");
    this.addOutput("", "Texture");
    this.properties = {size:0, generate_mipmaps:!1, precision:LGraphTexture.DEFAULT};
  }, LGraphTextureToViewport = function() {
    this.addInput("Texture", "Texture");
    this.properties = {additive:!1, antialiasing:!1, filter:!0, disable_alpha:!1, gamma:1.0};
    this.size[0] = 130;
  }, LGraphTextureWarp = function() {
    this.addInput("in", "Texture");
    this.addInput("warp", "Texture");
    this.addInput("factor", "number");
    this.addOutput("out", "Texture");
    this.properties = {factor:0.01, precision:LGraphTexture.DEFAULT};
  }, LGraphTextureScaleOffset = function() {
    this.addInput("in", "Texture");
    this.addInput("scale", "vec2");
    this.addInput("offset", "vec2");
    this.addOutput("out", "Texture");
    this.properties = {offset:vec2.fromValues(0, 0), scale:vec2.fromValues(1, 1), precision:LGraphTexture.DEFAULT};
  }, LGraphTextureShader = function() {
    this.addOutput("Texture", "Texture");
    this.properties = {code:"", width:512, height:512};
    this.properties.code = "\nvoid main() {\n  vec2 uv = v_coord;\n  vec3 color = vec3(0.0);\n//your code here\n\ngl_FragColor = vec4(color, 1.0);\n}\n";
  }, LGraphTextureOperation = function() {
    this.addInput("Texture", "Texture");
    this.addInput("TextureB", "Texture");
    this.addInput("value", "number");
    this.addOutput("Texture", "Texture");
    this.help = "<p>pixelcode must be vec3</p>\r\n\t\t\t<p>uvcode must be vec2, is optional</p>\r\n\t\t\t<p><strong>uv:</strong> tex. coords</p><p><strong>color:</strong> texture</p><p><strong>colorB:</strong> textureB</p><p><strong>time:</strong> scene time</p><p><strong>value:</strong> input value</p>";
    this.properties = {value:1, uvcode:"", pixelcode:"color + colorB * value", precision:LGraphTexture.DEFAULT};
  }, LGraphTextureSave = function() {
    this.addInput("Texture", "Texture");
    this.addOutput("", "Texture");
    this.properties = {name:""};
  }, LGraphTexturePreview = function() {
    this.addInput("Texture", "Texture");
    this.properties = {flipY:!1};
    this.size = [LGraphTexture.image_preview_size, LGraphTexture.image_preview_size];
  };
  LGraphTexture = function() {
    this.addOutput("Texture", "Texture");
    this.properties = {name:"", filter:!0};
    this.size = [LGraphTexture.image_preview_size, LGraphTexture.image_preview_size];
  };
  LGraphTexture.title = "Texture";
  LGraphTexture.desc = "Texture";
  LGraphTexture.widgets_info = {name:{widget:"texture"}, filter:{widget:"checkbox"}};
  LGraphTexture.loadTextureCallback = null;
  LGraphTexture.image_preview_size = 256;
  LGraphTexture.PASS_THROUGH = 1;
  LGraphTexture.COPY = 2;
  LGraphTexture.LOW = 3;
  LGraphTexture.HIGH = 4;
  LGraphTexture.REUSE = 5;
  LGraphTexture.DEFAULT = 2;
  LGraphTexture.MODE_VALUES = {"pass through":LGraphTexture.PASS_THROUGH, copy:LGraphTexture.COPY, low:LGraphTexture.LOW, high:LGraphTexture.HIGH, reuse:LGraphTexture.REUSE, "default":LGraphTexture.DEFAULT};
  LGraphTexture.getTexturesContainer = function() {
    return gl.textures;
  };
  LGraphTexture.loadTexture = function(d, e) {
    e = e || {};
    var f = d;
    "http://" == f.substr(0, 7) && LiteGraph.proxy && (f = LiteGraph.proxy + f.substr(7));
    return LGraphTexture.getTexturesContainer()[d] = GL.Texture.fromURL(f, e);
  };
  LGraphTexture.getTexture = function(d) {
    var e = this.getTexturesContainer();
    if (!e) {
      throw "Cannot load texture, container of textures not found";
    }
    e = e[d];
    return !e && d && ":" != d[0] ? this.loadTexture(d) : e;
  };
  LGraphTexture.getTargetTexture = function(d, e, f) {
    if (!d) {
      throw "LGraphTexture.getTargetTexture expects a reference texture";
    }
    switch(f) {
      case LGraphTexture.LOW:
        f = gl.UNSIGNED_BYTE;
        break;
      case LGraphTexture.HIGH:
        f = gl.HIGH_PRECISION_FORMAT;
        break;
      case LGraphTexture.REUSE:
        return d;
      default:
        f = d ? d.type : gl.UNSIGNED_BYTE;
    }
    e && e.width == d.width && e.height == d.height && e.type == f || (e = new GL.Texture(d.width, d.height, {type:f, format:gl.RGBA, filter:gl.LINEAR}));
    return e;
  };
  LGraphTexture.getNoiseTexture = function() {
    if (this._noise_texture) {
      return this._noise_texture;
    }
    for (var d = new Uint8Array(1048576), e = 0; 1048576 > e; ++e) {
      d[e] = 255 * Math.random();
    }
    return this._noise_texture = d = GL.Texture.fromMemory(512, 512, d, {format:gl.RGBA, wrap:gl.REPEAT, filter:gl.NEAREST});
  };
  LGraphTexture.prototype.onDropFile = function(d, e, f) {
    d ? ("string" == typeof d ? d = GL.Texture.fromURL(d) : -1 != e.toLowerCase().indexOf(".dds") ? d = GL.Texture.fromDDSInMemory(d) : (d = new Blob([f]), d = URL.createObjectURL(d), d = GL.Texture.fromURL(d)), this._drop_texture = d, this.properties.name = e) : (this._drop_texture = null, this.properties.name = "");
  };
  LGraphTexture.prototype.getExtraMenuOptions = function(d) {
    var e = this;
    if (this._drop_texture) {
      return [{content:"Clear", callback:function() {
        e._drop_texture = null;
        e.properties.name = "";
      }}];
    }
  };
  LGraphTexture.prototype.onExecute = function() {
    var d = null;
    this.isOutputConnected(1) && (d = this.getInputData(0));
    !d && this._drop_texture && (d = this._drop_texture);
    !d && this.properties.name && (d = LGraphTexture.getTexture(this.properties.name));
    if (d) {
      this._last_tex = d;
      !1 === this.properties.filter ? d.setParameter(gl.TEXTURE_MAG_FILTER, gl.NEAREST) : d.setParameter(gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      this.setOutputData(0, d);
      for (var e = 1; e < this.outputs.length; e++) {
        var f = this.outputs[e];
        if (f) {
          var g = null;
          "width" == f.name ? g = d.width : "height" == f.name ? g = d.height : "aspect" == f.name && (g = d.width / d.height);
          this.setOutputData(e, g);
        }
      }
    }
  };
  LGraphTexture.prototype.onResourceRenamed = function(d, e) {
    this.properties.name == d && (this.properties.name = e);
  };
  LGraphTexture.prototype.onDrawBackground = function(d) {
    if (!(this.flags.collapsed || 20 >= this.size[1])) {
      if (this._drop_texture && d.webgl) {
        d.drawImage(this._drop_texture, 0, 0, this.size[0], this.size[1]);
      } else {
        if (this._last_preview_tex != this._last_tex) {
          if (d.webgl) {
            this._canvas = this._last_tex;
          } else {
            var e = LGraphTexture.generateLowResTexturePreview(this._last_tex);
            if (!e) {
              return;
            }
            this._last_preview_tex = this._last_tex;
            this._canvas = cloneCanvas(e);
          }
        }
        this._canvas && (d.save(), d.webgl || (d.translate(0, this.size[1]), d.scale(1, -1)), d.drawImage(this._canvas, 0, 0, this.size[0], this.size[1]), d.restore());
      }
    }
  };
  LGraphTexture.generateLowResTexturePreview = function(d) {
    if (!d) {
      return null;
    }
    var e = LGraphTexture.image_preview_size, f = d;
    if (d.format == gl.DEPTH_COMPONENT) {
      return null;
    }
    if (d.width > e || d.height > e) {
      f = this._preview_temp_tex, this._preview_temp_tex || (this._preview_temp_tex = f = new GL.Texture(e, e, {minFilter:gl.NEAREST})), d.copyTo(f);
    }
    d = this._preview_canvas;
    d || (this._preview_canvas = d = createCanvas(e, e));
    f && f.toCanvas(d);
    return d;
  };
  LGraphTexture.prototype.getResources = function(d) {
    d[this.properties.name] = GL.Texture;
    return d;
  };
  LGraphTexture.prototype.onGetInputs = function() {
    return [["in", "Texture"]];
  };
  LGraphTexture.prototype.onGetOutputs = function() {
    return [["width", "number"], ["height", "number"], ["aspect", "number"]];
  };
  LiteGraph.registerNodeType("texture/texture", LGraphTexture);
  LGraphTexturePreview.title = "Preview";
  LGraphTexturePreview.desc = "Show a texture in the graph canvas";
  LGraphTexturePreview.allow_preview = !1;
  LGraphTexturePreview.prototype.onDrawBackground = function(d) {
    if (!this.flags.collapsed && (d.webgl || LGraphTexturePreview.allow_preview)) {
      var e = this.getInputData(0);
      e && (e = !e.handle && d.webgl ? e : LGraphTexture.generateLowResTexturePreview(e), d.save(), this.properties.flipY && (d.translate(0, this.size[1]), d.scale(1, -1)), d.drawImage(e, 0, 0, this.size[0], this.size[1]), d.restore());
    }
  };
  LiteGraph.registerNodeType("texture/preview", LGraphTexturePreview);
  LGraphTextureSave.title = "Save";
  LGraphTextureSave.desc = "Save a texture in the repository";
  LGraphTextureSave.prototype.onExecute = function() {
    var d = this.getInputData(0);
    d && (this.properties.name && (LGraphTexture.storeTexture ? LGraphTexture.storeTexture(this.properties.name, d) : LGraphTexture.getTexturesContainer()[this.properties.name] = d), this.setOutputData(0, d));
  };
  LiteGraph.registerNodeType("texture/save", LGraphTextureSave);
  LGraphTextureOperation.widgets_info = {uvcode:{widget:"textarea", height:100}, pixelcode:{widget:"textarea", height:100}, precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
  LGraphTextureOperation.title = "Operation";
  LGraphTextureOperation.desc = "Texture shader operation";
  LGraphTextureOperation.prototype.getExtraMenuOptions = function(d) {
    var e = this;
    return [{content:e.properties.show ? "Hide Texture" : "Show Texture", callback:function() {
      e.properties.show = !e.properties.show;
    }}];
  };
  LGraphTextureOperation.prototype.onDrawBackground = function(d) {
    this.flags.collapsed || 20 >= this.size[1] || !this.properties.show || !this._tex || this._tex.gl != d || (d.save(), d.drawImage(this._tex, 0, 0, this.size[0], this.size[1]), d.restore());
  };
  LGraphTextureOperation.prototype.onExecute = function() {
    var d = this.getInputData(0);
    if (this.isOutputConnected(0)) {
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, d);
      } else {
        var e = this.getInputData(1);
        if (this.properties.uvcode || this.properties.pixelcode) {
          var f = 512, g = 512;
          d ? (f = d.width, g = d.height) : e && (f = e.width, g = e.height);
          this._tex = d || this._tex ? LGraphTexture.getTargetTexture(d || this._tex, this._tex, this.properties.precision) : new GL.Texture(f, g, {type:this.precision === LGraphTexture.LOW ? gl.UNSIGNED_BYTE : gl.HIGH_PRECISION_FORMAT, format:gl.RGBA, filter:gl.LINEAR});
          var l = "";
          this.properties.uvcode && (l = "uv = " + this.properties.uvcode, -1 != this.properties.uvcode.indexOf(";") && (l = this.properties.uvcode));
          var k = "";
          this.properties.pixelcode && (k = "result = " + this.properties.pixelcode, -1 != this.properties.pixelcode.indexOf(";") && (k = this.properties.pixelcode));
          var a = this._shader;
          if (!a || this._shader_code != l + "|" + k) {
            try {
              this._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, LGraphTextureOperation.pixel_shader, {UV_CODE:l, PIXEL_CODE:k}), this.boxcolor = "#00FF00";
            } catch (h) {
              console.log("Error compiling shader: ", h);
              this.boxcolor = "#FF0000";
              return;
            }
            this.boxcolor = "#FF0000";
            this._shader_code = l + "|" + k;
            a = this._shader;
          }
          if (a) {
            this.boxcolor = "green";
            var b = this.getInputData(2);
            null != b ? this.properties.value = b : b = parseFloat(this.properties.value);
            var c = this.graph.getTime();
            this._tex.drawTo(function() {
              gl.disable(gl.DEPTH_TEST);
              gl.disable(gl.CULL_FACE);
              gl.disable(gl.BLEND);
              d && d.bind(0);
              e && e.bind(1);
              var h = Mesh.getScreenQuad();
              a.uniforms({u_texture:0, u_textureB:1, value:b, texSize:[f, g], time:c}).draw(h);
            });
            this.setOutputData(0, this._tex);
          } else {
            this.boxcolor = "red";
          }
        }
      }
    }
  };
  LGraphTextureOperation.pixel_shader = "precision highp float;\n\r\n\t\t\t\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_textureB;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform vec2 texSize;\n\r\n\t\t\tuniform float time;\n\r\n\t\t\tuniform float value;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 uv = v_coord;\n\r\n\t\t\t\tUV_CODE;\n\r\n\t\t\t\tvec4 color4 = texture2D(u_texture, uv);\n\r\n\t\t\t\tvec3 color = color4.rgb;\n\r\n\t\t\t\tvec4 color4B = texture2D(u_textureB, uv);\n\r\n\t\t\t\tvec3 colorB = color4B.rgb;\n\r\n\t\t\t\tvec3 result = color;\n\r\n\t\t\t\tfloat alpha = 1.0;\n\r\n\t\t\t\tPIXEL_CODE;\n\r\n\t\t\t\tgl_FragColor = vec4(result, alpha);\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("texture/operation", LGraphTextureOperation);
  LGraphTextureShader.title = "Shader";
  LGraphTextureShader.desc = "Texture shader";
  LGraphTextureShader.widgets_info = {code:{type:"code"}, precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
  LGraphTextureShader.prototype.onPropertyChanged = function(d, e) {
    if ("code" == d && (d = this.getShader())) {
      e = d.uniformInfo;
      if (this.inputs) {
        for (var f = {}, g = 0; g < this.inputs.length; ++g) {
          var l = this.getInputInfo(g);
          l && (e[l.name] && !f[l.name] ? f[l.name] = !0 : (this.removeInput(g), g--));
        }
      }
      for (g in e) {
        if (l = d.uniformInfo[g], null !== l.loc && "time" != g) {
          if (this._shader.samplers[g]) {
            e = "texture";
          } else {
            switch(l.size) {
              case 1:
                e = "number";
                break;
              case 2:
                e = "vec2";
                break;
              case 3:
                e = "vec3";
                break;
              case 4:
                e = "vec4";
                break;
              case 9:
                e = "mat3";
                break;
              case 16:
                e = "mat4";
                break;
              default:
                continue;
            }
          }
          f = this.findInputSlot(g);
          if (-1 != f && (l = this.getInputInfo(f))) {
            if (l.type == e) {
              continue;
            }
            this.removeInput(f, e);
          }
          this.addInput(g, e);
        }
      }
    }
  };
  LGraphTextureShader.prototype.getShader = function() {
    if (this._shader && this._shader_code == this.properties.code) {
      return this._shader;
    }
    this._shader_code = this.properties.code;
    this._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, LGraphTextureShader.pixel_shader + this.properties.code), this.boxcolor = "green";
    return this._shader;
  };
  LGraphTextureShader.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var d = this.getShader();
      if (d) {
        for (var e = 0; e < this.inputs.length; ++e) {
          var f = this.getInputInfo(e), g = this.getInputData(e);
          null != g && (g.constructor === GL.Texture && (g.bind(slot), g = slot, slot++), d.setUniform(f.name, g));
        }
        this._tex && this._tex.width == this.properties.width && this._tex.height == this.properties.height || (this._tex = new GL.Texture(this.properties.width, this.properties.height, {format:gl.RGBA, filter:gl.LINEAR}));
        var l = this._tex, k = this.graph.getTime();
        l.drawTo(function() {
          d.uniforms({texSize:[l.width, l.height], time:k}).draw(Mesh.getScreenQuad());
        });
        this.setOutputData(0, this._tex);
      }
    }
  };
  LGraphTextureShader.pixel_shader = "precision highp float;\n\r\n\t\t\t\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform float time;\n\r\n\t\t\t";
  LiteGraph.registerNodeType("texture/shader", LGraphTextureShader);
  LGraphTextureScaleOffset.widgets_info = {precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
  LGraphTextureScaleOffset.title = "Scale/Offset";
  LGraphTextureScaleOffset.desc = "Applies an scaling and offseting";
  LGraphTextureScaleOffset.prototype.onExecute = function() {
    var d = this.getInputData(0);
    if (this.isOutputConnected(0) && d) {
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, d);
      } else {
        var e = d.width, f = d.height, g = this.precision === LGraphTexture.LOW ? gl.UNSIGNED_BYTE : gl.HIGH_PRECISION_FORMAT;
        this.precision === LGraphTexture.DEFAULT && (g = d.type);
        this._tex && this._tex.width == e && this._tex.height == f && this._tex.type == g || (this._tex = new GL.Texture(e, f, {type:g, format:gl.RGBA, filter:gl.LINEAR}));
        var l = this._shader;
        l || (l = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureScaleOffset.pixel_shader));
        var k = this.getInputData(1);
        k ? (this.properties.scale[0] = k[0], this.properties.scale[1] = k[1]) : k = this.properties.scale;
        var a = this.getInputData(2);
        a ? (this.properties.offset[0] = a[0], this.properties.offset[1] = a[1]) : a = this.properties.offset;
        this._tex.drawTo(function() {
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.CULL_FACE);
          gl.disable(gl.BLEND);
          d.bind(0);
          var b = Mesh.getScreenQuad();
          l.uniforms({u_texture:0, u_scale:k, u_offset:a}).draw(b);
        });
        this.setOutputData(0, this._tex);
      }
    }
  };
  LGraphTextureScaleOffset.pixel_shader = "precision highp float;\n\r\n\t\t\t\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_textureB;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform vec2 u_scale;\n\r\n\t\t\tuniform vec2 u_offset;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 uv = v_coord;\n\r\n\t\t\t\tuv = uv / u_scale - u_offset;\n\r\n\t\t\t\tgl_FragColor = texture2D(u_texture, uv);\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("texture/scaleOffset", LGraphTextureScaleOffset);
  LGraphTextureWarp.widgets_info = {precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
  LGraphTextureWarp.title = "Warp";
  LGraphTextureWarp.desc = "Texture warp operation";
  LGraphTextureWarp.prototype.onExecute = function() {
    var d = this.getInputData(0);
    if (this.isOutputConnected(0)) {
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, d);
      } else {
        var e = this.getInputData(1), f = 512, g = 512;
        d ? (f = d.width, g = d.height) : e && (f = e.width, g = e.height);
        this._tex = d || this._tex ? LGraphTexture.getTargetTexture(d || this._tex, this._tex, this.properties.precision) : new GL.Texture(f, g, {type:this.precision === LGraphTexture.LOW ? gl.UNSIGNED_BYTE : gl.HIGH_PRECISION_FORMAT, format:gl.RGBA, filter:gl.LINEAR});
        var l = this._shader;
        l || (l = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureWarp.pixel_shader));
        var k = this.getInputData(2);
        null != k ? this.properties.factor = k : k = parseFloat(this.properties.factor);
        this._tex.drawTo(function() {
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.CULL_FACE);
          gl.disable(gl.BLEND);
          d && d.bind(0);
          e && e.bind(1);
          var a = Mesh.getScreenQuad();
          l.uniforms({u_texture:0, u_textureB:1, u_factor:k}).draw(a);
        });
        this.setOutputData(0, this._tex);
      }
    }
  };
  LGraphTextureWarp.pixel_shader = "precision highp float;\n\r\n\t\t\t\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_textureB;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform float u_factor;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 uv = v_coord;\n\r\n\t\t\t\tuv += ( texture2D(u_textureB, uv).rg - vec2(0.5)) * u_factor;\n\r\n\t\t\t\tgl_FragColor = texture2D(u_texture, uv);\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("texture/warp", LGraphTextureWarp);
  LGraphTextureToViewport.title = "to Viewport";
  LGraphTextureToViewport.desc = "Texture to viewport";
  LGraphTextureToViewport.prototype.onExecute = function() {
    var d = this.getInputData(0);
    if (d) {
      this.properties.disable_alpha ? gl.disable(gl.BLEND) : (gl.enable(gl.BLEND), this.properties.additive ? gl.blendFunc(gl.SRC_ALPHA, gl.ONE) : gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA));
      gl.disable(gl.DEPTH_TEST);
      var e = this.properties.gamma || 1.0;
      this.isInputConnected(1) && (e = this.getInputData(1));
      d.setParameter(gl.TEXTURE_MAG_FILTER, this.properties.filter ? gl.LINEAR : gl.NEAREST);
      if (this.properties.antialiasing) {
        LGraphTextureToViewport._shader || (LGraphTextureToViewport._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureToViewport.aa_pixel_shader));
        gl.getViewport();
        var f = Mesh.getScreenQuad();
        d.bind(0);
        LGraphTextureToViewport._shader.uniforms({u_texture:0, uViewportSize:[d.width, d.height], u_igamma:1 / e, inverseVP:[1 / d.width, 1 / d.height]}).draw(f);
      } else {
        1.0 != e ? (LGraphTextureToViewport._gamma_shader || (LGraphTextureToViewport._gamma_shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, LGraphTextureToViewport.gamma_pixel_shader)), d.toViewport(LGraphTextureToViewport._gamma_shader, {u_texture:0, u_igamma:1 / e})) : d.toViewport();
      }
    }
  };
  LGraphTextureToViewport.prototype.onGetInputs = function() {
    return [["gamma", "number"]];
  };
  LGraphTextureToViewport.aa_pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 uViewportSize;\n\r\n\t\t\tuniform vec2 inverseVP;\n\r\n\t\t\tuniform float u_igamma;\n\r\n\t\t\t#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n\r\n\t\t\t#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n\r\n\t\t\t#define FXAA_SPAN_MAX     8.0\n\r\n\t\t\t\n\r\n\t\t\t/* from mitsuhiko/webgl-meincraft based on the code on geeks3d.com */\n\r\n\t\t\tvec4 applyFXAA(sampler2D tex, vec2 fragCoord)\n\r\n\t\t\t{\n\r\n\t\t\t\tvec4 color = vec4(0.0);\n\r\n\t\t\t\t/*vec2 inverseVP = vec2(1.0 / uViewportSize.x, 1.0 / uViewportSize.y);*/\n\r\n\t\t\t\tvec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * inverseVP).xyz;\n\r\n\t\t\t\tvec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * inverseVP).xyz;\n\r\n\t\t\t\tvec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * inverseVP).xyz;\n\r\n\t\t\t\tvec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * inverseVP).xyz;\n\r\n\t\t\t\tvec3 rgbM  = texture2D(tex, fragCoord  * inverseVP).xyz;\n\r\n\t\t\t\tvec3 luma = vec3(0.299, 0.587, 0.114);\n\r\n\t\t\t\tfloat lumaNW = dot(rgbNW, luma);\n\r\n\t\t\t\tfloat lumaNE = dot(rgbNE, luma);\n\r\n\t\t\t\tfloat lumaSW = dot(rgbSW, luma);\n\r\n\t\t\t\tfloat lumaSE = dot(rgbSE, luma);\n\r\n\t\t\t\tfloat lumaM  = dot(rgbM,  luma);\n\r\n\t\t\t\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\r\n\t\t\t\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\r\n\t\t\t\t\n\r\n\t\t\t\tvec2 dir;\n\r\n\t\t\t\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\r\n\t\t\t\tdir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\r\n\t\t\t\t\n\r\n\t\t\t\tfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\r\n\t\t\t\t\n\r\n\t\t\t\tfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\r\n\t\t\t\tdir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * inverseVP;\n\r\n\t\t\t\t\n\r\n\t\t\t\tvec3 rgbA = 0.5 * (texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz + \n\r\n\t\t\t\t\ttexture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n\r\n\t\t\t\tvec3 rgbB = rgbA * 0.5 + 0.25 * (texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz + \n\r\n\t\t\t\t\ttexture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\r\n\t\t\t\t\n\r\n\t\t\t\t//return vec4(rgbA,1.0);\n\r\n\t\t\t\tfloat lumaB = dot(rgbB, luma);\n\r\n\t\t\t\tif ((lumaB < lumaMin) || (lumaB > lumaMax))\n\r\n\t\t\t\t\tcolor = vec4(rgbA, 1.0);\n\r\n\t\t\t\telse\n\r\n\t\t\t\t\tcolor = vec4(rgbB, 1.0);\n\r\n\t\t\t\tif(u_igamma != 1.0)\n\r\n\t\t\t\t\tcolor.xyz = pow( color.xyz, vec3(u_igamma) );\n\r\n\t\t\t\treturn color;\n\r\n\t\t\t}\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t   gl_FragColor = applyFXAA( u_texture, v_coord * uViewportSize) ;\n\r\n\t\t\t}\n\r\n\t\t\t";
  LGraphTextureToViewport.gamma_pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform float u_igamma;\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D( u_texture, v_coord);\n\r\n\t\t\t\tcolor.xyz = pow(color.xyz, vec3(u_igamma) );\n\r\n\t\t\t   gl_FragColor = color;\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("texture/toviewport", LGraphTextureToViewport);
  LGraphTextureCopy.title = "Copy";
  LGraphTextureCopy.desc = "Copy Texture";
  LGraphTextureCopy.widgets_info = {size:{widget:"combo", values:[0, 32, 64, 128, 256, 512, 1024, 2048]}, precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
  LGraphTextureCopy.prototype.onExecute = function() {
    var d = this.getInputData(0);
    if ((d || this._temp_texture) && this.isOutputConnected(0)) {
      if (d) {
        var e = d.width, f = d.height;
        0 != this.properties.size && (f = e = this.properties.size);
        var g = this._temp_texture, l = d.type;
        this.properties.precision === LGraphTexture.LOW ? l = gl.UNSIGNED_BYTE : this.properties.precision === LGraphTexture.HIGH && (l = gl.HIGH_PRECISION_FORMAT);
        g && g.width == e && g.height == f && g.type == l || (g = gl.LINEAR, this.properties.generate_mipmaps && isPowerOfTwo(e) && isPowerOfTwo(f) && (g = gl.LINEAR_MIPMAP_LINEAR), this._temp_texture = new GL.Texture(e, f, {type:l, format:gl.RGBA, minFilter:g, magFilter:gl.LINEAR}));
        d.copyTo(this._temp_texture);
        this.properties.generate_mipmaps && (this._temp_texture.bind(0), gl.generateMipmap(this._temp_texture.texture_type), this._temp_texture.unbind(0));
      }
      this.setOutputData(0, this._temp_texture);
    }
  };
  LiteGraph.registerNodeType("texture/copy", LGraphTextureCopy);
  LGraphTextureDownsample.title = "Downsample";
  LGraphTextureDownsample.desc = "Downsample Texture";
  LGraphTextureDownsample.widgets_info = {iterations:{type:"number", step:1, precision:0, min:1}, precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
  LGraphTextureDownsample.prototype.onExecute = function() {
    var d = this.getInputData(0);
    if ((d || this._temp_texture) && this.isOutputConnected(0) && d && d.texture_type === GL.TEXTURE_2D) {
      var e = LGraphTextureDownsample._shader;
      e || (LGraphTextureDownsample._shader = e = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureDownsample.pixel_shader));
      var f = d.width | 0, g = d.height | 0, l = d.type;
      this.properties.precision === LGraphTexture.LOW ? l = gl.UNSIGNED_BYTE : this.properties.precision === LGraphTexture.HIGH && (l = gl.HIGH_PRECISION_FORMAT);
      var k = this.properties.iterations || 1, a = d, b = [];
      l = {type:l, format:d.format};
      var c = vec2.create(), h = {u_offset:c};
      this._texture && GL.Texture.releaseTemporary(this._texture);
      for (var n = 0; n < k; ++n) {
        c[0] = 1 / f;
        c[1] = 1 / g;
        f = f >> 1 || 0;
        g = g >> 1 || 0;
        d = GL.Texture.getTemporary(f, g, l);
        b.push(d);
        a.setParameter(GL.TEXTURE_MAG_FILTER, GL.NEAREST);
        a.copyTo(d, e, h);
        if (1 == f && 1 == g) {
          break;
        }
        a = d;
      }
      this._texture = b.pop();
      for (n = 0; n < b.length; ++n) {
        GL.Texture.releaseTemporary(b[n]);
      }
      this.properties.generate_mipmaps && (this._texture.bind(0), gl.generateMipmap(this._texture.texture_type), this._texture.unbind(0));
      this.setOutputData(0, this._texture);
    }
  };
  LGraphTextureDownsample.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_offset;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord );\n\r\n\t\t\t\tcolor += texture2D(u_texture, v_coord + vec2( u_offset.x, 0.0 ) );\n\r\n\t\t\t\tcolor += texture2D(u_texture, v_coord + vec2( 0.0, u_offset.y ) );\n\r\n\t\t\t\tcolor += texture2D(u_texture, v_coord + vec2( u_offset.x, u_offset.y ) );\n\r\n\t\t\t   gl_FragColor = color * 0.25;\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("texture/downsample", LGraphTextureDownsample);
  LGraphTextureAverage.title = "Average";
  LGraphTextureAverage.desc = "Compute a partial average (32 random samples) of a texture and stores it as a 1x1 pixel texture";
  LGraphTextureAverage.prototype.onExecute = function() {
    var d = this.getInputData(0);
    if (d && this.isOutputConnected(0)) {
      if (!LGraphTextureAverage._shader) {
        LGraphTextureAverage._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureAverage.pixel_shader);
        for (var e = new Float32Array(32), f = 0; 32 > f; ++f) {
          e[f] = Math.random();
        }
        LGraphTextureAverage._shader.uniforms({u_samples_a:e.subarray(0, 16), u_samples_b:e.subarray(16, 32)});
      }
      e = this._temp_texture;
      f = this.properties.low_precision ? gl.UNSIGNED_BYTE : d.type;
      e && e.type == f || (this._temp_texture = new GL.Texture(1, 1, {type:f, format:gl.RGBA, filter:gl.NEAREST}));
      var g = LGraphTextureAverage._shader, l = this._uniforms;
      l.u_mipmap_offset = this.properties.mipmap_offset;
      this._temp_texture.drawTo(function() {
        d.toViewport(g, l);
      });
      this.setOutputData(0, this._temp_texture);
    }
  };
  LGraphTextureAverage.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tuniform mat4 u_samples_a;\n\r\n\t\t\tuniform mat4 u_samples_b;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform float u_mipmap_offset;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = vec4(0.0);\n\r\n\t\t\t\tfor(int i = 0; i < 4; ++i)\n\r\n\t\t\t\t\tfor(int j = 0; j < 4; ++j)\n\r\n\t\t\t\t\t{\n\r\n\t\t\t\t\t\tcolor += texture2D(u_texture, vec2( u_samples_a[i][j], u_samples_b[i][j] ), u_mipmap_offset );\n\r\n\t\t\t\t\t\tcolor += texture2D(u_texture, vec2( 1.0 - u_samples_a[i][j], 1.0 - u_samples_b[i][j] ), u_mipmap_offset );\n\r\n\t\t\t\t\t}\n\r\n\t\t\t   gl_FragColor = color * 0.03125;\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("texture/average", LGraphTextureAverage);
  LGraphImageToTexture.title = "Image to Texture";
  LGraphImageToTexture.desc = "Uploads an image to the GPU";
  LGraphImageToTexture.prototype.onExecute = function() {
    var d = this.getInputData(0);
    if (d) {
      var e = d.videoWidth || d.width, f = d.videoHeight || d.height;
      if (d.gltexture) {
        this.setOutputData(0, d.gltexture);
      } else {
        var g = this._temp_texture;
        g && g.width == e && g.height == f || (this._temp_texture = new GL.Texture(e, f, {format:gl.RGBA, filter:gl.LINEAR}));
        try {
          this._temp_texture.uploadImage(d);
        } catch (l) {
          console.error("image comes from an unsafe location, cannot be uploaded to webgl");
          return;
        }
        this.setOutputData(0, this._temp_texture);
      }
    }
  };
  LiteGraph.registerNodeType("texture/imageToTexture", LGraphImageToTexture);
  LGraphTextureLUT.widgets_info = {precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
  LGraphTextureLUT.title = "LUT";
  LGraphTextureLUT.desc = "Apply LUT to Texture";
  LGraphTextureLUT.widgets_info = {texture:{widget:"texture"}};
  LGraphTextureLUT.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var d = this.getInputData(0);
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, d);
      } else {
        if (d) {
          var e = this.getInputData(1);
          e || (e = LGraphTexture.getTexture(this.properties.texture));
          if (e) {
            e.bind(0);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
            var f = this.properties.intensity;
            this.isInputConnected(2) && (this.properties.intensity = f = this.getInputData(2));
            this._tex = LGraphTexture.getTargetTexture(d, this._tex, this.properties.precision);
            this._tex.drawTo(function() {
              e.bind(1);
              d.toViewport(LGraphTextureLUT._shader, {u_texture:0, u_textureB:1, u_amount:f});
            });
            this.setOutputData(0, this._tex);
          } else {
            this.setOutputData(0, d);
          }
        }
      }
    }
  };
  LGraphTextureLUT.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_textureB;\n\r\n\t\t\tuniform float u_amount;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\t lowp vec4 textureColor = clamp( texture2D(u_texture, v_coord), vec4(0.0), vec4(1.0) );\n\r\n\t\t\t\t mediump float blueColor = textureColor.b * 63.0;\n\r\n\t\t\t\t mediump vec2 quad1;\n\r\n\t\t\t\t quad1.y = floor(floor(blueColor) / 8.0);\n\r\n\t\t\t\t quad1.x = floor(blueColor) - (quad1.y * 8.0);\n\r\n\t\t\t\t mediump vec2 quad2;\n\r\n\t\t\t\t quad2.y = floor(ceil(blueColor) / 8.0);\n\r\n\t\t\t\t quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n\r\n\t\t\t\t highp vec2 texPos1;\n\r\n\t\t\t\t texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\r\n\t\t\t\t texPos1.y = 1.0 - ((quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\n\r\n\t\t\t\t highp vec2 texPos2;\n\r\n\t\t\t\t texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\r\n\t\t\t\t texPos2.y = 1.0 - ((quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\n\r\n\t\t\t\t lowp vec4 newColor1 = texture2D(u_textureB, texPos1);\n\r\n\t\t\t\t lowp vec4 newColor2 = texture2D(u_textureB, texPos2);\n\r\n\t\t\t\t lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n\r\n\t\t\t\t gl_FragColor = vec4( mix( textureColor.rgb, newColor.rgb, u_amount), textureColor.w);\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("texture/LUT", LGraphTextureLUT);
  LGraphTextureChannels.title = "Texture to Channels";
  LGraphTextureChannels.desc = "Split texture channels";
  LGraphTextureChannels.prototype.onExecute = function() {
    var d = this.getInputData(0);
    if (d) {
      this._channels || (this._channels = Array(4));
      for (var e = 0, f = 0; 4 > f; f++) {
        this.isOutputConnected(f) ? (this._channels[f] && this._channels[f].width == d.width && this._channels[f].height == d.height && this._channels[f].type == d.type || (this._channels[f] = new GL.Texture(d.width, d.height, {type:d.type, format:gl.RGBA, filter:gl.LINEAR})), e++) : this._channels[f] = null;
      }
      if (e) {
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        var g = Mesh.getScreenQuad(), l = LGraphTextureChannels._shader, k = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
        for (f = 0; 4 > f; f++) {
          this._channels[f] && (this._channels[f].drawTo(function() {
            d.bind(0);
            l.uniforms({u_texture:0, u_mask:k[f]}).draw(g);
          }), this.setOutputData(f, this._channels[f]));
        }
      }
    }
  };
  LGraphTextureChannels.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec4 u_mask;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t   gl_FragColor = vec4( vec3( length( texture2D(u_texture, v_coord) * u_mask )), 1.0 );\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("texture/textureChannels", LGraphTextureChannels);
  LGraphChannelsTexture.title = "Channels to Texture";
  LGraphChannelsTexture.desc = "Split texture channels";
  LGraphChannelsTexture.prototype.onExecute = function() {
    var d = [this.getInputData(0), this.getInputData(1), this.getInputData(2), this.getInputData(3)];
    if (d[0] && d[1] && d[2] && d[3]) {
      gl.disable(gl.BLEND);
      gl.disable(gl.DEPTH_TEST);
      var e = Mesh.getScreenQuad(), f = LGraphChannelsTexture._shader;
      this._tex = LGraphTexture.getTargetTexture(d[0], this._tex);
      this._tex.drawTo(function() {
        d[0].bind(0);
        d[1].bind(1);
        d[2].bind(2);
        d[3].bind(3);
        f.uniforms({u_textureR:0, u_textureG:1, u_textureB:2, u_textureA:3}).draw(e);
      });
      this.setOutputData(0, this._tex);
    }
  };
  LGraphChannelsTexture.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_textureR;\n\r\n\t\t\tuniform sampler2D u_textureG;\n\r\n\t\t\tuniform sampler2D u_textureB;\n\r\n\t\t\tuniform sampler2D u_textureA;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t   gl_FragColor = vec4( \r\n\t\t\t\t\t\ttexture2D(u_textureR, v_coord).r,\r\n\t\t\t\t\t\ttexture2D(u_textureG, v_coord).r,\r\n\t\t\t\t\t\ttexture2D(u_textureB, v_coord).r,\r\n\t\t\t\t\t\ttexture2D(u_textureA, v_coord).r);\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("texture/channelsTexture", LGraphChannelsTexture);
  LGraphTextureGradient.title = "Gradient";
  LGraphTextureGradient.desc = "Generates a gradient";
  LGraphTextureGradient["@A"] = {type:"color"};
  LGraphTextureGradient["@B"] = {type:"color"};
  LGraphTextureGradient["@texture_size"] = {type:"enum", values:[32, 64, 128, 256, 512]};
  LGraphTextureGradient.prototype.onExecute = function() {
    gl.disable(gl.BLEND);
    gl.disable(gl.DEPTH_TEST);
    var d = GL.Mesh.getScreenQuad(), e = LGraphTextureGradient._shader, f = this.getInputData(0);
    f || (f = this.properties.A);
    var g = this.getInputData(1);
    g || (g = this.properties.B);
    for (var l = 2; l < this.inputs.length; l++) {
      var k = this.inputs[l], a = this.getInputData(l);
      void 0 !== a && (this.properties[k.name] = a);
    }
    var b = this._uniforms;
    this._uniforms.u_angle = this.properties.angle * DEG2RAD;
    this._uniforms.u_scale = this.properties.scale;
    vec3.copy(b.u_colorA, f);
    vec3.copy(b.u_colorB, g);
    f = parseInt(this.properties.texture_size);
    this._tex && this._tex.width == f || (this._tex = new GL.Texture(f, f, {format:gl.RGB, filter:gl.LINEAR}));
    this._tex.drawTo(function() {
      e.uniforms(b).draw(d);
    });
    this.setOutputData(0, this._tex);
  };
  LGraphTextureGradient.prototype.onGetInputs = function() {
    return [["angle", "number"], ["scale", "number"]];
  };
  LGraphTextureGradient.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform float u_angle;\n\r\n\t\t\tuniform float u_scale;\n\r\n\t\t\tuniform vec3 u_colorA;\n\r\n\t\t\tuniform vec3 u_colorB;\n\r\n\t\t\t\n\r\n\t\t\tvec2 rotate(vec2 v, float angle)\n\r\n\t\t\t{\n\r\n\t\t\t\tvec2 result;\n\r\n\t\t\t\tfloat _cos = cos(angle);\n\r\n\t\t\t\tfloat _sin = sin(angle);\n\r\n\t\t\t\tresult.x = v.x * _cos - v.y * _sin;\n\r\n\t\t\t\tresult.y = v.x * _sin + v.y * _cos;\n\r\n\t\t\t\treturn result;\n\r\n\t\t\t}\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tfloat f = (rotate(u_scale * (v_coord - vec2(0.5)), u_angle) + vec2(0.5)).x;\n\r\n\t\t\t\tvec3 color = mix(u_colorA,u_colorB,clamp(f,0.0,1.0));\n\r\n\t\t\t   gl_FragColor = vec4(color,1.0);\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("texture/gradient", LGraphTextureGradient);
  LGraphTextureMix.title = "Mix";
  LGraphTextureMix.desc = "Generates a texture mixing two textures";
  LGraphTextureMix.widgets_info = {precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
  LGraphTextureMix.prototype.onExecute = function() {
    var d = this.getInputData(0);
    if (this.isOutputConnected(0)) {
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, d);
      } else {
        var e = this.getInputData(1), f = this.getInputData(2);
        if (d && e && f) {
          this._tex = LGraphTexture.getTargetTexture(d, this._tex, this.properties.precision);
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          var g = Mesh.getScreenQuad(), l = LGraphTextureMix._shader;
          this._tex.drawTo(function() {
            d.bind(0);
            e.bind(1);
            f.bind(2);
            l.uniforms({u_textureA:0, u_textureB:1, u_textureMix:2}).draw(g);
          });
          this.setOutputData(0, this._tex);
        }
      }
    }
  };
  LGraphTextureMix.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_textureA;\n\r\n\t\t\tuniform sampler2D u_textureB;\n\r\n\t\t\tuniform sampler2D u_textureMix;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t   gl_FragColor = mix( texture2D(u_textureA, v_coord), texture2D(u_textureB, v_coord), texture2D(u_textureMix, v_coord) );\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("texture/mix", LGraphTextureMix);
  LGraphTextureEdges.title = "Edges";
  LGraphTextureEdges.desc = "Detects edges";
  LGraphTextureEdges.widgets_info = {precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
  LGraphTextureEdges.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var d = this.getInputData(0);
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, d);
      } else {
        if (d) {
          this._tex = LGraphTexture.getTargetTexture(d, this._tex, this.properties.precision);
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          var e = Mesh.getScreenQuad(), f = LGraphTextureEdges._shader, g = this.properties.invert, l = this.properties.factor;
          this._tex.drawTo(function() {
            d.bind(0);
            f.uniforms({u_texture:0, u_isize:[1 / d.width, 1 / d.height], u_factor:l, u_invert:g ? 1 : 0}).draw(e);
          });
          this.setOutputData(0, this._tex);
        }
      }
    }
  };
  LGraphTextureEdges.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_isize;\n\r\n\t\t\tuniform int u_invert;\n\r\n\t\t\tuniform float u_factor;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 center = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tvec4 up = texture2D(u_texture, v_coord + u_isize * vec2(0.0,1.0) );\n\r\n\t\t\t\tvec4 down = texture2D(u_texture, v_coord + u_isize * vec2(0.0,-1.0) );\n\r\n\t\t\t\tvec4 left = texture2D(u_texture, v_coord + u_isize * vec2(1.0,0.0) );\n\r\n\t\t\t\tvec4 right = texture2D(u_texture, v_coord + u_isize * vec2(-1.0,0.0) );\n\r\n\t\t\t\tvec4 diff = abs(center - up) + abs(center - down) + abs(center - left) + abs(center - right);\n\r\n\t\t\t\tdiff *= u_factor;\n\r\n\t\t\t\tif(u_invert == 1)\n\r\n\t\t\t\t\tdiff.xyz = vec3(1.0) - diff.xyz;\n\r\n\t\t\t   gl_FragColor = vec4( diff.xyz, center.a );\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("texture/edges", LGraphTextureEdges);
  LGraphTextureDepthRange.title = "Depth Range";
  LGraphTextureDepthRange.desc = "Generates a texture with a depth range";
  LGraphTextureDepthRange.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var d = this.getInputData(0);
      if (d) {
        var e = gl.UNSIGNED_BYTE;
        this.properties.high_precision && (e = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT);
        this._temp_texture && this._temp_texture.type == e && this._temp_texture.width == d.width && this._temp_texture.height == d.height || (this._temp_texture = new GL.Texture(d.width, d.height, {type:e, format:gl.RGBA, filter:gl.LINEAR}));
        var f = this.properties.distance;
        this.isInputConnected(1) && (f = this.getInputData(1), this.properties.distance = f);
        var g = this.properties.range;
        this.isInputConnected(2) && (g = this.getInputData(2), this.properties.range = g);
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        var l = Mesh.getScreenQuad();
        LGraphTextureDepthRange._shader || (LGraphTextureDepthRange._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, LGraphTextureDepthRange.pixel_shader));
        var k = LGraphTextureDepthRange._shader, a = [LS.Renderer._current_camera.near, LS.Renderer._current_camera.far];
        this._temp_texture.drawTo(function() {
          d.bind(0);
          k.uniforms({u_texture:0, u_distance:f, u_range:g, u_camera_planes:a}).draw(l);
        });
        this.setOutputData(0, this._temp_texture);
      }
    }
  };
  LGraphTextureDepthRange.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform float u_distance;\n\r\n\t\t\tuniform float u_range;\n\r\n\t\t\t\n\r\n\t\t\tfloat LinearDepth()\n\r\n\t\t\t{\n\r\n\t\t\t\tfloat n = u_camera_planes.x;\n\r\n\t\t\t\tfloat f = u_camera_planes.y;\n\r\n\t\t\t\treturn (2.0 * n) / (f + n - texture2D(u_texture, v_coord).x * (f - n));\n\r\n\t\t\t}\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tfloat diff = abs(LinearDepth() * u_camera_planes.y - u_distance);\n\r\n\t\t\t\tfloat dof = 1.0;\n\r\n\t\t\t\tif(diff <= u_range)\n\r\n\t\t\t\t\tdof = diff / u_range;\n\r\n\t\t\t   gl_FragColor = vec4(dof);\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("texture/depth_range", LGraphTextureDepthRange);
  LGraphTextureBlur.title = "Blur";
  LGraphTextureBlur.desc = "Blur a texture";
  LGraphTextureBlur.max_iterations = 20;
  LGraphTextureBlur.prototype.onExecute = function() {
    var d = this.getInputData(0);
    if (d && this.isOutputConnected(0)) {
      var e = this._temp_texture;
      e && e.width == d.width && e.height == d.height && e.type == d.type || (this._temp_texture = new GL.Texture(d.width, d.height, {type:d.type, format:gl.RGBA, filter:gl.LINEAR}), this._final_texture = new GL.Texture(d.width, d.height, {type:d.type, format:gl.RGBA, filter:gl.LINEAR}));
      e = this.properties.iterations;
      this.isInputConnected(1) && (e = this.getInputData(1), this.properties.iterations = e);
      e = Math.min(Math.floor(e), LGraphTextureBlur.max_iterations);
      if (0 == e) {
        this.setOutputData(0, d);
      } else {
        var f = this.properties.intensity;
        this.isInputConnected(2) && (f = this.getInputData(2), this.properties.intensity = f);
        var g = LiteGraph.camera_aspect;
        g || void 0 === window.gl || (g = gl.canvas.height / gl.canvas.width);
        g || (g = 1);
        g = this.properties.preserve_aspect ? g : 1;
        for (var l = this.properties.scale || [1, 1], k = 0; k < e; ++k) {
          d.applyBlur(g * l[0] * k, l[1] * k, f, this._temp_texture, this._final_texture), d = this._final_texture;
        }
        this.setOutputData(0, this._final_texture);
      }
    }
  };
  LGraphTextureBlur.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_offset;\n\r\n\t\t\tuniform float u_intensity;\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t   vec4 sum = vec4(0.0);\n\r\n\t\t\t   vec4 center = texture2D(u_texture, v_coord);\n\r\n\t\t\t   sum += texture2D(u_texture, v_coord + u_offset * -4.0) * 0.05/0.98;\n\r\n\t\t\t   sum += texture2D(u_texture, v_coord + u_offset * -3.0) * 0.09/0.98;\n\r\n\t\t\t   sum += texture2D(u_texture, v_coord + u_offset * -2.0) * 0.12/0.98;\n\r\n\t\t\t   sum += texture2D(u_texture, v_coord + u_offset * -1.0) * 0.15/0.98;\n\r\n\t\t\t   sum += center * 0.16/0.98;\n\r\n\t\t\t   sum += texture2D(u_texture, v_coord + u_offset * 4.0) * 0.05/0.98;\n\r\n\t\t\t   sum += texture2D(u_texture, v_coord + u_offset * 3.0) * 0.09/0.98;\n\r\n\t\t\t   sum += texture2D(u_texture, v_coord + u_offset * 2.0) * 0.12/0.98;\n\r\n\t\t\t   sum += texture2D(u_texture, v_coord + u_offset * 1.0) * 0.15/0.98;\n\r\n\t\t\t   gl_FragColor = u_intensity * sum;\n\r\n\t\t\t   /*gl_FragColor.a = center.a*/;\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("texture/blur", LGraphTextureBlur);
  LGraphTextureKuwaharaFilter.title = "Kuwahara Filter";
  LGraphTextureKuwaharaFilter.desc = "Filters a texture giving an artistic oil canvas painting";
  LGraphTextureKuwaharaFilter.max_radius = 10;
  LGraphTextureKuwaharaFilter._shaders = [];
  LGraphTextureKuwaharaFilter.prototype.onExecute = function() {
    var d = this.getInputData(0);
    if (d && this.isOutputConnected(0)) {
      var e = this._temp_texture;
      e && e.width == d.width && e.height == d.height && e.type == d.type || (this._temp_texture = new GL.Texture(d.width, d.height, {type:d.type, format:gl.RGBA, filter:gl.LINEAR}));
      e = this.properties.radius;
      e = Math.min(Math.floor(e), LGraphTextureKuwaharaFilter.max_radius);
      if (0 == e) {
        this.setOutputData(0, d);
      } else {
        var f = this.properties.intensity, g = LiteGraph.camera_aspect;
        g || void 0 === window.gl || (g = gl.canvas.height / gl.canvas.width);
        g || (g = 1);
        g = this.properties.preserve_aspect ? g : 1;
        LGraphTextureKuwaharaFilter._shaders[e] || (LGraphTextureKuwaharaFilter._shaders[e] = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, LGraphTextureKuwaharaFilter.pixel_shader, {RADIUS:e.toFixed(0)}));
        var l = LGraphTextureKuwaharaFilter._shaders[e], k = GL.Mesh.getScreenQuad();
        d.bind(0);
        this._temp_texture.drawTo(function() {
          l.uniforms({u_texture:0, u_intensity:f, u_resolution:[d.width, d.height], u_iResolution:[1 / d.width, 1 / d.height]}).draw(k);
        });
        this.setOutputData(0, this._temp_texture);
      }
    }
  };
  LGraphTextureKuwaharaFilter.pixel_shader = "\n\r\n\tprecision highp float;\n\r\n\tvarying vec2 v_coord;\n\r\n\tuniform sampler2D u_texture;\n\r\n\tuniform float u_intensity;\n\r\n\tuniform vec2 u_resolution;\n\r\n\tuniform vec2 u_iResolution;\n\r\n\t#ifndef RADIUS\n\r\n\t\t#define RADIUS 7\n\r\n\t#endif\n\r\n\tvoid main() {\n\r\n\t\n\r\n\t\tconst int radius = RADIUS;\n\r\n\t\tvec2 fragCoord = v_coord;\n\r\n\t\tvec2 src_size = u_iResolution;\n\r\n\t\tvec2 uv = v_coord;\n\r\n\t\tfloat n = float((radius + 1) * (radius + 1));\n\r\n\t\tint i;\n\r\n\t\tint j;\n\r\n\t\tvec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n\r\n\t\tvec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n\r\n\t\tvec3 c;\n\r\n\t\t\n\r\n\t\tfor (int j = -radius; j <= 0; ++j)  {\n\r\n\t\t\tfor (int i = -radius; i <= 0; ++i)  {\n\r\n\t\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\r\n\t\t\t\tm0 += c;\n\r\n\t\t\t\ts0 += c * c;\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tfor (int j = -radius; j <= 0; ++j)  {\n\r\n\t\t\tfor (int i = 0; i <= radius; ++i)  {\n\r\n\t\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\r\n\t\t\t\tm1 += c;\n\r\n\t\t\t\ts1 += c * c;\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tfor (int j = 0; j <= radius; ++j)  {\n\r\n\t\t\tfor (int i = 0; i <= radius; ++i)  {\n\r\n\t\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\r\n\t\t\t\tm2 += c;\n\r\n\t\t\t\ts2 += c * c;\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tfor (int j = 0; j <= radius; ++j)  {\n\r\n\t\t\tfor (int i = -radius; i <= 0; ++i)  {\n\r\n\t\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\r\n\t\t\t\tm3 += c;\n\r\n\t\t\t\ts3 += c * c;\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tfloat min_sigma2 = 1e+2;\n\r\n\t\tm0 /= n;\n\r\n\t\ts0 = abs(s0 / n - m0 * m0);\n\r\n\t\t\n\r\n\t\tfloat sigma2 = s0.r + s0.g + s0.b;\n\r\n\t\tif (sigma2 < min_sigma2) {\n\r\n\t\t\tmin_sigma2 = sigma2;\n\r\n\t\t\tgl_FragColor = vec4(m0, 1.0);\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tm1 /= n;\n\r\n\t\ts1 = abs(s1 / n - m1 * m1);\n\r\n\t\t\n\r\n\t\tsigma2 = s1.r + s1.g + s1.b;\n\r\n\t\tif (sigma2 < min_sigma2) {\n\r\n\t\t\tmin_sigma2 = sigma2;\n\r\n\t\t\tgl_FragColor = vec4(m1, 1.0);\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tm2 /= n;\n\r\n\t\ts2 = abs(s2 / n - m2 * m2);\n\r\n\t\t\n\r\n\t\tsigma2 = s2.r + s2.g + s2.b;\n\r\n\t\tif (sigma2 < min_sigma2) {\n\r\n\t\t\tmin_sigma2 = sigma2;\n\r\n\t\t\tgl_FragColor = vec4(m2, 1.0);\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tm3 /= n;\n\r\n\t\ts3 = abs(s3 / n - m3 * m3);\n\r\n\t\t\n\r\n\t\tsigma2 = s3.r + s3.g + s3.b;\n\r\n\t\tif (sigma2 < min_sigma2) {\n\r\n\t\t\tmin_sigma2 = sigma2;\n\r\n\t\t\tgl_FragColor = vec4(m3, 1.0);\n\r\n\t\t}\n\r\n\t}\n\r\n\t";
  LiteGraph.registerNodeType("texture/kuwahara", LGraphTextureKuwaharaFilter);
  LGraphTextureWebcam.title = "Webcam";
  LGraphTextureWebcam.desc = "Webcam texture";
  LGraphTextureWebcam.prototype.openStream = function() {
    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
    window.URL = window.URL || window.webkitURL;
    if (navigator.getUserMedia) {
      this._waiting_confirmation = !0;
      var d = this;
      navigator.getUserMedia({video:!0}, this.streamReady.bind(this), function(e) {
        console.log("Webcam rejected", e);
        d._webcam_stream = !1;
        d.box_color = "red";
      });
    }
  };
  LGraphTextureWebcam.prototype.streamReady = function(d) {
    this._webcam_stream = d;
    var e = this._video;
    e || (e = document.createElement("video"), e.autoplay = !0, e.src = window.URL.createObjectURL(d), this._video = e, e.onloadedmetadata = function(d) {
      console.log(d);
    });
  };
  LGraphTextureWebcam.prototype.onRemoved = function() {
    this._webcam_stream && (this._webcam_stream.stop(), this._video = this._webcam_stream = null);
  };
  LGraphTextureWebcam.prototype.onDrawBackground = function(d) {
    this.flags.collapsed || 20 >= this.size[1] || !this._video || (d.save(), d.webgl ? this._temp_texture && d.drawImage(this._temp_texture, 0, 0, this.size[0], this.size[1]) : (d.translate(0, this.size[1]), d.scale(1, -1), d.drawImage(this._video, 0, 0, this.size[0], this.size[1])), d.restore());
  };
  LGraphTextureWebcam.prototype.onExecute = function() {
    null != this._webcam_stream || this._waiting_confirmation || this.openStream();
    if (this._video && this._video.videoWidth) {
      var d = this._video.videoWidth, e = this._video.videoHeight, f = this._temp_texture;
      f && f.width == d && f.height == e || (this._temp_texture = new GL.Texture(d, e, {format:gl.RGB, filter:gl.LINEAR}));
      this._temp_texture.uploadImage(this._video);
      this.properties.texture_name && (LGraphTexture.getTexturesContainer()[this.properties.texture_name] = this._temp_texture);
      this.setOutputData(0, this._temp_texture);
    }
  };
  LiteGraph.registerNodeType("texture/webcam", LGraphTextureWebcam);
  LGraphTextureMatte.title = "Matte";
  LGraphTextureMatte.desc = "Extracts background";
  LGraphTextureMatte.widgets_info = {key_color:{widget:"color"}, precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
  LGraphTextureMatte.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var d = this.getInputData(0);
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, d);
      } else {
        if (d) {
          this._tex = LGraphTexture.getTargetTexture(d, this._tex, this.properties.precision);
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          this._uniforms || (this._uniforms = {u_texture:0, u_key_color:this.properties.key_color, u_threshold:1, u_slope:1});
          var e = this._uniforms, f = Mesh.getScreenQuad(), g = LGraphTextureMatte._shader;
          e.u_key_color = this.properties.key_color;
          e.u_threshold = this.properties.threshold;
          e.u_slope = this.properties.slope;
          this._tex.drawTo(function() {
            d.bind(0);
            g.uniforms(e).draw(f);
          });
          this.setOutputData(0, this._tex);
        }
      }
    }
  };
  LGraphTextureMatte.pixel_shader = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec3 u_key_color;\n\r\n\t\t\tuniform float u_threshold;\n\r\n\t\t\tuniform float u_slope;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec3 color = texture2D( u_texture, v_coord ).xyz;\n\r\n\t\t\t\tfloat diff = length( normalize(color) - normalize(u_key_color) );\n\r\n\t\t\t\tfloat edge = u_threshold * (1.0 - u_slope);\n\r\n\t\t\t\tfloat alpha = smoothstep( edge, u_threshold, diff);\n\r\n\t\t\t\tgl_FragColor = vec4( color, alpha );\n\r\n\t\t\t}";
  LiteGraph.registerNodeType("texture/matte", LGraphTextureMatte);
  LGraphCubemap.title = "Cubemap";
  LGraphCubemap.prototype.onDropFile = function(d, e, f) {
    d ? (this._drop_texture = "string" == typeof d ? GL.Texture.fromURL(d) : GL.Texture.fromDDSInMemory(d), this.properties.name = e) : (this._drop_texture = null, this.properties.name = "");
  };
  LGraphCubemap.prototype.onExecute = function() {
    if (this._drop_texture) {
      this.setOutputData(0, this._drop_texture);
    } else {
      if (this.properties.name) {
        var d = LGraphTexture.getTexture(this.properties.name);
        d && (this._last_tex = d, this.setOutputData(0, d));
      }
    }
  };
  LGraphCubemap.prototype.onDrawBackground = function(d) {
    this.flags.collapsed || 20 >= this.size[1] || !d.webgl || gl.meshes.cube || (gl.meshes.cube = GL.Mesh.cube({size:1}));
  };
  LiteGraph.registerNodeType("texture/cubemap", LGraphCubemap);
}
;if ("undefined" != typeof LiteGraph) {
  var LGraphFXVigneting = function() {
    this.addInput("Tex.", "Texture");
    this.addInput("intensity", "number");
    this.addOutput("Texture", "Texture");
    this.properties = {intensity:1, invert:!1, precision:LGraphTexture.DEFAULT};
    LGraphFXVigneting._shader || (LGraphFXVigneting._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, LGraphFXVigneting.pixel_shader));
  }, LGraphFXGeneric = function() {
    this.addInput("Texture", "Texture");
    this.addInput("value1", "number");
    this.addInput("value2", "number");
    this.addOutput("Texture", "Texture");
    this.properties = {fx:"halftone", value1:1, value2:1, precision:LGraphTexture.DEFAULT};
  }, LGraphFXBokeh = function() {
    this.addInput("Texture", "Texture");
    this.addInput("Blurred", "Texture");
    this.addInput("Mask", "Texture");
    this.addInput("Threshold", "number");
    this.addOutput("Texture", "Texture");
    this.properties = {shape:"", size:10, alpha:1.0, threshold:1.0, high_precision:!1};
  }, LGraphFXLens = function() {
    this.addInput("Texture", "Texture");
    this.addInput("Aberration", "number");
    this.addInput("Distortion", "number");
    this.addInput("Blur", "number");
    this.addOutput("Texture", "Texture");
    this.properties = {aberration:1.0, distortion:1.0, blur:1.0, precision:LGraphTexture.DEFAULT};
    LGraphFXLens._shader || (LGraphFXLens._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, LGraphFXLens.pixel_shader));
  };
  LGraphFXLens.title = "Lens";
  LGraphFXLens.desc = "Camera Lens distortion";
  LGraphFXLens.widgets_info = {precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
  LGraphFXLens.prototype.onExecute = function() {
    var d = this.getInputData(0);
    if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
      this.setOutputData(0, d);
    } else {
      if (d) {
        this._tex = LGraphTexture.getTargetTexture(d, this._tex, this.properties.precision);
        var e = this.properties.aberration;
        this.isInputConnected(1) && (e = this.getInputData(1), this.properties.aberration = e);
        var f = this.properties.distortion;
        this.isInputConnected(2) && (f = this.getInputData(2), this.properties.distortion = f);
        var g = this.properties.blur;
        this.isInputConnected(3) && (g = this.getInputData(3), this.properties.blur = g);
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        var l = Mesh.getScreenQuad(), k = LGraphFXLens._shader;
        this._tex.drawTo(function() {
          d.bind(0);
          k.uniforms({u_texture:0, u_aberration:e, u_distortion:f, u_blur:g}).draw(l);
        });
        this.setOutputData(0, this._tex);
      }
    }
  };
  LGraphFXLens.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform float u_aberration;\n\r\n\t\t\tuniform float u_distortion;\n\r\n\t\t\tuniform float u_blur;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 coord = v_coord;\n\r\n\t\t\t\tfloat dist = distance(vec2(0.5), coord);\n\r\n\t\t\t\tvec2 dist_coord = coord - vec2(0.5);\n\r\n\t\t\t\tfloat percent = 1.0 + ((0.5 - dist) / 0.5) * u_distortion;\n\r\n\t\t\t\tdist_coord *= percent;\n\r\n\t\t\t\tcoord = dist_coord + vec2(0.5);\n\r\n\t\t\t\tvec4 color = texture2D(u_texture,coord, u_blur * dist);\n\r\n\t\t\t\tcolor.r = texture2D(u_texture,vec2(0.5) + dist_coord * (1.0+0.01*u_aberration), u_blur * dist ).r;\n\r\n\t\t\t\tcolor.b = texture2D(u_texture,vec2(0.5) + dist_coord * (1.0-0.01*u_aberration), u_blur * dist ).b;\n\r\n\t\t\t\tgl_FragColor = color;\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("fx/lens", LGraphFXLens);
  window.LGraphFXLens = LGraphFXLens;
  LGraphFXBokeh.title = "Bokeh";
  LGraphFXBokeh.desc = "applies an Bokeh effect";
  LGraphFXBokeh.widgets_info = {shape:{widget:"texture"}};
  LGraphFXBokeh.prototype.onExecute = function() {
    var d = this.getInputData(0), e = this.getInputData(1), f = this.getInputData(2);
    if (d && f && this.properties.shape) {
      e || (e = d);
      var g = LGraphTexture.getTexture(this.properties.shape);
      if (g) {
        var l = this.properties.threshold;
        this.isInputConnected(3) && (l = this.getInputData(3), this.properties.threshold = l);
        var k = gl.UNSIGNED_BYTE;
        this.properties.high_precision && (k = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT);
        this._temp_texture && this._temp_texture.type == k && this._temp_texture.width == d.width && this._temp_texture.height == d.height || (this._temp_texture = new GL.Texture(d.width, d.height, {type:k, format:gl.RGBA, filter:gl.LINEAR}));
        var a = LGraphFXBokeh._first_shader;
        a || (a = LGraphFXBokeh._first_shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, LGraphFXBokeh._first_pixel_shader));
        var b = LGraphFXBokeh._second_shader;
        b || (b = LGraphFXBokeh._second_shader = new GL.Shader(LGraphFXBokeh._second_vertex_shader, LGraphFXBokeh._second_pixel_shader));
        var c = this._points_mesh;
        c && c._width == d.width && c._height == d.height && 2 == c._spacing || (c = this.createPointsMesh(d.width, d.height, 2));
        var h = Mesh.getScreenQuad(), n = this.properties.size, v = this.properties.alpha;
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
        this._temp_texture.drawTo(function() {
          d.bind(0);
          e.bind(1);
          f.bind(2);
          a.uniforms({u_texture:0, u_texture_blur:1, u_mask:2, u_texsize:[d.width, d.height]}).draw(h);
        });
        this._temp_texture.drawTo(function() {
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.ONE, gl.ONE);
          d.bind(0);
          g.bind(3);
          b.uniforms({u_texture:0, u_mask:2, u_shape:3, u_alpha:v, u_threshold:l, u_pointSize:n, u_itexsize:[1.0 / d.width, 1.0 / d.height]}).draw(c, gl.POINTS);
        });
        this.setOutputData(0, this._temp_texture);
      }
    } else {
      this.setOutputData(0, d);
    }
  };
  LGraphFXBokeh.prototype.createPointsMesh = function(d, e, f) {
    for (var g = Math.round(d / f), l = Math.round(e / f), k = new Float32Array(g * l * 2), a = -1, b = 2 / d * f, c = 2 / e * f, h = 0; h < l; ++h) {
      for (var n = -1, v = 0; v < g; ++v) {
        var u = h * g * 2 + 2 * v;
        k[u] = n;
        k[u + 1] = a;
        n += b;
      }
      a += c;
    }
    this._points_mesh = GL.Mesh.load({vertices2D:k});
    this._points_mesh._width = d;
    this._points_mesh._height = e;
    this._points_mesh._spacing = f;
    return this._points_mesh;
  };
  LGraphFXBokeh._first_pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_texture_blur;\n\r\n\t\t\tuniform sampler2D u_mask;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tvec4 blurred_color = texture2D(u_texture_blur, v_coord);\n\r\n\t\t\t\tfloat mask = texture2D(u_mask, v_coord).x;\n\r\n\t\t\t   gl_FragColor = mix(color, blurred_color, mask);\n\r\n\t\t\t}\n\r\n\t\t\t";
  LGraphFXBokeh._second_vertex_shader = "precision highp float;\n\r\n\t\t\tattribute vec2 a_vertex2D;\n\r\n\t\t\tvarying vec4 v_color;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_mask;\n\r\n\t\t\tuniform vec2 u_itexsize;\n\r\n\t\t\tuniform float u_pointSize;\n\r\n\t\t\tuniform float u_threshold;\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 coord = a_vertex2D * 0.5 + 0.5;\n\r\n\t\t\t\tv_color = texture2D( u_texture, coord );\n\r\n\t\t\t\tv_color += texture2D( u_texture, coord + vec2(u_itexsize.x, 0.0) );\n\r\n\t\t\t\tv_color += texture2D( u_texture, coord + vec2(0.0, u_itexsize.y));\n\r\n\t\t\t\tv_color += texture2D( u_texture, coord + u_itexsize);\n\r\n\t\t\t\tv_color *= 0.25;\n\r\n\t\t\t\tfloat mask = texture2D(u_mask, coord).x;\n\r\n\t\t\t\tfloat luminance = length(v_color) * mask;\n\r\n\t\t\t\t/*luminance /= (u_pointSize*u_pointSize)*0.01 */;\n\r\n\t\t\t\tluminance -= u_threshold;\n\r\n\t\t\t\tif(luminance < 0.0)\n\r\n\t\t\t\t{\n\r\n\t\t\t\t\tgl_Position.x = -100.0;\n\r\n\t\t\t\t\treturn;\n\r\n\t\t\t\t}\n\r\n\t\t\t\tgl_PointSize = u_pointSize;\n\r\n\t\t\t\tgl_Position = vec4(a_vertex2D,0.0,1.0);\n\r\n\t\t\t}\n\r\n\t\t\t";
  LGraphFXBokeh._second_pixel_shader = "precision highp float;\n\r\n\t\t\tvarying vec4 v_color;\n\r\n\t\t\tuniform sampler2D u_shape;\n\r\n\t\t\tuniform float u_alpha;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D( u_shape, gl_PointCoord );\n\r\n\t\t\t\tcolor *= v_color * u_alpha;\n\r\n\t\t\t\tgl_FragColor = color;\n\r\n\t\t\t}\n";
  LiteGraph.registerNodeType("fx/bokeh", LGraphFXBokeh);
  window.LGraphFXBokeh = LGraphFXBokeh;
  LGraphFXGeneric.title = "FX";
  LGraphFXGeneric.desc = "applies an FX from a list";
  LGraphFXGeneric.widgets_info = {fx:{widget:"combo", values:["halftone", "pixelate", "lowpalette", "noise", "gamma"]}, precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
  LGraphFXGeneric.shaders = {};
  LGraphFXGeneric.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var d = this.getInputData(0);
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, d);
      } else {
        if (d) {
          this._tex = LGraphTexture.getTargetTexture(d, this._tex, this.properties.precision);
          var e = this.properties.value1;
          this.isInputConnected(1) && (e = this.getInputData(1), this.properties.value1 = e);
          var f = this.properties.value2;
          this.isInputConnected(2) && (f = this.getInputData(2), this.properties.value2 = f);
          var g = this.properties.fx, l = LGraphFXGeneric.shaders[g];
          if (!l) {
            var k = LGraphFXGeneric["pixel_shader_" + g];
            if (!k) {
              return;
            }
            l = LGraphFXGeneric.shaders[g] = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, k);
          }
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          var a = Mesh.getScreenQuad();
          camera_planes = window.LS && LS.Renderer._current_camera ? [LS.Renderer._current_camera.near, LS.Renderer._current_camera.far] : [1, 100];
          var b = null;
          "noise" == g && (b = LGraphTexture.getNoiseTexture());
          this._tex.drawTo(function() {
            d.bind(0);
            "noise" == g && b.bind(1);
            l.uniforms({u_texture:0, u_noise:1, u_size:[d.width, d.height], u_rand:[Math.random(), Math.random()], u_value1:e, u_value2:f, u_camera_planes:camera_planes}).draw(a);
          });
          this.setOutputData(0, this._tex);
        }
      }
    }
  };
  LGraphFXGeneric.pixel_shader_halftone = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\t\n\r\n\t\t\tfloat pattern() {\n\r\n\t\t\t\tfloat s = sin(u_value1 * 3.1415), c = cos(u_value1 * 3.1415);\n\r\n\t\t\t\tvec2 tex = v_coord * u_size.xy;\n\r\n\t\t\t\tvec2 point = vec2(\n\r\n\t\t\t\t   c * tex.x - s * tex.y ,\n\r\n\t\t\t\t   s * tex.x + c * tex.y \n\r\n\t\t\t\t) * u_value2;\n\r\n\t\t\t\treturn (sin(point.x) * sin(point.y)) * 4.0;\n\r\n\t\t\t}\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tfloat average = (color.r + color.g + color.b) / 3.0;\n\r\n\t\t\t\tgl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n\r\n\t\t\t}\n";
  LGraphFXGeneric.pixel_shader_pixelate = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 coord = vec2( floor(v_coord.x * u_value1) / u_value1, floor(v_coord.y * u_value2) / u_value2 );\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, coord);\n\r\n\t\t\t\tgl_FragColor = color;\n\r\n\t\t\t}\n";
  LGraphFXGeneric.pixel_shader_lowpalette = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tgl_FragColor = floor(color * u_value1) / u_value1;\n\r\n\t\t\t}\n";
  LGraphFXGeneric.pixel_shader_noise = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_noise;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\tuniform vec2 u_rand;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tvec3 noise = texture2D(u_noise, v_coord * vec2(u_size.x / 512.0, u_size.y / 512.0) + u_rand).xyz - vec3(0.5);\n\r\n\t\t\t\tgl_FragColor = vec4( color.xyz + noise * u_value1, color.a );\n\r\n\t\t\t}\n";
  LGraphFXGeneric.pixel_shader_gamma = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tfloat gamma = 1.0 / u_value1;\n\r\n\t\t\t\tgl_FragColor = vec4( pow( color.xyz, vec3(gamma) ), color.a );\n\r\n\t\t\t}\n";
  LiteGraph.registerNodeType("fx/generic", LGraphFXGeneric);
  window.LGraphFXGeneric = LGraphFXGeneric;
  LGraphFXVigneting.title = "Vigneting";
  LGraphFXVigneting.desc = "Vigneting";
  LGraphFXVigneting.widgets_info = {precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
  LGraphFXVigneting.prototype.onExecute = function() {
    var d = this.getInputData(0);
    if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
      this.setOutputData(0, d);
    } else {
      if (d) {
        this._tex = LGraphTexture.getTargetTexture(d, this._tex, this.properties.precision);
        var e = this.properties.intensity;
        this.isInputConnected(1) && (e = this.getInputData(1), this.properties.intensity = e);
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        var f = Mesh.getScreenQuad(), g = LGraphFXVigneting._shader, l = this.properties.invert;
        this._tex.drawTo(function() {
          d.bind(0);
          g.uniforms({u_texture:0, u_intensity:e, u_isize:[1 / d.width, 1 / d.height], u_invert:l ? 1 : 0}).draw(f);
        });
        this.setOutputData(0, this._tex);
      }
    }
  };
  LGraphFXVigneting.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform float u_intensity;\n\r\n\t\t\tuniform int u_invert;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tfloat luminance = 1.0 - length( v_coord - vec2(0.5) ) * 1.414;\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tif(u_invert == 1)\n\r\n\t\t\t\t\tluminance = 1.0 - luminance;\n\r\n\t\t\t\tluminance = mix(1.0, luminance, u_intensity);\n\r\n\t\t\t   gl_FragColor = vec4( luminance * color.xyz, color.a);\n\r\n\t\t\t}\n\r\n\t\t\t";
  LiteGraph.registerNodeType("fx/vigneting", LGraphFXVigneting);
  window.LGraphFXVigneting = LGraphFXVigneting;
}
;(function(d) {
  function e(a) {
    this.cmd = this.channel = 0;
    a ? this.setup(a) : this.data = [0, 0, 0];
  }
  function f(a, b) {
    navigator.requestMIDIAccess ? (this.on_ready = a, this.state = {note:[], cc:[]}, navigator.requestMIDIAccess().then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this))) : (this.error = "not suppoorted", b ? b("Not supported") : console.error("MIDI NOT SUPPORTED, enable by chrome://flags"));
  }
  function g() {
    this.addOutput("on_midi", LiteGraph.EVENT);
    this.addOutput("out", "midi");
    this.properties = {port:0};
    this._current_midi_event = this._last_midi_event = null;
    var a = this;
    new f(function(b) {
      a._midi = b;
      if (a._waiting) {
        a.onStart();
      }
      a._waiting = !1;
    });
  }
  function l() {
    this.addInput("send", LiteGraph.EVENT);
    this.properties = {port:0};
    var a = this;
    new f(function(b) {
      a._midi = b;
    });
  }
  function k() {
    this.addInput("on_midi", LiteGraph.EVENT);
    this._str = "";
    this.size = [200, 40];
  }
  function a() {
    this.properties = {channel:-1, cmd:-1, min_value:-1, max_value:-1};
    this.addInput("in", LiteGraph.EVENT);
    this.addOutput("on_midi", LiteGraph.EVENT);
  }
  function b() {
    this.properties = {channel:0, cmd:"CC", value1:1, value2:1};
    this.addInput("send", LiteGraph.EVENT);
    this.addInput("assign", LiteGraph.EVENT);
    this.addOutput("on_midi", LiteGraph.EVENT);
  }
  function c() {
    this.properties = {cc:1, value:0};
    this.addOutput("value", "number");
  }
  e.prototype.setup = function(a) {
    this.data = a;
    this.status = a = a[0];
    var b = a & 240;
    this.cmd = 240 <= a ? a : b;
    this.cmd == e.NOTEON && 0 == this.velocity && (this.cmd = e.NOTEOFF);
    this.cmd_str = e.commands[this.cmd] || "";
    if (b >= e.NOTEON || b <= e.NOTEOFF) {
      this.channel = a & 15;
    }
  };
  Object.defineProperty(e.prototype, "velocity", {get:function() {
    return this.cmd == e.NOTEON ? this.data[2] : -1;
  }, set:function(a) {
    this.data[2] = a;
  }, enumerable:!0});
  e.notes = "A A# B C C# D D# E F F# G G#".split(" ");
  e.prototype.getPitch = function() {
    return 440 * Math.pow(2, (this.data[1] - 69) / 12);
  };
  e.computePitch = function(a) {
    return 440 * Math.pow(2, (a - 69) / 12);
  };
  e.prototype.getCC = function() {
    return this.data[1];
  };
  e.prototype.getCCValue = function() {
    return this.data[2];
  };
  e.prototype.getPitchBend = function() {
    return this.data[1] + (this.data[2] << 7) - 8192;
  };
  e.computePitchBend = function(a, b) {
    return a + (b << 7) - 8192;
  };
  e.prototype.setCommandFromString = function(a) {
    this.cmd = e.computeCommandFromString(a);
  };
  e.computeCommandFromString = function(a) {
    if (!a) {
      return 0;
    }
    if (a && a.constructor === Number) {
      return a;
    }
    a = a.toUpperCase();
    switch(a) {
      case "NOTE ON":
      case "NOTEON":
        return e.NOTEON;
      case "NOTE OFF":
      case "NOTEOFF":
        return e.NOTEON;
      case "KEY PRESSURE":
      case "KEYPRESSURE":
        return e.KEYPRESSURE;
      case "CONTROLLER CHANGE":
      case "CONTROLLERCHANGE":
      case "CC":
        return e.CONTROLLERCHANGE;
      case "PROGRAM CHANGE":
      case "PROGRAMCHANGE":
      case "PC":
        return e.PROGRAMCHANGE;
      case "CHANNEL PRESSURE":
      case "CHANNELPRESSURE":
        return e.CHANNELPRESSURE;
      case "PITCH BEND":
      case "PITCHBEND":
        return e.PITCHBEND;
      case "TIME TICK":
      case "TIMETICK":
        return e.TIMETICK;
      default:
        return Number(a);
    }
  };
  e.toNoteString = function(a) {
    var b = (a - 21) % 12;
    0 > b && (b = 12 + b);
    return e.notes[b] + Math.floor((a - 24) / 12 + 1);
  };
  e.prototype.toString = function() {
    var a = "" + this.channel + ". ";
    switch(this.cmd) {
      case e.NOTEON:
        a += "NOTEON " + e.toNoteString(this.data[1]);
        break;
      case e.NOTEOFF:
        a += "NOTEOFF " + e.toNoteString(this.data[1]);
        break;
      case e.CONTROLLERCHANGE:
        a += "CC " + this.data[1] + " " + this.data[2];
        break;
      case e.PROGRAMCHANGE:
        a += "PC " + this.data[1];
        break;
      case e.PITCHBEND:
        a += "PITCHBEND " + this.getPitchBend();
        break;
      case e.KEYPRESSURE:
        a += "KEYPRESS " + this.data[1];
    }
    return a;
  };
  e.prototype.toHexString = function() {
    for (var a = "", b = 0; b < this.data.length; b++) {
      a += this.data[b].toString(16) + " ";
    }
  };
  e.NOTEOFF = 128;
  e.NOTEON = 144;
  e.KEYPRESSURE = 160;
  e.CONTROLLERCHANGE = 176;
  e.PROGRAMCHANGE = 192;
  e.CHANNELPRESSURE = 208;
  e.PITCHBEND = 224;
  e.TIMETICK = 248;
  e.commands = {128:"note off", 144:"note on", 160:"key pressure", 176:"controller change", 192:"program change", 208:"channel pressure", 224:"pitch bend", 240:"system", 242:"Song pos", 243:"Song select", 246:"Tune request", 248:"time tick", 250:"Start Song", 251:"Continue Song", 252:"Stop Song", 254:"Sensing", 255:"Reset"};
  f.input = null;
  f.MIDIEvent = e;
  f.prototype.onMIDISuccess = function(a) {
    console.log("MIDI ready!");
    console.log(a);
    this.midi = a;
    this.updatePorts();
    if (this.on_ready) {
      this.on_ready(this);
    }
  };
  f.prototype.updatePorts = function() {
    var a = this.midi;
    this.input_ports = a.inputs;
    for (var b = 0, c = this.input_ports.values(), d = c.next(); d && !1 === d.done;) {
      d = d.value, console.log("Input port [type:'" + d.type + "'] id:'" + d.id + "' manufacturer:'" + d.manufacturer + "' name:'" + d.name + "' version:'" + d.version + "'"), b++, d = c.next();
    }
    this.num_input_ports = b;
    b = 0;
    this.output_ports = a.outputs;
    c = this.output_ports.values();
    for (d = c.next(); d && !1 === d.done;) {
      d = d.value, console.log("Output port [type:'" + d.type + "'] id:'" + d.id + "' manufacturer:'" + d.manufacturer + "' name:'" + d.name + "' version:'" + d.version + "'"), b++, d = c.next();
    }
    this.num_output_ports = b;
  };
  f.prototype.onMIDIFailure = function(a) {
    console.error("Failed to get MIDI access - " + a);
  };
  f.prototype.openInputPort = function(a, b) {
    a = this.input_ports.get("input-" + a);
    if (!a) {
      return !1;
    }
    f.input = this;
    var c = this;
    a.onmidimessage = function(a) {
      var d = new e(a.data);
      c.updateState(d);
      b && b(a.data, d);
      if (f.on_message) {
        f.on_message(a.data, d);
      }
    };
    console.log("port open: ", a);
    return !0;
  };
  f.parseMsg = function(a) {
  };
  f.prototype.updateState = function(a) {
    switch(a.cmd) {
      case e.NOTEON:
        this.state.note[a.value1 | 0] = a.value2;
        break;
      case e.NOTEOFF:
        this.state.note[a.value1 | 0] = 0;
        break;
      case e.CONTROLLERCHANGE:
        this.state.cc[a.getCC()] = a.getCCValue();
    }
  };
  f.prototype.sendMIDI = function(a, b) {
    b && (a = this.output_ports.get("output-" + a)) && (f.output = this, b.constructor === e ? a.send(b.data) : a.send(b));
  };
  g.MIDIInterface = f;
  g.title = "MIDI Input";
  g.desc = "Reads MIDI from a input port";
  g.prototype.getPropertyInfo = function(a) {
    if (this._midi && "port" == a) {
      a = {};
      for (var b = 0; b < this._midi.input_ports.size; ++b) {
        var c = this._midi.input_ports.get("input-" + b);
        a[b] = b + ".- " + c.name + " version:" + c.version;
      }
      return {type:"enum", values:a};
    }
  };
  g.prototype.onStart = function() {
    this._midi ? this._midi.openInputPort(this.properties.port, this.onMIDIEvent.bind(this)) : this._waiting = !0;
  };
  g.prototype.onMIDIEvent = function(a, b) {
    this._last_midi_event = b;
    this.trigger("on_midi", b);
    b.cmd == e.NOTEON ? this.trigger("on_noteon", b) : b.cmd == e.NOTEOFF ? this.trigger("on_noteoff", b) : b.cmd == e.CONTROLLERCHANGE ? this.trigger("on_cc", b) : b.cmd == e.PROGRAMCHANGE ? this.trigger("on_pc", b) : b.cmd == e.PITCHBEND && this.trigger("on_pitchbend", b);
  };
  g.prototype.onExecute = function() {
    if (this.outputs) {
      for (var a = this._last_midi_event, b = 0; b < this.outputs.length; ++b) {
        switch(this.outputs[b].name) {
          case "midi":
            var c = this._midi;
            break;
          case "last_midi":
            c = a;
            break;
          default:
            continue;
        }
        this.setOutputData(b, c);
      }
    }
  };
  g.prototype.onGetOutputs = function() {
    return [["last_midi", "midi"], ["on_midi", LiteGraph.EVENT], ["on_noteon", LiteGraph.EVENT], ["on_noteoff", LiteGraph.EVENT], ["on_cc", LiteGraph.EVENT], ["on_pc", LiteGraph.EVENT], ["on_pitchbend", LiteGraph.EVENT]];
  };
  LiteGraph.registerNodeType("midi/input", g);
  l.MIDIInterface = f;
  l.title = "MIDI Output";
  l.desc = "Sends MIDI to output channel";
  l.prototype.getPropertyInfo = function(a) {
    if (this._midi && "port" == a) {
      a = {};
      for (var b = 0; b < this._midi.output_ports.size; ++b) {
        var c = this._midi.output_ports.get(b);
        a[b] = b + ".- " + c.name + " version:" + c.version;
      }
      return {type:"enum", values:a};
    }
  };
  l.prototype.onAction = function(a, b) {
    console.log(b);
    this._midi && ("send" == a && this._midi.sendMIDI(this.port, b), this.trigger("midi", b));
  };
  l.prototype.onGetInputs = function() {
    return [["send", LiteGraph.ACTION]];
  };
  l.prototype.onGetOutputs = function() {
    return [["on_midi", LiteGraph.EVENT]];
  };
  LiteGraph.registerNodeType("midi/output", l);
  k.title = "MIDI Show";
  k.desc = "Shows MIDI in the graph";
  k.prototype.onAction = function(a, b) {
    b && (this._str = b.constructor === e ? b.toString() : "???");
  };
  k.prototype.onDrawForeground = function(a) {
    this._str && (a.font = "30px Arial", a.fillText(this._str, 10, 0.8 * this.size[1]));
  };
  k.prototype.onGetInputs = function() {
    return [["in", LiteGraph.ACTION]];
  };
  k.prototype.onGetOutputs = function() {
    return [["on_midi", LiteGraph.EVENT]];
  };
  LiteGraph.registerNodeType("midi/show", k);
  a.title = "MIDI Filter";
  a.desc = "Filters MIDI messages";
  a.prototype.onAction = function(a, b) {
    !b || b.constructor !== e || -1 != this.properties.channel && b.channel != this.properties.channel || -1 != this.properties.cmd && b.cmd != this.properties.cmd || -1 != this.properties.min_value && b.data[1] < this.properties.min_value || -1 != this.properties.max_value && b.data[1] > this.properties.max_value || this.trigger("on_midi", b);
  };
  LiteGraph.registerNodeType("midi/filter", a);
  b.title = "MIDIEvent";
  b.desc = "Create a MIDI Event";
  b.prototype.onAction = function(a, b) {
    "assign" == a ? (this.properties.channel = b.channel, this.properties.cmd = b.cmd, this.properties.value1 = b.data[1], this.properties.value2 = b.data[2]) : (b = new e, b.channel = this.properties.channel, this.properties.cmd && this.properties.cmd.constructor === String ? b.setCommandFromString(this.properties.cmd) : b.cmd = this.properties.cmd, b.data[0] = b.cmd | b.channel, b.data[1] = Number(this.properties.value1), b.data[2] = Number(this.properties.value2), this.trigger("on_midi", b));
  };
  b.prototype.onExecute = function() {
    var a = this.properties;
    if (this.outputs) {
      for (var b = 0; b < this.outputs.length; ++b) {
        switch(this.outputs[b].name) {
          case "midi":
            var c = new e;
            c.setup([a.cmd, a.value1, a.value2]);
            c.channel = a.channel;
            break;
          case "command":
            c = a.cmd;
            break;
          case "cc":
            c = a.value1;
            break;
          case "cc_value":
            c = a.value2;
            break;
          case "note":
            c = a.cmd == e.NOTEON || a.cmd == e.NOTEOFF ? a.value1 : null;
            break;
          case "velocity":
            c = a.cmd == e.NOTEON ? a.value2 : null;
            break;
          case "pitch":
            c = a.cmd == e.NOTEON ? e.computePitch(a.value1) : null;
            break;
          case "pitchbend":
            c = a.cmd == e.PITCHBEND ? e.computePitchBend(a.value1, a.value2) : null;
            break;
          default:
            continue;
        }
        null !== c && this.setOutputData(b, c);
      }
    }
  };
  b.prototype.onPropertyChanged = function(a, b) {
    "cmd" == a && (this.properties.cmd = e.computeCommandFromString(b));
  };
  b.prototype.onGetOutputs = function() {
    return [["midi", "midi"], ["on_midi", LiteGraph.EVENT], ["command", "number"], ["note", "number"], ["velocity", "number"], ["cc", "number"], ["cc_value", "number"], ["pitch", "number"], ["pitchbend", "number"]];
  };
  LiteGraph.registerNodeType("midi/event", b);
  c.title = "MIDICC";
  c.desc = "gets a Controller Change";
  c.prototype.onExecute = function() {
    f.input && (this.properties.value = f.input.state.cc[this.properties.cc]);
    this.setOutputData(0, this.properties.value);
  };
  LiteGraph.registerNodeType("midi/cc", c);
})(window);
(function(d) {
  function e() {
    this.properties = {src:"", gain:0.5, loop:!0, autoplay:!0, playbackRate:1};
    this._loading_audio = !1;
    this._audiobuffer = null;
    this._audionodes = [];
    this._last_sourcenode = null;
    this.addOutput("out", "audio");
    this.addInput("gain", "number");
    this.audionode = p.getAudioContext().createGain();
    this.audionode.graphnode = this;
    this.audionode.gain.value = this.properties.gain;
    this.properties.src && this.loadSound(this.properties.src);
  }
  function f() {
    this.properties = {fftSize:2048, minDecibels:-100, maxDecibels:-10, smoothingTimeConstant:0.5};
    this.audionode = p.getAudioContext().createAnalyser();
    this.audionode.graphnode = this;
    this.audionode.fftSize = this.properties.fftSize;
    this.audionode.minDecibels = this.properties.minDecibels;
    this.audionode.maxDecibels = this.properties.maxDecibels;
    this.audionode.smoothingTimeConstant = this.properties.smoothingTimeConstant;
    this.addInput("in", "audio");
    this.addOutput("freqs", "array");
    this.addOutput("samples", "array");
    this._time_bin = this._freq_bin = null;
  }
  function g() {
    this.properties = {gain:1};
    this.audionode = p.getAudioContext().createGain();
    this.addInput("in", "audio");
    this.addInput("gain", "number");
    this.addOutput("out", "audio");
  }
  function l() {
    this.properties = {impulse_src:"", normalize:!0};
    this.audionode = p.getAudioContext().createConvolver();
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function k() {
    this.properties = {threshold:-50, knee:40, ratio:12, reduction:-20, attack:0, release:0.25};
    this.audionode = p.getAudioContext().createDynamicsCompressor();
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function a() {
    this.properties = {};
    this.audionode = p.getAudioContext().createWaveShaper();
    this.addInput("in", "audio");
    this.addInput("shape", "waveshape");
    this.addOutput("out", "audio");
  }
  function b() {
    this.properties = {gain1:0.5, gain2:0.5};
    this.audionode = p.getAudioContext().createGain();
    this.audionode1 = p.getAudioContext().createGain();
    this.audionode1.gain.value = this.properties.gain1;
    this.audionode2 = p.getAudioContext().createGain();
    this.audionode2.gain.value = this.properties.gain2;
    this.audionode1.connect(this.audionode);
    this.audionode2.connect(this.audionode);
    this.addInput("in1", "audio");
    this.addInput("in1 gain", "number");
    this.addInput("in2", "audio");
    this.addInput("in2 gain", "number");
    this.addOutput("out", "audio");
  }
  function c() {
    this.properties = {delayTime:0.5};
    this.audionode = p.getAudioContext().createDelay(10);
    this.audionode.delayTime.value = this.properties.delayTime;
    this.addInput("in", "audio");
    this.addInput("time", "number");
    this.addOutput("out", "audio");
  }
  function h() {
    this.properties = {frequency:350, detune:0, Q:1};
    this.addProperty("type", "lowpass", "enum", {values:"lowpass highpass bandpass lowshelf highshelf peaking notch allpass".split(" ")});
    this.audionode = p.getAudioContext().createBiquadFilter();
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function n() {
    this.properties = {frequency:440, detune:0, type:"sine"};
    this.addProperty("type", "sine", "enum", {values:["sine", "square", "sawtooth", "triangle", "custom"]});
    this.audionode = p.getAudioContext().createOscillator();
    this.addOutput("out", "audio");
  }
  function v() {
    this.properties = {continuous:!0, mark:-1};
    this.addInput("data", "array");
    this.addInput("mark", "number");
    this.size = [300, 200];
    this._last_buffer = null;
  }
  function u() {
    this.properties = {band:440, amplitude:1};
    this.addInput("freqs", "array");
    this.addOutput("signal", "number");
  }
  function r() {
    if (!r.default_code) {
      var a = r.default_function.toString(), b = a.indexOf("{") + 1, c = a.lastIndexOf("}");
      r.default_code = a.substr(b, c - b);
    }
    this.properties = {code:r.default_code};
    a = p.getAudioContext();
    a.createScriptProcessor ? this.audionode = a.createScriptProcessor(4096, 1, 1) : (console.warn("ScriptProcessorNode deprecated"), this.audionode = a.createGain());
    this.processCode();
    r._bypass_function || (r._bypass_function = this.audionode.onaudioprocess);
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function t() {
    this.audionode = p.getAudioContext().destination;
    this.addInput("in", "audio");
  }
  var p = {};
  d.LGAudio = p;
  p.getAudioContext = function() {
    if (!this._audio_context) {
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!window.AudioContext) {
        return console.error("AudioContext not supported by browser"), null;
      }
      this._audio_context = new AudioContext;
      this._audio_context.onmessage = function(a) {
        console.log("msg", a);
      };
      this._audio_context.onended = function(a) {
        console.log("ended", a);
      };
      this._audio_context.oncomplete = function(a) {
        console.log("complete", a);
      };
    }
    return this._audio_context;
  };
  p.connect = function(a, b) {
    try {
      a.connect(b);
    } catch (y) {
      console.warn("LGraphAudio:", y);
    }
  };
  p.disconnect = function(a, b) {
    try {
      a.disconnect(b);
    } catch (y) {
      console.warn("LGraphAudio:", y);
    }
  };
  p.changeAllAudiosConnections = function(a, b) {
    if (a.inputs) {
      for (var c = 0; c < a.inputs.length; ++c) {
        var d = a.graph.links[a.inputs[c].link];
        if (d) {
          var e = a.graph.getNodeById(d.origin_id);
          e = e.getAudioNodeInOutputSlot ? e.getAudioNodeInOutputSlot(d.origin_slot) : e.audionode;
          d = a.getAudioNodeInInputSlot ? a.getAudioNodeInInputSlot(c) : a.audionode;
          b ? p.connect(e, d) : p.disconnect(e, d);
        }
      }
    }
    if (a.outputs) {
      for (c = 0; c < a.outputs.length; ++c) {
        for (var f = a.outputs[c], g = 0; g < f.links.length; ++g) {
          if (d = a.graph.links[f.links[g]]) {
            e = a.getAudioNodeInOutputSlot ? a.getAudioNodeInOutputSlot(c) : a.audionode;
            var h = a.graph.getNodeById(d.target_id);
            d = h.getAudioNodeInInputSlot ? h.getAudioNodeInInputSlot(d.target_slot) : h.audionode;
            b ? p.connect(e, d) : p.disconnect(e, d);
          }
        }
      }
    }
  };
  p.onConnectionsChange = function(a, b, c, d) {
    a == LiteGraph.OUTPUT && (a = null, d && (a = this.graph.getNodeById(d.target_id)), a && (b = this.getAudioNodeInOutputSlot ? this.getAudioNodeInOutputSlot(b) : this.audionode, d = a.getAudioNodeInInputSlot ? a.getAudioNodeInInputSlot(d.target_slot) : a.audionode, c ? p.connect(b, d) : p.disconnect(b, d)));
  };
  p.createAudioNodeWrapper = function(a) {
    var b = a.prototype.onPropertyChanged;
    a.prototype.onPropertyChanged = function(a, c) {
      b && b.call(this, a, c);
      this.audionode && void 0 !== this.audionode[a] && (void 0 !== this.audionode[a].value ? this.audionode[a].value = c : this.audionode[a] = c);
    };
    a.prototype.onConnectionsChange = p.onConnectionsChange;
  };
  p.cached_audios = {};
  p.loadSound = function(a, b, c) {
    function d(a) {
      console.log("Audio loading sample error:", a);
      c && c(a);
    }
    if (p.cached_audios[a] && -1 == a.indexOf("blob:")) {
      b && b(p.cached_audios[a]);
    } else {
      p.onProcessAudioURL && (a = p.onProcessAudioURL(a));
      var e = new XMLHttpRequest;
      e.open("GET", a, !0);
      e.responseType = "arraybuffer";
      var f = p.getAudioContext();
      e.onload = function() {
        console.log("AudioSource loaded");
        f.decodeAudioData(e.response, function(c) {
          console.log("AudioSource decoded");
          p.cached_audios[a] = c;
          b && b(c);
        }, d);
      };
      e.send();
      return e;
    }
  };
  e["@src"] = {widget:"resource"};
  e.supported_extensions = ["wav", "ogg", "mp3"];
  e.prototype.onAdded = function(a) {
    if (a.status === LGraph.STATUS_RUNNING) {
      this.onStart();
    }
  };
  e.prototype.onStart = function() {
    this._audiobuffer && this.properties.autoplay && this.playBuffer(this._audiobuffer);
  };
  e.prototype.onStop = function() {
    this.stopAllSounds();
  };
  e.prototype.onPause = function() {
    this.pauseAllSounds();
  };
  e.prototype.onUnpause = function() {
    this.unpauseAllSounds();
  };
  e.prototype.onRemoved = function() {
    this.stopAllSounds();
    this._dropped_url && URL.revokeObjectURL(this._url);
  };
  e.prototype.stopAllSounds = function() {
    for (var a = 0; a < this._audionodes.length; ++a) {
      this._audionodes[a].started && (this._audionodes[a].started = !1, this._audionodes[a].stop());
    }
    this._audionodes.length = 0;
  };
  e.prototype.pauseAllSounds = function() {
    p.getAudioContext().suspend();
  };
  e.prototype.unpauseAllSounds = function() {
    p.getAudioContext().resume();
  };
  e.prototype.onExecute = function() {
    if (this.inputs) {
      for (var a = 0; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        if (null != b.link) {
          var c = this.getInputData(a);
          if (void 0 !== c) {
            if ("gain" == b.name) {
              this.audionode.gain.value = c;
            } else {
              if ("playbackRate" == b.name) {
                for (this.properties.playbackRate = c, b = 0; b < this._audionodes.length; ++b) {
                  this._audionodes[b].playbackRate.value = c;
                }
              }
            }
          }
        }
      }
    }
    if (this.outputs) {
      for (a = 0; a < this.outputs.length; ++a) {
        "buffer" == this.outputs[a].name && this._audiobuffer && this.setOutputData(a, this._audiobuffer);
      }
    }
  };
  e.prototype.onAction = function(a) {
    this._audiobuffer && ("Play" == a ? this.playBuffer(this._audiobuffer) : "Stop" == a && this.stopAllSounds());
  };
  e.prototype.onPropertyChanged = function(a, b) {
    if ("src" == a) {
      this.loadSound(b);
    } else {
      if ("gain" == a) {
        this.audionode.gain.value = b;
      } else {
        if ("playbackRate" == a) {
          for (a = 0; a < this._audionodes.length; ++a) {
            this._audionodes[a].playbackRate.value = b;
          }
        }
      }
    }
  };
  e.prototype.playBuffer = function(a) {
    var b = this, c = p.getAudioContext().createBufferSource();
    this._last_sourcenode = c;
    c.graphnode = this;
    c.buffer = a;
    c.loop = this.properties.loop;
    c.playbackRate.value = this.properties.playbackRate;
    this._audionodes.push(c);
    c.connect(this.audionode);
    this._audionodes.push(c);
    c.onended = function() {
      b.trigger("ended");
      var a = b._audionodes.indexOf(c);
      -1 != a && b._audionodes.splice(a, 1);
    };
    c.started || (c.started = !0, c.start());
    return c;
  };
  e.prototype.loadSound = function(a) {
    var b = this;
    this._request && (this._request.abort(), this._request = null);
    this._audiobuffer = null;
    this._loading_audio = !1;
    a && (this._request = p.loadSound(a, function(a) {
      this.boxcolor = LiteGraph.NODE_DEFAULT_BOXCOLOR;
      b._audiobuffer = a;
      b._loading_audio = !1;
      if (b.graph && b.graph.status === LGraph.STATUS_RUNNING) {
        b.onStart();
      }
    }), this._loading_audio = !0, this.boxcolor = "#AA4");
  };
  e.prototype.onConnectionsChange = p.onConnectionsChange;
  e.prototype.onGetInputs = function() {
    return [["playbackRate", "number"], ["Play", LiteGraph.ACTION], ["Stop", LiteGraph.ACTION]];
  };
  e.prototype.onGetOutputs = function() {
    return [["buffer", "audiobuffer"], ["ended", LiteGraph.EVENT]];
  };
  e.prototype.onDropFile = function(a) {
    this._dropped_url && URL.revokeObjectURL(this._dropped_url);
    a = URL.createObjectURL(a);
    this.properties.src = a;
    this.loadSound(a);
    this._dropped_url = a;
  };
  e.title = "Source";
  e.desc = "Plays audio";
  LiteGraph.registerNodeType("audio/source", e);
  f.prototype.onPropertyChanged = function(a, b) {
    this.audionode[a] = b;
  };
  f.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.audionode.frequencyBinCount;
      this._freq_bin && this._freq_bin.length == a || (this._freq_bin = new Uint8Array(a));
      this.audionode.getByteFrequencyData(this._freq_bin);
      this.setOutputData(0, this._freq_bin);
    }
    this.isOutputConnected(1) && (a = this.audionode.frequencyBinCount, this._time_bin && this._time_bin.length == a || (this._time_bin = new Uint8Array(a)), this.audionode.getByteTimeDomainData(this._time_bin), this.setOutputData(1, this._time_bin));
    for (a = 1; a < this.inputs.length; ++a) {
      var b = this.inputs[a];
      if (null != b.link) {
        var c = this.getInputData(a);
        void 0 !== c && (this.audionode[b.name].value = c);
      }
    }
  };
  f.prototype.onGetInputs = function() {
    return [["minDecibels", "number"], ["maxDecibels", "number"], ["smoothingTimeConstant", "number"]];
  };
  f.prototype.onGetOutputs = function() {
    return [["freqs", "array"], ["samples", "array"]];
  };
  f.title = "Analyser";
  f.desc = "Audio Analyser";
  LiteGraph.registerNodeType("audio/analyser", f);
  g.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var a = 1; a < this.inputs.length; ++a) {
        var b = this.inputs[a], c = this.getInputData(a);
        void 0 !== c && (this.audionode[b.name].value = c);
      }
    }
  };
  p.createAudioNodeWrapper(g);
  g.title = "Gain";
  g.desc = "Audio gain";
  LiteGraph.registerNodeType("audio/gain", g);
  p.createAudioNodeWrapper(l);
  l.prototype.onRemove = function() {
    this._dropped_url && URL.revokeObjectURL(this._dropped_url);
  };
  l.prototype.onPropertyChanged = function(a, b) {
    "impulse_src" == a ? this.loadImpulse(b) : "normalize" == a && (this.audionode.normalize = b);
  };
  l.prototype.onDropFile = function(a) {
    this._dropped_url && URL.revokeObjectURL(this._dropped_url);
    this._dropped_url = URL.createObjectURL(a);
    this.properties.impulse_src = this._dropped_url;
    this.loadImpulse(this._dropped_url);
  };
  l.prototype.loadImpulse = function(a) {
    var b = this;
    this._request && (this._request.abort(), this._request = null);
    this._impulse_buffer = null;
    this._loading_impulse = !1;
    a && (this._request = p.loadSound(a, function(a) {
      b._impulse_buffer = a;
      b.audionode.buffer = a;
      console.log("Impulse signal set");
      b._loading_impulse = !1;
    }), this._loading_impulse = !0);
  };
  l.title = "Convolver";
  l.desc = "Convolves the signal (used for reverb)";
  LiteGraph.registerNodeType("audio/convolver", l);
  p.createAudioNodeWrapper(k);
  k.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var a = 1; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        if (null != b.link) {
          var c = this.getInputData(a);
          void 0 !== c && (this.audionode[b.name].value = c);
        }
      }
    }
  };
  k.prototype.onGetInputs = function() {
    return [["threshold", "number"], ["knee", "number"], ["ratio", "number"], ["reduction", "number"], ["attack", "number"], ["release", "number"]];
  };
  k.title = "DynamicsCompressor";
  k.desc = "Dynamics Compressor";
  LiteGraph.registerNodeType("audio/dynamicsCompressor", k);
  a.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      var a = this.getInputData(1);
      void 0 !== a && (this.audionode.curve = a);
    }
  };
  a.prototype.setWaveShape = function(a) {
    this.audionode.curve = a;
  };
  p.createAudioNodeWrapper(a);
  b.prototype.getAudioNodeInInputSlot = function(a) {
    if (0 == a) {
      return this.audionode1;
    }
    if (2 == a) {
      return this.audionode2;
    }
  };
  b.prototype.onPropertyChanged = function(a, b) {
    "gain1" == a ? this.audionode1.gain.value = b : "gain2" == a && (this.audionode2.gain.value = b);
  };
  b.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var a = 1; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        null != b.link && "audio" != b.type && (b = this.getInputData(a), void 0 !== b && (1 == a ? this.audionode1.gain.value = b : 3 == a && (this.audionode2.gain.value = b)));
      }
    }
  };
  p.createAudioNodeWrapper(b);
  b.title = "Mixer";
  b.desc = "Audio mixer";
  LiteGraph.registerNodeType("audio/mixer", b);
  p.createAudioNodeWrapper(c);
  c.prototype.onExecute = function() {
    var a = this.getInputData(1);
    void 0 !== a && (this.audionode.delayTime.value = a);
  };
  c.title = "Delay";
  c.desc = "Audio delay";
  LiteGraph.registerNodeType("audio/delay", c);
  h.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var a = 1; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        if (null != b.link) {
          var c = this.getInputData(a);
          void 0 !== c && (this.audionode[b.name].value = c);
        }
      }
    }
  };
  h.prototype.onGetInputs = function() {
    return [["frequency", "number"], ["detune", "number"], ["Q", "number"]];
  };
  p.createAudioNodeWrapper(h);
  h.title = "BiquadFilter";
  h.desc = "Audio filter";
  LiteGraph.registerNodeType("audio/biquadfilter", h);
  n.prototype.onStart = function() {
    this.audionode.started || (this.audionode.started = !0, this.audionode.start());
  };
  n.prototype.onStop = function() {
    this.audionode.started && (this.audionode.started = !1, this.audionode.stop());
  };
  n.prototype.onPause = function() {
    this.onStop();
  };
  n.prototype.onUnpause = function() {
    this.onStart();
  };
  n.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var a = 0; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        if (null != b.link) {
          var c = this.getInputData(a);
          void 0 !== c && (this.audionode[b.name].value = c);
        }
      }
    }
  };
  n.prototype.onGetInputs = function() {
    return [["frequency", "number"], ["detune", "number"], ["type", "string"]];
  };
  p.createAudioNodeWrapper(n);
  n.title = "Oscillator";
  n.desc = "Oscillator";
  LiteGraph.registerNodeType("audio/oscillator", n);
  v.prototype.onExecute = function() {
    this._last_buffer = this.getInputData(0);
    var a = this.getInputData(1);
    void 0 !== a && (this.properties.mark = a);
    this.setDirtyCanvas(!0, !1);
  };
  v.prototype.onDrawForeground = function(a) {
    if (this._last_buffer) {
      var b = this._last_buffer, c = b.length / this.size[0], d = this.size[1];
      a.fillStyle = "black";
      a.fillRect(0, 0, this.size[0], this.size[1]);
      a.strokeStyle = "white";
      a.beginPath();
      var e = 0;
      if (this.properties.continuous) {
        a.moveTo(e, d);
        for (var f = 0; f < b.length; f += c) {
          a.lineTo(e, d - b[f | 0] / 255 * d), e++;
        }
      } else {
        for (f = 0; f < b.length; f += c) {
          a.moveTo(e + 0.5, d), a.lineTo(e + 0.5, d - b[f | 0] / 255 * d), e++;
        }
      }
      a.stroke();
      0 <= this.properties.mark && (b = p.getAudioContext().sampleRate / b.length, e = this.properties.mark / b * 2 / c, e >= this.size[0] && (e = this.size[0] - 1), a.strokeStyle = "red", a.beginPath(), a.moveTo(e, d), a.lineTo(e, 0), a.stroke());
    }
  };
  v.title = "Visualization";
  v.desc = "Audio Visualization";
  LiteGraph.registerNodeType("audio/visualization", v);
  u.prototype.onExecute = function() {
    if (this._freqs = this.getInputData(0)) {
      var a = this.properties.band, b = this.getInputData(1);
      void 0 !== b && (a = b);
      b = p.getAudioContext().sampleRate / this._freqs.length;
      b = a / b * 2;
      b >= this._freqs.length ? b = this._freqs[this._freqs.length - 1] : (a = b | 0, b -= a, b = this._freqs[a] * (1 - b) + this._freqs[a + 1] * b);
      this.setOutputData(0, b / 255 * this.properties.amplitude);
    }
  };
  u.prototype.onGetInputs = function() {
    return [["band", "number"]];
  };
  u.title = "Signal";
  u.desc = "extract the signal of some frequency";
  LiteGraph.registerNodeType("audio/signal", u);
  r.prototype.onAdded = function(a) {
    a.status == LGraph.STATUS_RUNNING && (this.audionode.onaudioprocess = this._callback);
  };
  r["@code"] = {widget:"code"};
  r.prototype.onStart = function() {
    this.audionode.onaudioprocess = this._callback;
  };
  r.prototype.onStop = function() {
    this.audionode.onaudioprocess = r._bypass_function;
  };
  r.prototype.onPause = function() {
    this.audionode.onaudioprocess = r._bypass_function;
  };
  r.prototype.onUnpause = function() {
    this.audionode.onaudioprocess = this._callback;
  };
  r.prototype.onExecute = function() {
  };
  r.prototype.onRemoved = function() {
    this.audionode.onaudioprocess = r._bypass_function;
  };
  r.prototype.processCode = function() {
    try {
      this._script = new (new Function("properties", this.properties.code))(this.properties), this._old_code = this.properties.code, this._callback = this._script.onaudioprocess;
    } catch (q) {
      console.error("Error in onaudioprocess code", q), this._callback = r._bypass_function, this.audionode.onaudioprocess = this._callback;
    }
  };
  r.prototype.onPropertyChanged = function(a, b) {
    "code" == a && (this.properties.code = b, this.processCode(), this.graph && this.graph.status == LGraph.STATUS_RUNNING && (this.audionode.onaudioprocess = this._callback));
  };
  r.default_function = function() {
    this.onaudioprocess = function(a) {
      var b = a.inputBuffer;
      a = a.outputBuffer;
      for (var c = 0; c < a.numberOfChannels; c++) {
        for (var d = b.getChannelData(c), e = a.getChannelData(c), f = 0; f < b.length; f++) {
          e[f] = d[f];
        }
      }
    };
  };
  p.createAudioNodeWrapper(r);
  r.title = "Script";
  r.desc = "apply script to signal";
  LiteGraph.registerNodeType("audio/script", r);
  t.title = "Destination";
  t.desc = "Audio output";
  LiteGraph.registerNodeType("audio/destination", t);
})(window);

