/**
 * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                name = baseParts.concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());
define("../tools/almond", function(){});

define('misc/Polyfill',['require','exports','module'],function (require, exports, module) {

  'use strict';

  // polyfills stuffs

  if (!window.Map) {
    window.Map = function () {
      this.map = {};
    };
    window.Map.prototype = {
      set: function (key, value) {
        this.map[key] = value;
      },
      get: function (key) {
        return this.map[key];
      }
    };
  }

  if (!Float32Array.prototype.slice) {
    var slicePolyfill = function (start, end) {
      return new this.constructor(this.subarray(start, end));
    };

    Int8Array.prototype.slice = slicePolyfill;
    Uint8Array.prototype.slice = slicePolyfill;
    Uint8ClampedArray.prototype.slice = slicePolyfill;
    Int16Array.prototype.slice = slicePolyfill;
    Uint16Array.prototype.slice = slicePolyfill;
    Int32Array.prototype.slice = slicePolyfill;
    Uint32Array.prototype.slice = slicePolyfill;
    Float32Array.prototype.slice = slicePolyfill;
    Float64Array.prototype.slice = slicePolyfill;
  }

  if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (str) {
      return this.slice(-str.length) === str;
    };
  }

  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (str) {
      return this.slice(0, str.length) === str;
    };
  }

  var vendors = ['moz', 'webkit'];
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
  }
  if (!window.requestAnimationFrame)
    window.alert('browser is too old. Probably no webgl there anyway');

  module.exports = {};
});
define('lib/glMatrix',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var glm = {};

  glm.vec2 = window.vec2;
  glm.vec3 = window.vec3;
  glm.vec4 = window.vec4;
  glm.mat2 = window.mat2;
  glm.mat3 = window.mat3;
  glm.mat4 = window.mat4;
  glm.quat = window.quat;

  module.exports = glm;
});
define('lib/Hammer',['require','exports','module'],function (require, exports, module) {

  'use strict';

  module.exports = window.Hammer;
});
define('misc/Utils',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var Utils = {};

  Utils.SCALE = 100.0; // scale factor
  Utils.TAG_FLAG = 1; // flag value for comparison (always >= tags values)
  Utils.SCULPT_FLAG = 1; // flag value for sculpt (always >= tags values)
  Utils.STATE_FLAG = 1; // flag value for states (always >= tags values)

  Utils.cursors = {};
  Utils.cursors.dropper = 'url(resources/dropper.png) 5 25, auto';

  Utils.makeProxy = function (source, proxy, wrapFunc) {
    var sourceProto = source.prototype;
    var proxyProto = proxy.prototype;
    var protos = Object.keys(sourceProto);
    for (var i = 0, l = protos.length; i < l; ++i) {
      var proto = protos[i];
      if (!proxyProto[proto])
        proxyProto[proto] = wrapFunc ? wrapFunc(sourceProto[proto]) : sourceProto[proto];
    }
  };

  Utils.littleEndian = (function () {
    var buffer = new ArrayBuffer(2);
    new DataView(buffer).setInt16(0, 256, true);
    return new Int16Array(buffer)[0] === 256;
  })();

  Utils.replaceElement = function (array, oldValue, newValue) {
    for (var i = 0, l = array.length; i < l; ++i) {
      if (array[i] === oldValue) {
        array[i] = newValue;
        return;
      }
    }
  };

  Utils.removeElement = function (array, remValue) {
    for (var i = 0, l = array.length; i < l; ++i) {
      if (array[i] === remValue) {
        array[i] = array[l - 1];
        array.pop();
        return;
      }
    }
  };

  Utils.appendArray = function (array1, array2) {
    var nb1 = array1.length;
    var nb2 = array2.length;
    array1.length += nb2;
    for (var i = 0; i < nb2; ++i)
      array1[nb1 + i] = array2[i];
  };

  /** Return true if the number is a power of two */
  Utils.isPowerOfTwo = function (x) {
    return x !== 0 && (x & (x - 1)) === 0;
  };

  /** Return the nearest power of two value */
  Utils.nextHighestPowerOfTwo = function (x) {
    --x;
    for (var i = 1; i < 32; i <<= 1)
      x = x | x >> i;
    return x + 1;
  };

  var sortFunc = function (a, b) {
    return a - b;
  };
  /** sort an array and delete duplicate values */
  Utils.tidy = function (array) {
    array.sort(sortFunc);
    var len = array.length;
    var i = 0;
    var j = 0;
    for (i = 1; i < len; ++i) {
      if (array[j] !== array[i])
        array[++j] = array[i];
    }
    if (i > 1)
      array.length = j + 1;
  };

  /** Intersection between two arrays */
  Utils.intersectionArrays = function (a, b) {
    var ai = 0;
    var bi = 0;
    var result = [];

    var aLen = a.length;
    var bLen = b.length;
    while (ai < aLen && bi < bLen) {
      if (a[ai] < b[bi]) ai++;
      else if (a[ai] > b[bi]) bi++;
      else {
        result.push(a[ai]);
        ++ai;
        ++bi;
      }
    }
    return result;
  };

  /** Get bytes */
  Utils.getBytes = function (data, offset) {
    return [data[offset].charCodeAt(), data[offset + 1].charCodeAt(), data[offset + 2].charCodeAt(), data[offset + 3].charCodeAt()];
  };

  /** Read a binary uint32 */
  Utils.getUint32 = function (data, offset) {
    var b = Utils.getBytes(data, offset);
    return (b[0] << 0) | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
  };

  /** Read a binary float32 */
  Utils.getFloat32 = function (data, offset) {
    var b = Utils.getBytes(data, offset),
      sign = 1 - (2 * (b[3] >> 7)),
      exponent = (((b[3] << 1) & 0xff) | (b[2] >> 7)) - 127,
      mantissa = ((b[2] & 0x7f) << 16) | (b[1] << 8) | b[0];

    if (exponent === 128) {
      if (mantissa !== 0)
        return NaN;
      else
        return sign * Infinity;
    }
    if (exponent === -127)
      return sign * mantissa * Math.pow(2, -126 - 23);
    return sign * (1 + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);
  };

  /** Array buffer to string utf-8 */
  Utils.ab2str = function (buf) {
    var str = '';
    var ab = new Uint8Array(buf);
    var chunkSize = 65535;
    for (var off = 0, abLen = ab.length; off < abLen; off += chunkSize) {
      var subab = ab.subarray(off, chunkSize < abLen - off ? chunkSize + off : abLen);
      str += String.fromCharCode.apply(null, subab);
    }
    return str;
  };

  /** Return a buffer array which is at least nbBytes long */
  Utils.getMemory = (function () {
    var pool = new ArrayBuffer(100000);
    return function (nbBytes) {
      if (pool.byteLength >= nbBytes)
        return pool;
      pool = new ArrayBuffer(nbBytes);
      return pool;
    };
  })();

  /** Return the current time */
  Utils.now = Date.now || function () {
    return new Date().getTime();
  };

  Utils.throttle = function (func, wait) {
    var result;
    var args = [];
    var timeout = null;
    var previous = 0;
    var later = function () {
      previous = Utils.now();
      timeout = null;
      result = func.apply(func, args);
    };
    return function () {
      var now = Utils.now();
      var remaining = wait - (now - previous);

      var nbArgs = args.length = arguments.length;
      for (var i = 0; i < nbArgs; ++i)
        args[i] = arguments[i];

      if (remaining <= 0 || remaining > wait) {
        window.clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(func, args);
      } else if (!timeout) {
        timeout = window.setTimeout(later, remaining);
      }
      return result;
    };
  };

  Utils.normalizeArrayVec3 = function (array, out) {
    var arrayOut = out || array;
    for (var i = 0, l = array.length / 3; i < l; ++i) {
      var j = i * 3;
      var nx = array[j];
      var ny = array[j + 1];
      var nz = array[j + 2];
      var len = nx * nx + ny * ny + nz * nz;
      if (len === 0) {
        arrayOut[j] = 1.0;
        continue;
      }
      len = 1.0 / Math.sqrt(len);
      arrayOut[j] = nx * len;
      arrayOut[j + 1] = ny * len;
      arrayOut[j + 2] = nz * len;
    }
    return arrayOut;
  };

  Utils.convertArrayVec3toSRGB = function (array, out) {
    var arrayOut = out || array;
    for (var i = 0, l = array.length; i < l; ++i) {
      var c = array[i];
      var S1 = Math.sqrt(c);
      var S2 = Math.sqrt(S1);
      var S3 = Math.sqrt(S2);
      arrayOut[i] = 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;
    }
    return arrayOut;
  };

  Utils.convertArrayVec3toLinear = function (array, out) {
    var arrayOut = out || array;
    for (var i = 0, l = array.length; i < l; ++i) {
      var c = array[i];
      arrayOut[i] = c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
    }
    return arrayOut;
  };

  module.exports = Utils;
});
define('misc/getOptionsURL',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var queryBool = function (value, def) {
    if (value === undefined) return def;
    return value !== 'false' && value !== '0';
  };

  var queryNumber = function (value, min, max, def) {
    var f = parseFloat(value);
    if (!f && f !== 0.0) return def;
    return Math.max(min, Math.min(max, f));
  };

  var queryInteger = function (value, min, max, def) {
    var f = parseInt(value, 10);
    if (!f && f !== 0.0) return def;
    return Math.max(min, Math.min(max, f));
  };

  var queryColor = function (color, def) {
    if (!color) return def;
    var arr = color.split(',');
    if (arr.length < 3) return def;
    var out = def.slice();
    out[0] = parseInt(arr[0] || 0, 10) / 255;
    out[1] = parseInt(arr[1] || 0, 10) / 255;
    out[2] = parseInt(arr[2] || 0, 10) / 255;
    if (arr[3] !== undefined) out[3] = parseFloat(arr[3]);
    return out;
  };

  var readShortcuts = function (str) {
    var shortcuts = {};
    shortcuts['0'.charCodeAt(0)] = 'MOVE';
    shortcuts['1'.charCodeAt(0)] = 'BRUSH';
    shortcuts['2'.charCodeAt(0)] = 'INFLATE';
    shortcuts['3'.charCodeAt(0)] = 'TWIST';
    shortcuts['4'.charCodeAt(0)] = 'SMOOTH';
    shortcuts['5'.charCodeAt(0)] = 'FLATTEN';
    shortcuts['6'.charCodeAt(0)] = 'PINCH';
    shortcuts['7'.charCodeAt(0)] = 'CREASE';
    shortcuts['8'.charCodeAt(0)] = 'DRAG';
    shortcuts['9'.charCodeAt(0)] = 'PAINT';
    shortcuts['E'.charCodeAt(0)] = 'TRANSFORM';

    if (!str)
      return shortcuts;

    var vars = str.split(',');
    for (var i = 0, nbVars = vars.length; i < nbVars; i++) {
      var pair = vars[i].split(':', 2);
      if (pair.length !== 2) continue;
      shortcuts[pair[1].toUpperCase().charCodeAt(0)] = pair[0].toUpperCase();
    }

    return shortcuts;
  };

  var readUrlParameters = function () {
    var vars = window.location.search.substr(1).split('&');
    var params = {};
    for (var i = 0, nbVars = vars.length; i < nbVars; i++) {
      var pair = vars[i].split('=', 2);
      if (pair.length !== 2) continue;
      params[pair[0].toLowerCase()] = pair[1];
    }
    return params;
  };

  var options;
  var getOptionsURL = function () {
    if (options)
      return options;

    options = {};

    var params = readUrlParameters();

    // misc
    options.language = params.language; // english/chinese/korean/japanese/russian
    options.scalecenter = queryBool(params.scalecenter, true);
    options.wacom = queryBool(params.wacom, false); // try using deprecated npapi plugin

    // display
    options.grid = queryBool(params.grid, true);
    options.outline = queryBool(params.outline, false);
    options.outlinecolor = queryColor(params.outlinecolor, [0.3, 0.0, 0.0, 1.0]);
    options.mirrorline = queryBool(params.mirrorline, false);
    options.darkenunselected = queryBool(params.darkenunselected, true);

    // camera
    options.projection = (params.projection || 'PERSPECTIVE').toUpperCase(); // perspective/orthographic
    options.cameramode = (params.cameramode || 'ORBIT').toUpperCase(); // orbit/spherical/plane
    options.pivot = queryBool(params.pivot, true);
    options.fov = queryNumber(params.fov, 10, 90, 45); // [10-90]

    // rendering
    options.flatshading = queryBool(params.flatshading, false);
    options.wireframe = queryBool(params.wireframe, false);
    options.curvature = queryNumber(params.curvature, 0, 5, 0); // [0-5]
    options.exposure = queryNumber(params.exposure, 0, 5, 1); // [0-5]
    options.environment = queryInteger(params.environment, 0, Infinity, 0); // [0-inf]
    options.matcap = queryInteger(params.matcap, 0, Infinity, 3); // [0-inf]
    options.shader = (params.shader || 'MATCAP').toUpperCase(); // pbr/matcap/normal/uv
    options.filmic = queryBool(params.filmic, false);

    options.shortcuts = readShortcuts(params.shortcuts);

    return options;
  };

  getOptionsURL();

  module.exports = getOptionsURL;
});
define('misc/Tablet',['require','exports','module','misc/getOptionsURL'],function (require, exports, module) {

  'use strict';

  var getOptionsURL = require('misc/getOptionsURL');

  // TODO
  // It was based NPAPI, a deprecated API !
  // need a workaround now...
  // maybe I should take a look at pointer events, or extended touch events
  // only if requested through url
  var plugin;
  if (getOptionsURL().wacom) {
    plugin = document.createElement('object');
    plugin.setAttribute('id', 'tablet-plugin');
    plugin.setAttribute('type', 'application/x-wacomtabletplugin');
    document.body.appendChild(plugin);
  }

  var Tablet = {
    useOnRadius: true, // the pen pressure acts on the tool's radius
    useOnIntensity: false // the pen pressure acts on the tool's intensity
  };

  /** Returns the pressure of pen: [0, 1] **/
  Tablet.pressure = function () {
    if (!plugin)
      return 1.0;
    var pen = plugin.penAPI;
    return pen && pen.pointerType ? pen.pressure : 1.0;
  };

  Tablet.getPressureIntensity = function () {
    return Tablet.useOnIntensity === true ? 0.25 + Tablet.pressure() * 0.75 : 1.0;
  };

  Tablet.getPressureRadius = function () {
    return Tablet.useOnRadius === true ? 0.25 + Tablet.pressure() * 0.75 : 1.0;
  };

  module.exports = Tablet;
});
define('editing/tools/SculptBase',['require','exports','module','misc/Utils'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');

  // Overview sculpt :
  // start (check if we hit the mesh, start state stack) -> startSculpt
  // startSculpt (init stuffs specific to the tool) -> sculptStroke

  // sculptStroke (handle sculpt stroke by throttling/smoothing stroke) -> makeStroke
  // makeStroke (handle symmetry and picking before sculping) -> stroke
  // stroke (tool specific, move vertices, etc)

  // update -> sculptStroke

  var SculptBase = function (main) {
    this._main = main;
    this._states = main ? main.getStates() : null; // for undo-redo
    this._cbContinuous = this.updateContinuous.bind(this); // callback continuous
    this._lastMouseX = 0.0;
    this._lastMouseY = 0.0;
  };

  SculptBase.prototype = {
    setToolMesh: function (mesh) {
      // to be called when we create a new instance of a tool operator
      // that is no part of the main application Sculpt container (e.g smooth)
      this._forceToolMesh = mesh;
    },
    getMesh: function () {
      return this._forceToolMesh || this._main.getMesh();
    },
    start: function (ctrl) {
      var main = this._main;
      var picking = main.getPicking();

      if (!picking.intersectionMouseMeshes())
        return false;

      var mesh = main.setOrUnsetMesh(picking.getMesh(), ctrl);
      if (!mesh)
        return false;

      picking.initAlpha();
      var pickingSym = main.getSculpt().getSymmetry() ? main.getPickingSymmetry() : null;
      if (pickingSym) {
        pickingSym.intersectionMouseMesh(mesh);
        pickingSym.initAlpha();
      }

      this.pushState();
      this._lastMouseX = main._mouseX;
      this._lastMouseY = main._mouseY;
      this.startSculpt();

      return true;
    },
    end: function () {
      if (this.getMesh())
        this.getMesh().checkLeavesUpdate();
    },
    pushState: function () {
      this._states.pushStateGeometry(this.getMesh());
    },
    startSculpt: function () {
      if (this._lockPosition === true)
        return;
      this.sculptStroke();
    },
    preUpdate: function (canBeContinuous) {
      var main = this._main;
      var picking = main.getPicking();
      var isSculpting = main._action === 'SCULPT_EDIT';

      if (isSculpting && !canBeContinuous)
        return;

      if (isSculpting)
        picking.intersectionMouseMesh();
      else
        picking.intersectionMouseMeshes();

      var mesh = picking.getMesh();
      if (mesh && main.getSculpt().getSymmetry())
        main.getPickingSymmetry().intersectionMouseMesh(mesh);
    },
    update: function (continuous) {
      if (this._lockPosition === true)
        return this.updateSculptLock(continuous);
      this.sculptStroke();
    },
    /** Update lock position */
    updateSculptLock: function (continuous) {
      var main = this._main;
      if (!continuous)
        this._states.getCurrentState().undo(); // I can't believe it actually worked

      var picking = main.getPicking();
      var origRad = this._radius;
      var pickingSym = main.getSculpt().getSymmetry() ? main.getPickingSymmetry() : null;

      var dx = main._mouseX - this._lastMouseX;
      var dy = main._mouseY - this._lastMouseY;
      this._radius = Math.sqrt(dx * dx + dy * dy);
      // it's a bit hacky... I just simulate another stroke with a very small offset
      // so that the stroke still has a direction (the mask can be rotated correctly then)
      var offx = dx / this._radius;
      var offy = dy / this._radius;
      this.makeStroke(this._lastMouseX + offx * 1e-3, this._lastMouseY + offy * 1e-3, picking, pickingSym);
      this._radius = origRad;

      this.updateRender();
      main.setCanvasCursor('default');
    },
    sculptStroke: function () {
      var main = this._main;
      var picking = main.getPicking();
      var pickingSym = main.getSculpt().getSymmetry() ? main.getPickingSymmetry() : null;

      var dx = main._mouseX - this._lastMouseX;
      var dy = main._mouseY - this._lastMouseY;
      var dist = Math.sqrt(dx * dx + dy * dy);
      var minSpacing = 0.15 * this._radius * main.getPixelRatio();

      if (dist <= minSpacing)
        return;

      var step = 1.0 / Math.floor(dist / minSpacing);
      dx *= step;
      dy *= step;
      var mouseX = this._lastMouseX + dx;
      var mouseY = this._lastMouseY + dy;

      for (var i = step; i <= 1.0; i += step) {
        if (!this.makeStroke(mouseX, mouseY, picking, pickingSym))
          break;
        mouseX += dx;
        mouseY += dy;
      }

      this.updateRender();

      this._lastMouseX = main._mouseX;
      this._lastMouseY = main._mouseY;
    },
    updateRender: function () {
      this.updateMeshBuffers();
      this._main.render();
    },
    makeStroke: function (mouseX, mouseY, picking, pickingSym) {
      var mesh = this.getMesh();
      picking.intersectionMouseMesh(mesh, mouseX, mouseY);
      var pick1 = picking.getMesh();
      if (pick1) {
        picking.pickVerticesInSphere(picking.getLocalRadius2());
        picking.computePickedNormal();
      }
      // if dyn topo, we need to the picking and the sculpting altogether
      var dynTopo = mesh.getDynamicTopology && !this._lockPosition;
      if (dynTopo && pick1)
        this.stroke(picking, false);

      var pick2;
      if (pickingSym) {
        pickingSym.intersectionMouseMesh(mesh, mouseX, mouseY);
        pick2 = pickingSym.getMesh();
        if (pick2) {
          pickingSym.setLocalRadius2(picking.getLocalRadius2());
          pickingSym.pickVerticesInSphere(pickingSym.getLocalRadius2());
          pickingSym.computePickedNormal();
        }
      }

      if (!dynTopo && pick1) this.stroke(picking, false);
      if (pick2) this.stroke(pickingSym, true);
      return pick1 || pick2;
    },
    updateMeshBuffers: function () {
      var mesh = this.getMesh();
      if (mesh.getDynamicTopology)
        mesh.updateBuffers();
      else
        mesh.updateGeometryBuffers();
    },
    updateContinuous: function () {
      if (this._lockPosition) return this.update(true);
      var main = this._main;
      var picking = main.getPicking();
      var pickingSym = main.getSculpt().getSymmetry() ? main.getPickingSymmetry() : null;
      this.makeStroke(main._mouseX, main._mouseY, picking, pickingSym);
      this.updateRender();
    },
    /** Return the vertices that point toward the camera */
    getFrontVertices: function (iVertsInRadius, eyeDir) {
      var nbVertsSelected = iVertsInRadius.length;
      var iVertsFront = new Uint32Array(Utils.getMemory(4 * nbVertsSelected), 0, nbVertsSelected);
      var acc = 0;
      var nAr = this.getMesh().getNormals();
      var eyeX = eyeDir[0];
      var eyeY = eyeDir[1];
      var eyeZ = eyeDir[2];
      for (var i = 0; i < nbVertsSelected; ++i) {
        var id = iVertsInRadius[i];
        var j = id * 3;
        if ((nAr[j] * eyeX + nAr[j + 1] * eyeY + nAr[j + 2] * eyeZ) <= 0.0)
          iVertsFront[acc++] = id;
      }
      return new Uint32Array(iVertsFront.subarray(0, acc));
    },
    /** Compute average normal of a group of vertices with culling */
    areaNormal: function (iVerts) {
      var mesh = this.getMesh();
      var nAr = mesh.getNormals();
      var mAr = mesh.getMaterials();
      var anx = 0.0;
      var any = 0.0;
      var anz = 0.0;
      for (var i = 0, l = iVerts.length; i < l; ++i) {
        var ind = iVerts[i] * 3;
        var f = mAr[ind + 2];
        anx += nAr[ind] * f;
        any += nAr[ind + 1] * f;
        anz += nAr[ind + 2] * f;
      }
      var len = Math.sqrt(anx * anx + any * any + anz * anz);
      if (len === 0.0)
        return;
      len = 1.0 / len;
      return [anx * len, any * len, anz * len];
    },
    /** Compute average center of a group of vertices (with culling) */
    areaCenter: function (iVerts) {
      var mesh = this.getMesh();
      var vAr = mesh.getVertices();
      var mAr = mesh.getMaterials();
      var nbVerts = iVerts.length;
      var ax = 0.0;
      var ay = 0.0;
      var az = 0.0;
      var acc = 0;
      for (var i = 0; i < nbVerts; ++i) {
        var ind = iVerts[i] * 3;
        var f = mAr[ind + 2];
        acc += f;
        ax += vAr[ind] * f;
        ay += vAr[ind + 1] * f;
        az += vAr[ind + 2] * f;
      }
      return [ax / acc, ay / acc, az / acc];
    },
    /** Updates the vertices original coords that are sculpted for the first time in this stroke */
    updateProxy: function (iVerts) {
      var mesh = this.getMesh();
      var vAr = mesh.getVertices();
      var vProxy = mesh.getVerticesProxy();
      if (vAr === vProxy)
        return;
      var vertStateFlags = mesh.getVerticesStateFlags();
      var stateFlag = Utils.STATE_FLAG;
      for (var i = 0, l = iVerts.length; i < l; ++i) {
        var id = iVerts[i];
        if (vertStateFlags[id] !== stateFlag) {
          var ind = id * 3;
          vProxy[ind] = vAr[ind];
          vProxy[ind + 1] = vAr[ind + 1];
          vProxy[ind + 2] = vAr[ind + 2];
        }
      }
    },
    /** Laplacian smooth. Special rule for vertex on the edge of the mesh. */
    laplacianSmooth: function (iVerts, smoothVerts, vField) {
      var mesh = this.getMesh();
      var vrvStartCount = mesh.getVerticesRingVertStartCount();
      var vertRingVert = mesh.getVerticesRingVert();
      var ringVerts = vertRingVert instanceof Array ? vertRingVert : null;
      var vertOnEdge = mesh.getVerticesOnEdge();
      var vAr = vField || mesh.getVertices();
      var nbVerts = iVerts.length;
      for (var i = 0; i < nbVerts; ++i) {
        var i3 = i * 3;
        var id = iVerts[i];
        var start, end;
        if (ringVerts) {
          vertRingVert = ringVerts[id];
          start = 0;
          end = vertRingVert.length;
        } else {
          start = vrvStartCount[id * 2];
          end = start + vrvStartCount[id * 2 + 1];
        }
        var avx = 0.0;
        var avy = 0.0;
        var avz = 0.0;
        var j = 0;
        var ind = 0;
        if (vertOnEdge[id] === 1) {
          var nbVertEdge = 0;
          for (j = start; j < end; ++j) {
            ind = vertRingVert[j];
            // we average only with vertices that are also on the edge
            if (vertOnEdge[ind] === 1) {
              ind *= 3;
              avx += vAr[ind];
              avy += vAr[ind + 1];
              avz += vAr[ind + 2];
              ++nbVertEdge;
            }
          }
          if (nbVertEdge >= 2) {
            smoothVerts[i3] = avx / nbVertEdge;
            smoothVerts[i3 + 1] = avy / nbVertEdge;
            smoothVerts[i3 + 2] = avz / nbVertEdge;
            continue;
          }
          avx = avy = avz = 0.0;
        }
        for (j = start; j < end; ++j) {
          ind = vertRingVert[j] * 3;
          avx += vAr[ind];
          avy += vAr[ind + 1];
          avz += vAr[ind + 2];
        }
        j = end - start;
        smoothVerts[i3] = avx / j;
        smoothVerts[i3 + 1] = avy / j;
        smoothVerts[i3 + 2] = avz / j;
      }
    },
    dynamicTopology: function (picking) {
      var mesh = this.getMesh();
      var iVerts = picking.getPickedVertices();
      if (!mesh.getDynamicTopology)
        return iVerts;
      if (iVerts.length === 0) {
        iVerts = mesh.getVerticesFromFaces([picking.getPickedFace()]);
        // undo-redo
        this._states.pushVertices(iVerts);
      }

      var topo = mesh.getDynamicTopology();
      var subFactor = topo.getSubdivisionFactor();
      var decFactor = topo.getDecimationFactor();
      if (subFactor === 0.0 && decFactor === 0.0)
        return iVerts;

      var iFaces = mesh.getFacesFromVertices(iVerts);
      var radius2 = picking.getLocalRadius2();
      var center = picking.getIntersectionPoint();
      var d2Max = radius2 * (1.1 - subFactor) * 0.2;
      var d2Min = (d2Max / 4.2025) * decFactor;

      // undo-redo
      this._states.pushFaces(iFaces);

      if (subFactor)
        iFaces = topo.subdivision(iFaces, center, radius2, d2Max, this._states);
      if (decFactor)
        iFaces = topo.decimation(iFaces, center, radius2, d2Min, this._states);
      iVerts = mesh.getVerticesFromFaces(iFaces);

      var nbVerts = iVerts.length;
      var sculptFlag = Utils.SCULPT_FLAG;
      var vscf = mesh.getVerticesSculptFlags();
      var iVertsInRadius = new Uint32Array(Utils.getMemory(nbVerts * 4), 0, nbVerts);
      var acc = 0;
      for (var i = 0; i < nbVerts; ++i) {
        var iVert = iVerts[i];
        if (vscf[iVert] === sculptFlag)
          iVertsInRadius[acc++] = iVert;
      }
      iVertsInRadius = new Uint32Array(iVertsInRadius.subarray(0, acc));
      mesh.updateTopology(iFaces);
      mesh.updateGeometry(iFaces, iVertsInRadius);
      return iVertsInRadius;
    },
    getUnmaskedVertices: function () {
      return this.filterMaskedVertices(0.0, Infinity);
    },
    getMaskedVertices: function () {
      return this.filterMaskedVertices(-Infinity, 1.0);
    },
    filterMaskedVertices: function (lowerBound, upperBound) {
      var lb = lowerBound === undefined ? -Infinity : lowerBound;
      var ub = upperBound === undefined ? Infinity : upperBound;
      var mesh = this.getMesh();
      var mAr = mesh.getMaterials();
      var nbVertices = mesh.getNbVertices();
      var cleaned = new Uint32Array(Utils.getMemory(4 * nbVertices), 0, nbVertices);
      var acc = 0;
      for (var i = 0; i < nbVertices; ++i) {
        var mask = mAr[i * 3 + 2];
        if (mask > lb && mask < ub)
          cleaned[acc++] = i;
      }
      return new Uint32Array(cleaned.subarray(0, acc));
    },
    postRender: function () {},
    addSculptToScene: function () {},
    getScreenRadius: function () {
      return (this._radius || 1) * this._main.getPixelRatio();
    }
  };

  module.exports = SculptBase;
});
define('editing/tools/Flatten',['require','exports','module','misc/Utils','misc/Tablet','editing/tools/SculptBase'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var Tablet = require('misc/Tablet');
  var SculptBase = require('editing/tools/SculptBase');

  var Flatten = function (main) {
    SculptBase.call(this, main);
    this._radius = 50;
    this._intensity = 0.75;
    this._negative = true;
    this._culling = false;
    this._idAlpha = 0;
    this._lockPosition = false;
  };

  Flatten.prototype = {
    /** On stroke */
    stroke: function (picking) {
      var iVertsInRadius = picking.getPickedVertices();
      var intensity = this._intensity * Tablet.getPressureIntensity();

      // undo-redo
      this._states.pushVertices(iVertsInRadius);
      iVertsInRadius = this.dynamicTopology(picking);

      var iVertsFront = this.getFrontVertices(iVertsInRadius, picking.getEyeDirection());
      if (this._culling)
        iVertsInRadius = iVertsFront;

      var aNormal = this.areaNormal(iVertsFront);
      if (!aNormal)
        return;
      var aCenter = this.areaCenter(iVertsFront);
      picking.updateAlpha(this._lockPosition);
      picking.setIdAlpha(this._idAlpha);
      this.flatten(iVertsInRadius, aNormal, aCenter, picking.getIntersectionPoint(), picking.getLocalRadius2(), intensity, picking);

      var mesh = this.getMesh();
      mesh.updateGeometry(mesh.getFacesFromVertices(iVertsInRadius), iVertsInRadius);
    },
    /** Flatten, projection of the sculpting vertex onto a plane defined by the barycenter and normals of all the sculpting vertices */
    flatten: function (iVertsInRadius, aNormal, aCenter, center, radiusSquared, intensity, picking) {
      var mesh = this.getMesh();
      var vAr = mesh.getVertices();
      var mAr = mesh.getMaterials();
      var radius = Math.sqrt(radiusSquared);
      var vProxy = this._accumulate === false && this._lockPosition === false ? mesh.getVerticesProxy() : vAr;
      var cx = center[0];
      var cy = center[1];
      var cz = center[2];
      var ax = aCenter[0];
      var ay = aCenter[1];
      var az = aCenter[2];
      var anx = aNormal[0];
      var any = aNormal[1];
      var anz = aNormal[2];
      var comp = this._negative ? -1.0 : 1.0;
      for (var i = 0, l = iVertsInRadius.length; i < l; ++i) {
        var ind = iVertsInRadius[i] * 3;
        var vx = vAr[ind];
        var vy = vAr[ind + 1];
        var vz = vAr[ind + 2];
        var distToPlane = (vx - ax) * anx + (vy - ay) * any + (vz - az) * anz;
        if (distToPlane * comp > 0.0)
          continue;
        var dx = vProxy[ind] - cx;
        var dy = vProxy[ind + 1] - cy;
        var dz = vProxy[ind + 2] - cz;
        var dist = Math.sqrt(dx * dx + dy * dy + dz * dz) / radius;
        if (dist >= 1.0)
          continue;
        var fallOff = dist * dist;
        fallOff = 3.0 * fallOff * fallOff - 4.0 * fallOff * dist + 1.0;
        fallOff *= distToPlane * intensity * mAr[ind + 2] * picking.getAlpha(vx, vy, vz);
        vAr[ind] -= anx * fallOff;
        vAr[ind + 1] -= any * fallOff;
        vAr[ind + 2] -= anz * fallOff;
      }
    },
  };

  Utils.makeProxy(SculptBase, Flatten);

  module.exports = Flatten;
});
define('editing/tools/Brush',['require','exports','module','lib/glMatrix','misc/Utils','misc/Tablet','editing/tools/SculptBase','editing/tools/Flatten'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Utils = require('misc/Utils');
  var Tablet = require('misc/Tablet');
  var SculptBase = require('editing/tools/SculptBase');
  var Flatten = require('editing/tools/Flatten');

  var vec3 = glm.vec3;

  var Brush = function (main) {
    SculptBase.call(this, main);
    this._radius = 50;
    this._intensity = 0.5;
    this._negative = false;
    this._clay = true;
    this._culling = false;
    this._accumulate = true; // if we ignore the proxy
    this._idAlpha = 0;
    this._lockPosition = false;
  };

  Brush.prototype = {
    stroke: function (picking) {
      var iVertsInRadius = picking.getPickedVertices();
      var intensity = this._intensity * Tablet.getPressureIntensity();

      if (!this._accumulate && !this._lockPosition)
        this.updateProxy(iVertsInRadius);
      // undo-redo
      this._states.pushVertices(iVertsInRadius);
      if (!this._lockPosition)
        iVertsInRadius = this.dynamicTopology(picking);

      var iVertsFront = this.getFrontVertices(iVertsInRadius, picking.getEyeDirection());
      if (this._culling)
        iVertsInRadius = iVertsFront;

      var r2 = picking.getLocalRadius2();
      picking.updateAlpha(this._lockPosition);
      picking.setIdAlpha(this._idAlpha);

      if (!this._clay) {
        this.brush(iVertsInRadius, picking.getPickedNormal(), picking.getIntersectionPoint(), r2, intensity, picking);
      } else {
        var aNormal = this.areaNormal(iVertsFront);
        if (!aNormal)
          return;
        var aCenter = this._lockPosition ? picking.getIntersectionPoint() : this.areaCenter(iVertsFront);
        var off = Math.sqrt(r2) * 0.1;
        vec3.scaleAndAdd(aCenter, aCenter, aNormal, this._negative ? -off : off);
        Flatten.prototype.flatten.call(this, iVertsInRadius, aNormal, aCenter, picking.getIntersectionPoint(), r2, intensity, picking);
      }

      var mesh = this.getMesh();
      mesh.updateGeometry(mesh.getFacesFromVertices(iVertsInRadius), iVertsInRadius);
    },
    brush: function (iVertsInRadius, aNormal, center, radiusSquared, intensity, picking) {
      var mesh = this.getMesh();
      var vAr = mesh.getVertices();
      var mAr = mesh.getMaterials();
      var vProxy = this._accumulate || this._lockPosition ? vAr : mesh.getVerticesProxy();
      var radius = Math.sqrt(radiusSquared);
      var deformIntensityBrush = intensity * radius * 0.1;
      if (this._negative)
        deformIntensityBrush = -deformIntensityBrush;
      var cx = center[0];
      var cy = center[1];
      var cz = center[2];
      var anx = aNormal[0];
      var any = aNormal[1];
      var anz = aNormal[2];
      for (var i = 0, l = iVertsInRadius.length; i < l; ++i) {
        var ind = iVertsInRadius[i] * 3;
        var dx = vProxy[ind] - cx;
        var dy = vProxy[ind + 1] - cy;
        var dz = vProxy[ind + 2] - cz;
        var dist = Math.sqrt(dx * dx + dy * dy + dz * dz) / radius;
        if (dist >= 1.0)
          continue;
        var vx = vAr[ind];
        var vy = vAr[ind + 1];
        var vz = vAr[ind + 2];
        var fallOff = dist * dist;
        fallOff = 3.0 * fallOff * fallOff - 4.0 * fallOff * dist + 1.0;
        fallOff *= mAr[ind + 2] * deformIntensityBrush * picking.getAlpha(vx, vy, vz);
        vAr[ind] = vx + anx * fallOff;
        vAr[ind + 1] = vy + any * fallOff;
        vAr[ind + 2] = vz + anz * fallOff;
      }
    }
  };

  Utils.makeProxy(SculptBase, Brush);

  module.exports = Brush;
});
define('editing/tools/Smooth',['require','exports','module','misc/Utils','misc/Tablet','editing/tools/SculptBase'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var Tablet = require('misc/Tablet');
  var SculptBase = require('editing/tools/SculptBase');

  var Smooth = function (main) {
    SculptBase.call(this, main);
    this._radius = 50;
    this._intensity = 0.75;
    this._culling = false;
    this._tangent = false;
    this._idAlpha = 0;
    this._lockPosition = false;
  };

  Smooth.prototype = {
    /** On stroke */
    stroke: function (picking) {
      var iVertsInRadius = picking.getPickedVertices();
      var intensity = this._intensity * Tablet.getPressureIntensity();

      // undo-redo
      this._states.pushVertices(iVertsInRadius);

      if (this._culling)
        iVertsInRadius = this.getFrontVertices(iVertsInRadius, picking.getEyeDirection());

      picking.updateAlpha(this._lockPosition);
      picking.setIdAlpha(this._idAlpha);
      if (this._tangent) this.smoothTangent(iVertsInRadius, intensity, picking);
      else this.smooth(iVertsInRadius, intensity, picking);

      var mesh = this.getMesh();
      mesh.updateGeometry(mesh.getFacesFromVertices(iVertsInRadius), iVertsInRadius);
    },
    /** Smooth a group of vertices. New position is given by simple averaging */
    smooth: function (iVerts, intensity, picking) {
      var mesh = this.getMesh();
      var vAr = mesh.getVertices();
      var mAr = mesh.getMaterials();
      var nbVerts = iVerts.length;
      var smoothVerts = new Float32Array(nbVerts * 3);
      this.laplacianSmooth(iVerts, smoothVerts);
      for (var i = 0; i < nbVerts; ++i) {
        var ind = iVerts[i] * 3;
        var vx = vAr[ind];
        var vy = vAr[ind + 1];
        var vz = vAr[ind + 2];
        var i3 = i * 3;
        var mIntensity = intensity * mAr[ind + 2];
        if (picking)
          mIntensity *= picking.getAlpha(vx, vy, vz);
        var intComp = 1.0 - mIntensity;
        vAr[ind] = vx * intComp + smoothVerts[i3] * mIntensity;
        vAr[ind + 1] = vy * intComp + smoothVerts[i3 + 1] * mIntensity;
        vAr[ind + 2] = vz * intComp + smoothVerts[i3 + 2] * mIntensity;
      }
    },
    /** Smooth a group of vertices. Reproject the position on each vertex normals plane */
    smoothTangent: function (iVerts, intensity, picking) {
      var mesh = this.getMesh();
      var vAr = mesh.getVertices();
      var mAr = mesh.getMaterials();
      var nAr = mesh.getNormals();
      var nbVerts = iVerts.length;
      var smoothVerts = new Float32Array(nbVerts * 3);
      this.laplacianSmooth(iVerts, smoothVerts);
      for (var i = 0; i < nbVerts; ++i) {
        var ind = iVerts[i] * 3;
        var vx = vAr[ind];
        var vy = vAr[ind + 1];
        var vz = vAr[ind + 2];
        var nx = nAr[ind];
        var ny = nAr[ind + 1];
        var nz = nAr[ind + 2];
        var len = nx * nx + ny * ny + nz * nz;
        if (len === 0.0)
          continue;
        len = 1.0 / Math.sqrt(len);
        nx *= len;
        ny *= len;
        nz *= len;
        var i3 = i * 3;
        var smx = smoothVerts[i3];
        var smy = smoothVerts[i3 + 1];
        var smz = smoothVerts[i3 + 2];
        var dot = nx * (smx - vx) + ny * (smy - vy) + nz * (smz - vz);
        var mIntensity = intensity * mAr[ind + 2];
        if (picking)
          mIntensity *= picking.getAlpha(vx, vy, vz);
        vAr[ind] = vx + (smx - nx * dot - vx) * mIntensity;
        vAr[ind + 1] = vy + (smy - ny * dot - vy) * mIntensity;
        vAr[ind + 2] = vz + (smz - nz * dot - vz) * mIntensity;
      }
    },
    /** Smooth a group of vertices along their normals */
    smoothAlongNormals: function (iVerts, intensity, picking) {
      var mesh = this.getMesh();
      var vAr = mesh.getVertices();
      var mAr = mesh.getMaterials();
      var nAr = mesh.getNormals();
      var nbVerts = iVerts.length;
      var smoothVerts = new Float32Array(nbVerts * 3);
      this.laplacianSmooth(iVerts, smoothVerts);
      for (var i = 0; i < nbVerts; ++i) {
        var ind = iVerts[i] * 3;
        var vx = vAr[ind];
        var vy = vAr[ind + 1];
        var vz = vAr[ind + 2];
        var nx = nAr[ind];
        var ny = nAr[ind + 1];
        var nz = nAr[ind + 2];
        var i3 = i * 3;
        var len = 1.0 / ((nx * nx + ny * ny + nz * nz));
        var dot = nx * (smoothVerts[i3] - vx) + ny * (smoothVerts[i3 + 1] - vy) + nz * (smoothVerts[i3 + 2] - vz);
        dot *= len * intensity * mAr[ind + 2];
        if (picking)
          dot *= picking.getAlpha(vx, vy, vz);
        vAr[ind] = vx + nx * dot;
        vAr[ind + 1] = vy + ny * dot;
        vAr[ind + 2] = vz + nz * dot;
      }
    },
  };

  Utils.makeProxy(SculptBase, Smooth);

  module.exports = Smooth;
});
define('editing/tools/Inflate',['require','exports','module','misc/Utils','misc/Tablet','editing/tools/SculptBase','editing/tools/Smooth'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var Tablet = require('misc/Tablet');
  var SculptBase = require('editing/tools/SculptBase');
  var Smooth = require('editing/tools/Smooth');

  var Inflate = function (main) {
    SculptBase.call(this, main);
    this._radius = 50;
    this._intensity = 0.3;
    this._negative = false;
    this._culling = false;
    this._idAlpha = 0;
    this._lockPosition = false;
  };

  Inflate.prototype = {
    /** On stroke */
    stroke: function (picking) {
      var iVertsInRadius = picking.getPickedVertices();
      var intensity = this._intensity * Tablet.getPressureIntensity();

      this.updateProxy(iVertsInRadius);
      // undo-redo
      this._states.pushVertices(iVertsInRadius);
      iVertsInRadius = this.dynamicTopology(picking);

      if (this._culling)
        iVertsInRadius = this.getFrontVertices(iVertsInRadius, picking.getEyeDirection());

      picking.updateAlpha(this._lockPosition);
      picking.setIdAlpha(this._idAlpha);
      this.inflate(iVertsInRadius, picking.getIntersectionPoint(), picking.getLocalRadius2(), intensity, picking);
      Smooth.prototype.smoothTangent.call(this, iVertsInRadius, 1.0, picking);

      var mesh = this.getMesh();
      mesh.updateGeometry(mesh.getFacesFromVertices(iVertsInRadius), iVertsInRadius);
    },
    /** Inflate a group of vertices */
    inflate: function (iVerts, center, radiusSquared, intensity, picking) {
      var mesh = this.getMesh();
      var vAr = mesh.getVertices();
      var mAr = mesh.getMaterials();
      var vProxy = mesh.getVerticesProxy();
      var nAr = mesh.getNormals();
      var radius = Math.sqrt(radiusSquared);
      var deformIntensity = intensity * radius * 0.1;
      if (this._negative)
        deformIntensity = -deformIntensity;
      var cx = center[0];
      var cy = center[1];
      var cz = center[2];
      for (var i = 0, l = iVerts.length; i < l; ++i) {
        var ind = iVerts[i] * 3;
        var dx = vProxy[ind] - cx;
        var dy = vProxy[ind + 1] - cy;
        var dz = vProxy[ind + 2] - cz;
        var dist = Math.sqrt(dx * dx + dy * dy + dz * dz) / radius;
        if (dist >= 1.0)
          continue;
        var fallOff = dist * dist;
        fallOff = 3.0 * fallOff * fallOff - 4.0 * fallOff * dist + 1.0;
        fallOff = deformIntensity * fallOff;
        var vx = vAr[ind];
        var vy = vAr[ind + 1];
        var vz = vAr[ind + 2];
        var nx = nAr[ind];
        var ny = nAr[ind + 1];
        var nz = nAr[ind + 2];
        fallOff /= Math.sqrt(nx * nx + ny * ny + nz * nz);
        fallOff *= mAr[ind + 2] * picking.getAlpha(vx, vy, vz);
        vAr[ind] = vx + nx * fallOff;
        vAr[ind + 1] = vy + ny * fallOff;
        vAr[ind + 2] = vz + nz * fallOff;
      }
    }
  };

  Utils.makeProxy(SculptBase, Inflate);

  module.exports = Inflate;
});
define('math3d/Geometry',['require','exports','module','lib/glMatrix'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');

  var vec3 = glm.vec3;

  var Geometry = {};

  /** Normalize coordinate mouse between -1 and 1 */
  Geometry.normalizedMouse = function (mouseX, mouseY, width, height) {
    return [(2.0 * mouseX / width) - 1.0, 1.0 - (2.0 * mouseY / height)];
  };

  Geometry.reflect = function (vec, nor) {
    var d = vec3.dot(vec, nor);
    vec[0] -= 2 * d * nor[0];
    vec[1] -= 2 * d * nor[1];
    vec[2] -= 2 * d * nor[2];
    return vec;
  };

  /** Projection of mouse coordinate on sphere unit */
  Geometry.mouseOnUnitSphere = function (mouseXY) {
    var mouseX = mouseXY[0];
    var mouseY = mouseXY[1];
    var tempZ = 1.0 - mouseX * mouseX - mouseY * mouseY;
    var mouseZ = tempZ > 0.0 ? Math.sqrt(tempZ) : 0.0;
    var sourisSphere = [mouseX, mouseY, mouseZ];
    return vec3.normalize(sourisSphere, sourisSphere);
  };

  /** Compute intersection between a ray and a triangle. Returne the distance to the triangle if a hit occurs. */
  Geometry.intersectionRayTriangleEdges = (function () {
    var EPSILON = 1E-15;
    // hmm we favor false positive just in case...
    // mainly because of the voxel-remesh that can do weird things
    // if the ray casting fail on a border of a triangle 
    var ONE_PLUS_EPSILON = 1.0 + EPSILON;
    var ZERO_MINUS_EPSILON = 0.0 - EPSILON;
    var pvec = [0.0, 0.0, 0.0];
    var tvec = [0.0, 0.0, 0.0];
    var qvec = [0.0, 0.0, 0.0];
    return function (orig, dir, edge1, edge2, v1, vertInter) {
      // moller trumbore intersection algorithm
      vec3.cross(pvec, dir, edge2);
      var det = vec3.dot(edge1, pvec);
      if (det > -EPSILON && det < EPSILON)
        return -1.0;
      var invDet = 1.0 / det;
      vec3.sub(tvec, orig, v1);
      var u = vec3.dot(tvec, pvec) * invDet;
      if (u < ZERO_MINUS_EPSILON || u > ONE_PLUS_EPSILON)
        return -1.0;
      vec3.cross(qvec, tvec, edge1);
      var v = vec3.dot(dir, qvec) * invDet;
      if (v < ZERO_MINUS_EPSILON || u + v > ONE_PLUS_EPSILON)
        return -1.0;
      var t = vec3.dot(edge2, qvec) * invDet;
      if (t < ZERO_MINUS_EPSILON)
        return -1.0;
      if (vertInter)
        vec3.scaleAndAdd(vertInter, orig, dir, t);
      return t;
    };
  })();

  /** Compute intersection between a ray and a triangle. Returne the distance to the triangle if a hit occurs. */
  Geometry.intersectionRayTriangle = (function () {
    var edge1 = [0.0, 0.0, 0.0];
    var edge2 = [0.0, 0.0, 0.0];
    return function (orig, dir, v1, v2, v3, vertInter) {
      vec3.sub(edge1, v2, v1);
      vec3.sub(edge2, v3, v1);
      return Geometry.intersectionRayTriangleEdges(orig, dir, edge1, edge2, v1, vertInter);
    };
  })();

  //
  // \2|
  //  \|
  //   \
  // 3 |\  1
  //   |0\
  // __|__\___
  // 4 | 5 \ 6
  /** Compute distance between a point and a triangle. */
  Geometry.distance2PointTriangleEdges = (function () {
    var diff = [0.0, 0.0, 0.0];
    return function (point, edge1, edge2, v1, a00, a01, a11, closest) {

      vec3.sub(diff, v1, point);
      var b0 = vec3.dot(diff, edge1);
      var b1 = vec3.dot(diff, edge2);
      var c = vec3.sqrLen(diff);
      var det = Math.abs(a00 * a11 - a01 * a01);
      var s = a01 * b1 - a11 * b0;
      var t = a01 * b0 - a00 * b1;
      var sqrDistance;
      var zone = 4;

      if (s + t <= det) {
        if (s < 0.0) {
          if (t < 0.0) { // region 4
            zone = 4;
            if (b0 < 0.0) {
              t = 0.0;
              if (-b0 >= a00) {
                s = 1.0;
                sqrDistance = a00 + 2.0 * b0 + c;
              } else {
                s = -b0 / a00;
                sqrDistance = b0 * s + c;
              }
            } else {
              s = 0.0;
              if (b1 >= 0.0) {
                t = 0.0;
                sqrDistance = c;
              } else if (-b1 >= a11) {
                t = 1.0;
                sqrDistance = a11 + 2.0 * b1 + c;
              } else {
                t = -b1 / a11;
                sqrDistance = b1 * t + c;
              }
            }
          } else { // region 3
            zone = 3;
            s = 0.0;
            if (b1 >= 0.0) {
              t = 0.0;
              sqrDistance = c;
            } else if (-b1 >= a11) {
              t = 1.0;
              sqrDistance = a11 + 2.0 * b1 + c;
            } else {
              t = -b1 / a11;
              sqrDistance = b1 * t + c;
            }
          }
        } else if (t < 0.0) { // region 5
          zone = 5;
          t = 0.0;
          if (b0 >= 0.0) {
            s = 0.0;
            sqrDistance = c;
          } else if (-b0 >= a00) {
            s = 1.0;
            sqrDistance = a00 + 2.0 * b0 + c;
          } else {
            s = -b0 / a00;
            sqrDistance = b0 * s + c;
          }
        } else { // region 0
          zone = 0;
          // minimum at interior point
          var invDet = 1.0 / det;
          s *= invDet;
          t *= invDet;
          sqrDistance = s * (a00 * s + a01 * t + 2.0 * b0) + t * (a01 * s + a11 * t + 2.0 * b1) + c;
        }
      } else {
        var tmp0, tmp1, numer, denom;

        if (s < 0.0) { // region 2
          zone = 2;
          tmp0 = a01 + b0;
          tmp1 = a11 + b1;
          if (tmp1 > tmp0) {
            numer = tmp1 - tmp0;
            denom = a00 - 2.0 * a01 + a11;
            if (numer >= denom) {
              s = 1.0;
              t = 0.0;
              sqrDistance = a00 + 2.0 * b0 + c;
            } else {
              s = numer / denom;
              t = 1.0 - s;
              sqrDistance = s * (a00 * s + a01 * t + 2.0 * b0) + t * (a01 * s + a11 * t + 2.0 * b1) + c;
            }
          } else {
            s = 0.0;
            if (tmp1 <= 0.0) {
              t = 1.0;
              sqrDistance = a11 + 2.0 * b1 + c;
            } else if (b1 >= 0.0) {
              t = 0.0;
              sqrDistance = c;
            } else {
              t = -b1 / a11;
              sqrDistance = b1 * t + c;
            }
          }
        } else if (t < 0.0) { // region 6
          zone = 6;
          tmp0 = a01 + b1;
          tmp1 = a00 + b0;
          if (tmp1 > tmp0) {
            numer = tmp1 - tmp0;
            denom = a00 - 2.0 * a01 + a11;
            if (numer >= denom) {
              t = 1.0;
              s = 0.0;
              sqrDistance = a11 + 2.0 * b1 + c;
            } else {
              t = numer / denom;
              s = 1.0 - t;
              sqrDistance = s * (a00 * s + a01 * t + 2.0 * b0) + t * (a01 * s + a11 * t + 2.0 * b1) + c;
            }
          } else {
            t = 0.0;
            if (tmp1 <= 0.0) {
              s = 1.0;
              sqrDistance = a00 + 2.0 * b0 + c;
            } else if (b0 >= 0.0) {
              s = 0.0;
              sqrDistance = c;
            } else {
              s = -b0 / a00;
              sqrDistance = b0 * s + c;
            }
          }
        } else { // region 1
          zone = 1;
          numer = a11 + b1 - a01 - b0;
          if (numer <= 0.0) {
            s = 0.0;
            t = 1.0;
            sqrDistance = a11 + 2.0 * b1 + c;
          } else {
            denom = a00 - 2.0 * a01 + a11;
            if (numer >= denom) {
              s = 1.0;
              t = 0.0;
              sqrDistance = a00 + 2.0 * b0 + c;
            } else {
              s = numer / denom;
              t = 1.0 - s;
              sqrDistance = s * (a00 * s + a01 * t + 2.0 * b0) + t * (a01 * s + a11 * t + 2.0 * b1) + c;
            }
          }
        }
      }

      // Account for numerical round-off error.
      if (sqrDistance < 0.0)
        sqrDistance = 0.0;

      if (closest) {
        closest[0] = v1[0] + s * edge1[0] + t * edge2[0];
        closest[1] = v1[1] + s * edge1[1] + t * edge2[1];
        closest[2] = v1[2] + s * edge1[2] + t * edge2[2];
        closest[3] = zone;
      }
      return sqrDistance;
    };
  })();

  /** Compute distance between a point and a triangle. */
  Geometry.distance2PointTriangle = (function () {
    var edge1 = [0.0, 0.0, 0.0];
    var edge2 = [0.0, 0.0, 0.0];
    return function (point, v1, v2, v3, closest) {
      vec3.sub(edge1, v2, v1);
      vec3.sub(edge2, v3, v1);
      var a00 = vec3.sqrLen(edge1);
      var a01 = vec3.dot(edge1, edge2);
      var a11 = vec3.sqrLen(edge2);
      return Geometry.distance2PointTriangleEdges(point, edge1, edge2, v1, a00, a01, a11, closest);
    };
  })();

  /** If point is inside the triangle, test the sum of the areas */
  Geometry.pointInsideTriangle = (function () {
    var vec1 = [0.0, 0.0, 0.0];
    var vec2 = [0.0, 0.0, 0.0];
    var vecP1 = [0.0, 0.0, 0.0];
    var vecP2 = [0.0, 0.0, 0.0];
    var temp = [0.0, 0.0, 0.0];
    return function (point, v1, v2, v3) {
      vec3.sub(vec1, v1, v2);
      vec3.sub(vec2, v1, v3);
      vec3.sub(vecP1, point, v2);
      vec3.sub(vecP2, point, v3);
      var total = vec3.len(vec3.cross(temp, vec1, vec2));
      var area1 = vec3.len(vec3.cross(temp, vec1, vecP1));
      var area2 = vec3.len(vec3.cross(temp, vec2, vecP2));
      var area3 = vec3.len(vec3.cross(temp, vecP1, vecP2));
      return Math.abs(total - (area1 + area2 + area3)) < 1E-20;
    };
  })();

  /** If a sphere intersect a triangle */
  Geometry.triangleInsideSphere = function (point, radiusSq, v1, v2, v3) {
    if (Geometry.distanceSqToSegment(point, v1, v2) < radiusSq) return true;
    if (Geometry.distanceSqToSegment(point, v2, v3) < radiusSq) return true;
    if (Geometry.distanceSqToSegment(point, v1, v3) < radiusSq) return true;
    return false;
  };

  /** Minimum squared distance to a segment */
  Geometry.distanceSqToSegment = (function () {
    var pt = [0.0, 0.0, 0.0];
    var v2v1 = [0.0, 0.0, 0.0];
    return function (point, v1, v2) {
      vec3.sub(pt, point, v1);
      vec3.sub(v2v1, v2, v1);
      var len = vec3.sqrLen(v2v1);
      var t = vec3.dot(pt, v2v1) / len;
      if (t < 0.0) return vec3.sqrLen(pt);
      if (t > 1.0) return vec3.sqrLen(vec3.sub(pt, point, v2));

      pt[0] = point[0] - v1[0] - t * v2v1[0];
      pt[1] = point[1] - v1[1] - t * v2v1[1];
      pt[2] = point[2] - v1[2] - t * v2v1[2];
      return vec3.sqrLen(pt);
    };
  })();

  /** Sign angle between two 2d vectors in radians */
  Geometry.signedAngle2d = function (v1, v2) {
    var v1x = v1[0],
      v1y = v1[1],
      v2x = v2[0],
      v2y = v2[1];
    return Math.atan2(v1x * v2y - v1y * v2x, v1x * v2x + v1y * v2y);
  };

  /** Distance from a vertex and a plane */
  Geometry.pointPlaneDistance = (function () {
    var temp = [0.0, 0.0, 0.0];
    return function (v, ptPlane, nPlane) {
      return vec3.dot(vec3.sub(temp, v, ptPlane), nPlane);
    };
  })();

  /** Mirror a vertex according to a plane */
  Geometry.mirrorPoint = (function () {
    var temp = [0.0, 0.0, 0.0];
    return function (v, ptPlane, nPlane) {
      return vec3.sub(v, v, vec3.scale(temp, nPlane, Geometry.pointPlaneDistance(v, ptPlane, nPlane) * 2.0));
    };
  })();

  /** Compute the projection of a vertex on a line */
  Geometry.vertexOnLine = (function () {
    var ab = [0.0, 0.0, 0.0];
    return function (vertex, vNear, vFar) {
      vec3.sub(ab, vFar, vNear);
      var proj = [0.0, 0.0, 0.0];
      var dot = vec3.dot(ab, vec3.sub(proj, vertex, vNear));
      return vec3.scaleAndAdd(proj, vNear, ab, dot / vec3.sqrLen(ab));
    };
  })();

  /** Return the intersection between a ray and a plane */
  Geometry.intersectLinePlane = function (s1, s2, origin, normal, out) {
    var dist1 = vec3.dot(vec3.sub(out, s1, origin), normal);
    var dist2 = vec3.dot(vec3.sub(out, s2, origin), normal);
    // ray copplanar to triangle
    if (dist1 === dist2)
      return s2;
    // intersection between ray and triangle
    var val = -dist1 / (dist2 - dist1);
    return vec3.scaleAndAdd(out, s1, vec3.sub(out, s2, s1), val);
  };

  /** Return any perpendicular vector to another (normalized) vector */
  Geometry.getPerpendicularVector = function (vec) {
    var perp = [0.0, 0.0, 0.0];
    if (vec[0] === 0.0)
      perp[0] = 1.0;
    else if (vec[1] === 0.0)
      perp[1] = 1.0;
    else if (vec[2] === 0.0)
      perp[2] = 1.0;
    else {
      perp[0] = vec[2];
      perp[1] = vec[2];
      perp[2] = -vec[0] - vec[1];
      vec3.normalize(perp, perp);
    }
    return perp;
  };

  module.exports = Geometry;
});
define('editing/tools/Twist',['require','exports','module','lib/glMatrix','misc/Utils','math3d/Geometry','editing/tools/SculptBase'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Utils = require('misc/Utils');
  var Geometry = require('math3d/Geometry');
  var SculptBase = require('editing/tools/SculptBase');

  var vec2 = glm.vec2;
  var vec3 = glm.vec3;
  var quat = glm.quat;

  var Twist = function (main) {
    SculptBase.call(this, main);
    this._radius = 75;
    this._culling = false;
    this._twistData = {
      normal: [0.0, 0.0, 0.0], // normal of rotation plane
      center: [0.0, 0.0] // 2D center of rotation 
    };
    this._twistDataSym = {
      normal: [0.0, 0.0, 0.0], // normal of rotation plane
      center: [0.0, 0.0] // 2D center of rotation 
    };
    this._idAlpha = 0;
  };

  Twist.prototype = {
    /** Start a twist sculpt stroke */
    startSculpt: function () {
      var main = this._main;
      var mouseX = main._mouseX;
      var mouseY = main._mouseY;
      var picking = main.getPicking();
      this.initTwistData(picking, mouseX, mouseY, this._twistData);
      if (main.getSculpt().getSymmetry()) {
        var pickingSym = main.getPickingSymmetry();
        pickingSym.intersectionMouseMesh();
        pickingSym.setLocalRadius2(picking.getLocalRadius2());
        if (pickingSym.getMesh())
          this.initTwistData(pickingSym, mouseX, mouseY, this._twistDataSym);
      }
    },
    /** Set a few infos that will be needed for the twist function afterwards */
    initTwistData: function (picking, mouseX, mouseY, twistData) {
      picking.pickVerticesInSphere(picking.getLocalRadius2());
      vec3.negate(twistData.normal, picking.getEyeDirection());
      vec2.set(twistData.center, mouseX, mouseY);
    },
    /** Make a brush twist stroke */
    sculptStroke: function () {
      var main = this._main;
      var mx = main._mouseX;
      var my = main._mouseY;
      var lx = main._lastMouseX;
      var ly = main._lastMouseY;
      var picking = main.getPicking();
      var rLocal2 = picking.getLocalRadius2();
      picking.pickVerticesInSphere(rLocal2);
      this.stroke(picking, mx, my, lx, ly, this._twistData);

      if (main.getSculpt().getSymmetry()) {
        var pickingSym = main.getPickingSymmetry();
        if (pickingSym.getMesh()) {
          pickingSym.pickVerticesInSphere(rLocal2);
          this.stroke(pickingSym, lx, ly, mx, my, this._twistDataSym);
        }
      }
      this.updateRender();
      main.setCanvasCursor('default');
    },
    /** On stroke */
    stroke: function (picking, mx, my, lx, ly, twistData) {
      var iVertsInRadius = picking.getPickedVertices();

      // undo-redo
      this._states.pushVertices(iVertsInRadius);
      iVertsInRadius = this.dynamicTopology(picking);

      if (this._culling)
        iVertsInRadius = this.getFrontVertices(iVertsInRadius, picking.getEyeDirection());

      picking.updateAlpha(false);
      picking.setIdAlpha(this._idAlpha);
      this.twist(iVertsInRadius, picking.getIntersectionPoint(), picking.getLocalRadius2(), mx, my, lx, ly, twistData, picking);

      var mesh = this.getMesh();
      mesh.updateGeometry(mesh.getFacesFromVertices(iVertsInRadius), iVertsInRadius);
    },
    /** Twist the vertices around the mouse point intersection */
    twist: function (iVerts, center, radiusSquared, mouseX, mouseY, lastMouseX, lastMouseY, twistData, picking) {
      var mesh = this.getMesh();
      var mouseCenter = twistData.center;
      var vecMouse = [mouseX - mouseCenter[0], mouseY - mouseCenter[1]];
      if (vec2.len(vecMouse) < 30)
        return;
      vec2.normalize(vecMouse, vecMouse);
      var nPlane = twistData.normal;
      var rot = [0.0, 0.0, 0.0, 0.0];
      var vecOldMouse = [lastMouseX - mouseCenter[0], lastMouseY - mouseCenter[1]];
      vec2.normalize(vecOldMouse, vecOldMouse);
      var angle = Geometry.signedAngle2d(vecMouse, vecOldMouse);
      var vAr = mesh.getVertices();
      var mAr = mesh.getMaterials();
      var invRadius = 1.0 / Math.sqrt(radiusSquared);
      var cx = center[0];
      var cy = center[1];
      var cz = center[2];
      var coord = [0.0, 0.0, 0.0];
      for (var i = 0, l = iVerts.length; i < l; ++i) {
        var ind = iVerts[i] * 3;
        var vx = vAr[ind];
        var vy = vAr[ind + 1];
        var vz = vAr[ind + 2];
        var dx = vx - cx;
        var dy = vy - cy;
        var dz = vz - cz;
        var dist = Math.sqrt(dx * dx + dy * dy + dz * dz) * invRadius;
        var fallOff = dist * dist;
        fallOff = 3.0 * fallOff * fallOff - 4.0 * fallOff * dist + 1.0;
        fallOff *= angle * mAr[ind + 2] * picking.getAlpha(vx, vy, vz);
        quat.setAxisAngle(rot, nPlane, fallOff);
        vec3.set(coord, vx, vy, vz);
        vec3.sub(coord, coord, center);
        vec3.transformQuat(coord, coord, rot);
        vec3.add(coord, coord, center);
        vAr[ind] = coord[0];
        vAr[ind + 1] = coord[1];
        vAr[ind + 2] = coord[2];
      }
    }
  };

  Utils.makeProxy(SculptBase, Twist);

  module.exports = Twist;
});
define('editing/tools/Pinch',['require','exports','module','misc/Utils','misc/Tablet','editing/tools/SculptBase'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var Tablet = require('misc/Tablet');
  var SculptBase = require('editing/tools/SculptBase');

  var Pinch = function (main) {
    SculptBase.call(this, main);
    this._radius = 50;
    this._intensity = 0.75;
    this._negative = false;
    this._culling = false;
    this._idAlpha = 0;
    this._lockPosition = false;
  };

  Pinch.prototype = {
    /** On stroke */
    stroke: function (picking) {
      var iVertsInRadius = picking.getPickedVertices();
      var intensity = this._intensity * Tablet.getPressureIntensity();

      // undo-redo
      this._states.pushVertices(iVertsInRadius);
      iVertsInRadius = this.dynamicTopology(picking);

      if (this._culling)
        iVertsInRadius = this.getFrontVertices(iVertsInRadius, picking.getEyeDirection());

      picking.updateAlpha(this._lockPosition);
      picking.setIdAlpha(this._idAlpha);
      this.pinch(iVertsInRadius, picking.getIntersectionPoint(), picking.getLocalRadius2(), intensity, picking);

      var mesh = this.getMesh();
      mesh.updateGeometry(mesh.getFacesFromVertices(iVertsInRadius), iVertsInRadius);
    },
    /** Pinch, vertices gather around intersection point */
    pinch: function (iVertsInRadius, center, radiusSquared, intensity, picking) {
      var mesh = this.getMesh();
      var vAr = mesh.getVertices();
      var mAr = mesh.getMaterials();
      var radius = Math.sqrt(radiusSquared);
      var cx = center[0];
      var cy = center[1];
      var cz = center[2];
      var deformIntensity = intensity * 0.05;
      if (this._negative)
        deformIntensity = -deformIntensity;
      for (var i = 0, l = iVertsInRadius.length; i < l; ++i) {
        var ind = iVertsInRadius[i] * 3;
        var vx = vAr[ind];
        var vy = vAr[ind + 1];
        var vz = vAr[ind + 2];
        var dx = cx - vx;
        var dy = cy - vy;
        var dz = cz - vz;
        var dist = Math.sqrt(dx * dx + dy * dy + dz * dz) / radius;
        var fallOff = dist * dist;
        fallOff = 3.0 * fallOff * fallOff - 4.0 * fallOff * dist + 1.0;
        fallOff *= deformIntensity * mAr[ind + 2] * picking.getAlpha(vx, vy, vz);
        vAr[ind] = vx + dx * fallOff;
        vAr[ind + 1] = vy + dy * fallOff;
        vAr[ind + 2] = vz + dz * fallOff;
      }
    }
  };

  Utils.makeProxy(SculptBase, Pinch);

  module.exports = Pinch;
});
define('editing/tools/Crease',['require','exports','module','misc/Utils','misc/Tablet','editing/tools/SculptBase'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var Tablet = require('misc/Tablet');
  var SculptBase = require('editing/tools/SculptBase');

  var Crease = function (main) {
    SculptBase.call(this, main);
    this._radius = 25;
    this._intensity = 0.75;
    this._negative = true;
    this._culling = false;
    this._idAlpha = 0;
    this._lockPosition = false;
  };

  Crease.prototype = {
    /** On stroke */
    stroke: function (picking) {
      var iVertsInRadius = picking.getPickedVertices();
      var intensity = this._intensity * Tablet.getPressureIntensity();

      this.updateProxy(iVertsInRadius);
      // undo-redo
      this._states.pushVertices(iVertsInRadius);
      iVertsInRadius = this.dynamicTopology(picking);

      var iVertsFront = this.getFrontVertices(iVertsInRadius, picking.getEyeDirection());
      if (this._culling)
        iVertsInRadius = iVertsFront;

      picking.updateAlpha(this._lockPosition);
      picking.setIdAlpha(this._idAlpha);
      this.crease(iVertsInRadius, picking.getPickedNormal(), picking.getIntersectionPoint(), picking.getLocalRadius2(), intensity, picking);

      var mesh = this.getMesh();
      mesh.updateGeometry(mesh.getFacesFromVertices(iVertsInRadius), iVertsInRadius);
    },
    /** Pinch+brush-like sculpt */
    crease: function (iVertsInRadius, aNormal, center, radiusSquared, intensity, picking) {
      var mesh = this.getMesh();
      var vAr = mesh.getVertices();
      var mAr = mesh.getMaterials();
      var vProxy = mesh.getVerticesProxy();
      var radius = Math.sqrt(radiusSquared);
      var cx = center[0];
      var cy = center[1];
      var cz = center[2];
      var anx = aNormal[0];
      var any = aNormal[1];
      var anz = aNormal[2];
      var deformIntensity = intensity * 0.07;
      var brushFactor = deformIntensity * radius;
      if (this._negative)
        brushFactor = -brushFactor;
      for (var i = 0, l = iVertsInRadius.length; i < l; ++i) {
        var ind = iVertsInRadius[i] * 3;
        var dx = cx - vProxy[ind];
        var dy = cy - vProxy[ind + 1];
        var dz = cz - vProxy[ind + 2];
        var dist = Math.sqrt(dx * dx + dy * dy + dz * dz) / radius;
        if (dist >= 1.0)
          continue;
        var vx = vAr[ind];
        var vy = vAr[ind + 1];
        var vz = vAr[ind + 2];
        var fallOff = dist * dist;
        fallOff = 3.0 * fallOff * fallOff - 4.0 * fallOff * dist + 1.0;
        fallOff *= mAr[ind + 2] * picking.getAlpha(vx, vy, vz);
        var brushModifier = Math.pow(fallOff, 5) * brushFactor;
        fallOff *= deformIntensity;
        vAr[ind] = vx + dx * fallOff + anx * brushModifier;
        vAr[ind + 1] = vy + dy * fallOff + any * brushModifier;
        vAr[ind + 2] = vz + dz * fallOff + anz * brushModifier;
      }
    }
  };

  Utils.makeProxy(SculptBase, Crease);

  module.exports = Crease;
});
define('editing/tools/Drag',['require','exports','module','lib/glMatrix','misc/Utils','math3d/Geometry','editing/tools/SculptBase','editing/tools/Smooth'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Utils = require('misc/Utils');
  var Geometry = require('math3d/Geometry');
  var SculptBase = require('editing/tools/SculptBase');
  var Smooth = require('editing/tools/Smooth');

  var vec3 = glm.vec3;
  var mat4 = glm.mat4;

  var Drag = function (main) {
    SculptBase.call(this, main);
    this._radius = 150;
    this._dragDir = [0.0, 0.0, 0.0];
    this._dragDirSym = [0.0, 0.0, 0.0];
    this._idAlpha = 0;
  };

  Drag.prototype = {
    /** Make a brush stroke */
    sculptStroke: function () {
      var main = this._main;
      var mesh = this.getMesh();
      var picking = main.getPicking();
      var pickingSym = main.getSculpt().getSymmetry() ? main.getPickingSymmetry() : null;

      var dx = main._mouseX - this._lastMouseX;
      var dy = main._mouseY - this._lastMouseY;
      var dist = Math.sqrt(dx * dx + dy * dy);
      var minSpacing = 0.15 * this._radius;

      var step = 1.0 / Math.floor(dist / minSpacing);
      dx *= step;
      dy *= step;
      var mouseX = this._lastMouseX;
      var mouseY = this._lastMouseY;

      if (!picking.getMesh())
        return;
      picking._mesh = mesh;
      if (pickingSym) {
        pickingSym._mesh = mesh;
        vec3.copy(pickingSym.getIntersectionPoint(), picking.getIntersectionPoint());
        Geometry.mirrorPoint(pickingSym.getIntersectionPoint(), mesh.getSymmetryOrigin(), mesh.getSymmetryNormal());
      }

      for (var i = 0.0; i < 1.0; i += step) {
        if (!this.makeStroke(mouseX, mouseY, picking, pickingSym))
          break;
        mouseX += dx;
        mouseY += dy;
      }

      this.updateRender();

      this._lastMouseX = main._mouseX;
      this._lastMouseY = main._mouseY;
    },
    makeStroke: function (mouseX, mouseY, picking, pickingSym) {
      var mesh = this.getMesh();
      this.updateDragDir(picking, mouseX, mouseY);
      picking.pickVerticesInSphere(picking.getLocalRadius2());
      picking.computePickedNormal();
      // if dyn topo, we need to the picking and the sculpting altogether
      if (mesh.getDynamicTopology)
        this.stroke(picking, false);

      if (pickingSym) {
        this.updateDragDir(pickingSym, mouseX, mouseY, true);
        pickingSym.setLocalRadius2(picking.getLocalRadius2());
        pickingSym.pickVerticesInSphere(pickingSym.getLocalRadius2());
      }

      if (!mesh.getDynamicTopology) this.stroke(picking, false);
      if (pickingSym) this.stroke(pickingSym, true);
      return true;
    },
    /** On stroke */
    stroke: function (picking, sym) {
      var iVertsInRadius = picking.getPickedVertices();

      // undo-redo
      this._states.pushVertices(iVertsInRadius);
      iVertsInRadius = this.dynamicTopology(picking);

      picking.updateAlpha(this._lockPosition);
      picking.setIdAlpha(this._idAlpha);
      this.drag(iVertsInRadius, picking.getIntersectionPoint(), picking.getLocalRadius2(), sym, picking);
      Smooth.prototype.smoothTangent.call(this, iVertsInRadius, 1.0, picking);

      var mesh = this.getMesh();
      mesh.updateGeometry(mesh.getFacesFromVertices(iVertsInRadius), iVertsInRadius);
    },
    /** Drag deformation */
    drag: function (iVerts, center, radiusSquared, sym, picking) {
      var mesh = this.getMesh();
      var vAr = mesh.getVertices();
      var mAr = mesh.getMaterials();
      var radius = Math.sqrt(radiusSquared);
      var cx = center[0];
      var cy = center[1];
      var cz = center[2];
      var dir = sym ? this._dragDirSym : this._dragDir;
      var dirx = dir[0];
      var diry = dir[1];
      var dirz = dir[2];
      for (var i = 0, l = iVerts.length; i < l; ++i) {
        var ind = iVerts[i] * 3;
        var vx = vAr[ind];
        var vy = vAr[ind + 1];
        var vz = vAr[ind + 2];
        var dx = vx - cx;
        var dy = vy - cy;
        var dz = vz - cz;
        var dist = Math.sqrt(dx * dx + dy * dy + dz * dz) / radius;
        var fallOff = dist * dist;
        fallOff = 3.0 * fallOff * fallOff - 4.0 * fallOff * dist + 1.0;
        fallOff *= mAr[ind + 2] * picking.getAlpha(vx, vy, vz);
        vAr[ind] = vx + dirx * fallOff;
        vAr[ind + 1] = vy + diry * fallOff;
        vAr[ind + 2] = vz + dirz * fallOff;
      }
    },
    /** Set a few infos that will be needed for the drag function afterwards */
    updateDragDir: function (picking, mouseX, mouseY, useSymmetry) {
      var mesh = this.getMesh();
      var vNear = picking.unproject(mouseX, mouseY, 0.0);
      var vFar = picking.unproject(mouseX, mouseY, 0.1);
      var matInverse = mat4.create();
      mat4.invert(matInverse, mesh.getMatrix());
      vec3.transformMat4(vNear, vNear, matInverse);
      vec3.transformMat4(vFar, vFar, matInverse);
      var dir = this._dragDir;
      if (useSymmetry) {
        dir = this._dragDirSym;
        var ptPlane = mesh.getSymmetryOrigin();
        var nPlane = mesh.getSymmetryNormal();
        Geometry.mirrorPoint(vNear, ptPlane, nPlane);
        Geometry.mirrorPoint(vFar, ptPlane, nPlane);
      }
      var center = picking.getIntersectionPoint();
      picking.setIntersectionPoint(Geometry.vertexOnLine(center, vNear, vFar));
      vec3.sub(dir, picking.getIntersectionPoint(), center);
      picking._mesh = mesh;
      picking.updateLocalAndWorldRadius2();
      var eyeDir = picking.getEyeDirection();
      vec3.sub(eyeDir, vFar, vNear);
      vec3.normalize(eyeDir, eyeDir);
    }
  };

  Utils.makeProxy(SculptBase, Drag);

  module.exports = Drag;
});
define('editing/tools/Paint',['require','exports','module','lib/glMatrix','misc/Utils','misc/Tablet','editing/tools/SculptBase'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Utils = require('misc/Utils');
  var Tablet = require('misc/Tablet');
  var SculptBase = require('editing/tools/SculptBase');

  var vec3 = glm.vec3;

  var Paint = function (main) {
    SculptBase.call(this, main);
    this._radius = 50;
    this._hardness = 0.75;
    this._intensity = 0.75;
    this._culling = false;
    this._color = vec3.fromValues(1.0, 0.766, 0.336); // albedo
    this._material = vec3.fromValues(0.3, 0.95, 0.0); // roughness/metallic/masking
    this._pickColor = false; // color picking
    this._global = false; // global material
    this._pickCallback = null; // callback function after picking a color
    this._idAlpha = 0;
    this._lockPosition = false;
  };

  Paint.prototype = {
    end: function () {
      this._pickColor = false;
      SculptBase.prototype.end.call(this);
    },
    pushState: function (force) {
      if (!this._pickColor || force)
        this._states.pushStateColorAndMaterial(this.getMesh());
    },
    startSculpt: function () {
      if (this._pickColor)
        return this.pickColor(this._main.getPicking());
      SculptBase.prototype.startSculpt.call(this);
    },
    update: function () {
      if (this._pickColor === true)
        return this.updatePickColor();
      SculptBase.prototype.update.apply(this, arguments);
    },
    updateContinuous: function () {
      if (this._pickColor === true)
        return this.updatePickColor();
      SculptBase.prototype.updateContinuous.call(this);
    },
    updateMeshBuffers: function () {
      var mesh = this.getMesh();
      if (mesh.getDynamicTopology) {
        mesh.updateBuffers();
      } else {
        mesh.updateColorBuffer();
        mesh.updateMaterialBuffer();
      }
    },
    updatePickColor: function () {
      var picking = this._main.getPicking();
      if (picking.intersectionMouseMesh())
        this.pickColor(picking);
    },
    setPickCallback: function (cb) {
      this._pickCallback = cb;
    },
    pickColor: function (picking) {
      var mesh = this.getMesh();
      var color = this._color;
      picking.polyLerp(mesh.getMaterials(), color);
      var roughness = color[0];
      var metallic = color[1];
      picking.polyLerp(mesh.getColors(), color);
      this._pickCallback(color, roughness, metallic);
    },
    stroke: function (picking) {
      var iVertsInRadius = picking.getPickedVertices();
      var intensity = this._intensity * Tablet.getPressureIntensity();

      // undo-redo
      this._states.pushVertices(iVertsInRadius);
      iVertsInRadius = this.dynamicTopology(picking);

      if (this._culling)
        iVertsInRadius = this.getFrontVertices(iVertsInRadius, picking.getEyeDirection());

      picking.updateAlpha(this._lockPosition);
      picking.setIdAlpha(this._idAlpha);
      this.paint(iVertsInRadius, picking.getIntersectionPoint(), picking.getLocalRadius2(), intensity, this._hardness, picking);

      var mesh = this.getMesh();
      mesh.updateDuplicateColorsAndMaterials(iVertsInRadius);
      if (mesh.isUsingDrawArrays())
        mesh.updateDrawArrays(mesh.getFacesFromVertices(iVertsInRadius));
    },
    paint: function (iVerts, center, radiusSquared, intensity, hardness, picking) {
      var mesh = this.getMesh();
      var vAr = mesh.getVertices();
      var cAr = mesh.getColors();
      var mAr = mesh.getMaterials();
      var color = this._color;
      var roughness = this._material[0];
      var metallic = this._material[1];
      var radius = Math.sqrt(radiusSquared);
      var cr = color[0];
      var cg = color[1];
      var cb = color[2];
      var cx = center[0];
      var cy = center[1];
      var cz = center[2];
      var softness = 2 * (1 - hardness);
      for (var i = 0, l = iVerts.length; i < l; ++i) {
        var ind = iVerts[i] * 3;
        var vx = vAr[ind];
        var vy = vAr[ind + 1];
        var vz = vAr[ind + 2];
        var dx = vx - cx;
        var dy = vy - cy;
        var dz = vz - cz;
        var dist = Math.sqrt(dx * dx + dy * dy + dz * dz) / radius;
        var fallOff = Math.pow(1 - dist, softness);
        fallOff *= intensity * mAr[ind + 2] * picking.getAlpha(vx, vy, vz);
        var fallOffCompl = 1.0 - fallOff;
        cAr[ind] = cAr[ind] * fallOffCompl + cr * fallOff;
        cAr[ind + 1] = cAr[ind + 1] * fallOffCompl + cg * fallOff;
        cAr[ind + 2] = cAr[ind + 2] * fallOffCompl + cb * fallOff;
        mAr[ind] = mAr[ind] * fallOffCompl + roughness * fallOff;
        mAr[ind + 1] = mAr[ind + 1] * fallOffCompl + metallic * fallOff;
      }
    },
    paintAll: function () {
      var mesh = this.getMesh();
      var iVerts = this.getUnmaskedVertices();
      if (iVerts.length === 0)
        return;

      this.pushState(true);
      this._states.pushVertices(iVerts);

      var cAr = mesh.getColors();
      var mAr = mesh.getMaterials();
      var color = this._color;
      var roughness = this._material[0];
      var metallic = this._material[1];
      var cr = color[0];
      var cg = color[1];
      var cb = color[2];
      for (var i = 0, nb = iVerts.length; i < nb; ++i) {
        var ind = iVerts[i] * 3;
        var fallOff = mAr[ind + 2];
        var fallOffCompl = 1.0 - fallOff;
        cAr[ind] = cAr[ind] * fallOffCompl + cr * fallOff;
        cAr[ind + 1] = cAr[ind + 1] * fallOffCompl + cg * fallOff;
        cAr[ind + 2] = cAr[ind + 2] * fallOffCompl + cb * fallOff;
        mAr[ind] = mAr[ind] * fallOffCompl + roughness * fallOff;
        mAr[ind + 1] = mAr[ind + 1] * fallOffCompl + metallic * fallOff;
      }

      mesh.updateDuplicateColorsAndMaterials();
      mesh.updateDrawArrays();
      this.updateRender();
    }
  };

  Utils.makeProxy(SculptBase, Paint);

  module.exports = Paint;
});
define('editing/tools/Move',['require','exports','module','lib/glMatrix','misc/Utils','math3d/Geometry','editing/tools/SculptBase'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Utils = require('misc/Utils');
  var Geometry = require('math3d/Geometry');
  var SculptBase = require('editing/tools/SculptBase');

  var vec3 = glm.vec3;
  var mat4 = glm.mat4;

  var Move = function (main) {
    SculptBase.call(this, main);
    this._radius = 150;
    this._intensity = 1.0;
    this._topoCheck = true;
    this._negative = false; // along normal
    this._moveData = {
      center: [0.0, 0.0, 0.0],
      dir: [0.0, 0.0],
      vProxy: null
    };
    this._moveDataSym = {
      center: [0.0, 0.0, 0.0],
      dir: [0.0, 0.0],
      vProxy: null
    };
    this._idAlpha = 0;
  };

  Move.prototype = {
    startSculpt: function () {
      var main = this._main;
      var picking = main.getPicking();
      this.initMoveData(picking, this._moveData);

      if (main.getSculpt().getSymmetry()) {
        var pickingSym = main.getPickingSymmetry();
        pickingSym.intersectionMouseMesh();
        pickingSym.setLocalRadius2(picking.getLocalRadius2());

        if (pickingSym.getMesh())
          this.initMoveData(pickingSym, this._moveDataSym);
      }
    },
    initMoveData: function (picking, moveData) {
      if (this._topoCheck)
        picking.pickVerticesInSphereTopological(picking.getLocalRadius2());
      else
        picking.pickVerticesInSphere(picking.getLocalRadius2());
      vec3.copy(moveData.center, picking.getIntersectionPoint());
      var iVerts = picking.getPickedVertices();
      // undo-redo
      this._states.pushVertices(iVerts);

      var vAr = picking.getMesh().getVertices();
      var nbVerts = iVerts.length;
      var vProxy = moveData.vProxy = new Float32Array(nbVerts * 3);
      for (var i = 0; i < nbVerts; ++i) {
        var ind = iVerts[i] * 3;
        var j = i * 3;
        vProxy[j] = vAr[ind];
        vProxy[j + 1] = vAr[ind + 1];
        vProxy[j + 2] = vAr[ind + 2];
      }
    },
    copyVerticesProxy: function (picking, moveData) {
      var iVerts = picking.getPickedVertices();
      var vAr = this.getMesh().getVertices();
      var vProxy = moveData.vProxy;
      for (var i = 0, nbVerts = iVerts.length; i < nbVerts; ++i) {
        var ind = iVerts[i] * 3;
        var j = i * 3;
        vAr[ind] = vProxy[j];
        vAr[ind + 1] = vProxy[j + 1];
        vAr[ind + 2] = vProxy[j + 2];
      }
    },
    sculptStroke: function () {
      var main = this._main;
      var picking = main.getPicking();
      var pickingSym = main.getPickingSymmetry();
      var useSym = main.getSculpt().getSymmetry() && pickingSym.getMesh();

      picking.updateAlpha(this._lockPosition);
      picking.setIdAlpha(this._idAlpha);
      if (useSym) {
        pickingSym.updateAlpha(false);
        pickingSym.setIdAlpha(this._idAlpha);
      }

      this.copyVerticesProxy(picking, this._moveData);
      if (useSym)
        this.copyVerticesProxy(pickingSym, this._moveDataSym);

      var mouseX = main._mouseX;
      var mouseY = main._mouseY;
      this.updateMoveDir(picking, mouseX, mouseY);
      this.move(picking.getPickedVertices(), picking.getIntersectionPoint(), picking.getLocalRadius2(), this._moveData, picking);

      if (useSym) {
        this.updateMoveDir(pickingSym, mouseX, mouseY, true);
        this.move(pickingSym.getPickedVertices(), pickingSym.getIntersectionPoint(), pickingSym.getLocalRadius2(), this._moveDataSym, pickingSym);
      }

      var mesh = this.getMesh();
      mesh.updateGeometry(mesh.getFacesFromVertices(picking.getPickedVertices()), picking.getPickedVertices());
      if (useSym)
        mesh.updateGeometry(mesh.getFacesFromVertices(pickingSym.getPickedVertices()), pickingSym.getPickedVertices());
      this.updateRender();
      main.setCanvasCursor('default');
    },
    move: function (iVerts, center, radiusSquared, moveData, picking) {
      var mesh = this.getMesh();
      var vAr = mesh.getVertices();
      var mAr = mesh.getMaterials();
      var radius = Math.sqrt(radiusSquared);
      var vProxy = moveData.vProxy;
      var cx = center[0];
      var cy = center[1];
      var cz = center[2];
      var dir = moveData.dir;
      var dirx = dir[0];
      var diry = dir[1];
      var dirz = dir[2];
      for (var i = 0, l = iVerts.length; i < l; ++i) {
        var ind = iVerts[i] * 3;
        var j = i * 3;
        var vx = vProxy[j];
        var vy = vProxy[j + 1];
        var vz = vProxy[j + 2];
        var dx = vx - cx;
        var dy = vy - cy;
        var dz = vz - cz;
        var dist = Math.sqrt(dx * dx + dy * dy + dz * dz) / radius;
        var fallOff = dist * dist;
        fallOff = 3.0 * fallOff * fallOff - 4.0 * fallOff * dist + 1.0;
        fallOff *= mAr[ind + 2] * picking.getAlpha(vx, vy, vz);
        vAr[ind] += dirx * fallOff;
        vAr[ind + 1] += diry * fallOff;
        vAr[ind + 2] += dirz * fallOff;
      }
    },
    updateMoveDir: function (picking, mouseX, mouseY, useSymmetry) {
      var mesh = this.getMesh();
      var vNear = picking.unproject(mouseX, mouseY, 0.0);
      var vFar = picking.unproject(mouseX, mouseY, 0.1);
      var matInverse = mat4.create();
      mat4.invert(matInverse, mesh.getMatrix());
      vec3.transformMat4(vNear, vNear, matInverse);
      vec3.transformMat4(vFar, vFar, matInverse);

      var moveData = useSymmetry ? this._moveDataSym : this._moveData;
      if (useSymmetry) {
        var ptPlane = mesh.getSymmetryOrigin();
        var nPlane = mesh.getSymmetryNormal();
        Geometry.mirrorPoint(vNear, ptPlane, nPlane);
        Geometry.mirrorPoint(vFar, ptPlane, nPlane);
      }

      if (this._negative) {
        var len = vec3.dist(Geometry.vertexOnLine(moveData.center, vNear, vFar), moveData.center);
        vec3.normalize(moveData.dir, picking.computePickedNormal());
        vec3.scale(moveData.dir, moveData.dir, mouseX < this._lastMouseX ? -len : len);
      } else {
        vec3.sub(moveData.dir, Geometry.vertexOnLine(moveData.center, vNear, vFar), moveData.center);
      }
      vec3.scale(moveData.dir, moveData.dir, this._intensity);

      var eyeDir = picking.getEyeDirection();
      vec3.sub(eyeDir, vFar, vNear);
      vec3.normalize(eyeDir, eyeDir);
    }
  };

  Utils.makeProxy(SculptBase, Move);

  module.exports = Move;
});
define('mesh/meshData/DrawArraysData',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var DrawArraysData = function (mesh) {
    this._mesh = mesh; // the mesh

    this._verticesXYZ = null; // vertices (Float32Array)
    this._normalsXYZ = null; // normals (Float32Array)
    this._colorsRGB = null; // color vertices (Float32Array)
    this._materialsPBR = null; // material vertices (Float32Array)
    this._texCoordsST = null; // texCoords (Float32Array)
  };

  DrawArraysData.prototype = {
    getVerticesDrawArrays: function () {
      if (!this._verticesXYZ) this.updateDrawArrays();
      return this._verticesXYZ;
    },
    getNormalsDrawArrays: function () {
      return this._normalsXYZ;
    },
    getColorsDrawArrays: function () {
      return this._colorsRGB;
    },
    getMaterialsDrawArrays: function () {
      return this._materialsPBR;
    },
    getTexCoordsDrawArrays: function () {
      return this._texCoordsST;
    },
    setAlreadyDrawArrays: function () {
      // kind of a hack, to be used if the main arrays are already draw arrays
      var mesh = this._mesh;
      this._verticesXYZ = mesh.getVertices();
      this._normalsXYZ = mesh.getNormals();
      this._colorsRGB = mesh.getColors();
      this._materialsPBR = mesh.getMaterials();
    },
    /** ONLY FOR DYNAMIC MESH */
    reAllocateArrays: function (nbAddElements) {
      var mesh = this._mesh;
      var nbMagic = 10;
      var nbDyna = this._verticesXYZ.length / 9;
      var nbTriangles = mesh.getNbTriangles();
      var len = nbTriangles + nbAddElements * nbMagic;
      if (nbDyna < len || nbDyna > len * 4) {
        this._verticesXYZ = mesh.resizeArray(this._verticesXYZ, len * 9);
        this._normalsXYZ = mesh.resizeArray(this._normalsXYZ, len * 9);
        this._colorsRGB = mesh.resizeArray(this._colorsRGB, len * 9);
        this._materialsPBR = mesh.resizeArray(this._materialsPBR, len * 9);
      }
    },
    /** Updates the arrays that are going to be used by webgl */
    updateDrawArrays: function (iFaces) {
      var mesh = this._mesh;
      if (!mesh.isUsingDrawArrays())
        return;

      var vAr = mesh.getVertices();
      var nAr = mesh.getNormals();
      var cAr = mesh.getColors();
      var mAr = mesh.getMaterials();

      var fAr = mesh.getFaces();

      var nbTriangles = mesh.getNbTriangles();
      var facesToTris = mesh.hasOnlyTriangles() ? null : mesh.getFacesToTriangles();

      var full = iFaces === undefined;
      var cdv = this._verticesXYZ;
      var cdn = this._normalsXYZ;
      var cdc = this._colorsRGB;
      var cdm = this._materialsPBR;

      if (!cdv || cdv.length < nbTriangles * 9) {
        cdv = this._verticesXYZ = new Float32Array(nbTriangles * 9);
        cdn = this._normalsXYZ = new Float32Array(nbTriangles * 9);
        cdc = this._colorsRGB = new Float32Array(nbTriangles * 9);
        cdm = this._materialsPBR = new Float32Array(nbTriangles * 9);
      }

      var nbFaces = full ? mesh.getNbFaces() : iFaces.length;
      for (var i = 0; i < nbFaces; ++i) {
        var idFace = full ? i : iFaces[i];
        var ftt = facesToTris ? facesToTris[idFace] : idFace;
        var vId = ftt * 9;

        idFace *= 4;
        var id1 = fAr[idFace] * 3;
        var id2 = fAr[idFace + 1] * 3;
        var id3 = fAr[idFace + 2] * 3;
        var id4 = fAr[idFace + 3] * 3;

        // coordinates
        cdv[vId] = vAr[id1];
        cdv[vId + 1] = vAr[id1 + 1];
        cdv[vId + 2] = vAr[id1 + 2];
        cdv[vId + 3] = vAr[id2];
        cdv[vId + 4] = vAr[id2 + 1];
        cdv[vId + 5] = vAr[id2 + 2];
        cdv[vId + 6] = vAr[id3];
        cdv[vId + 7] = vAr[id3 + 1];
        cdv[vId + 8] = vAr[id3 + 2];

        // color
        cdc[vId] = cAr[id1];
        cdc[vId + 1] = cAr[id1 + 1];
        cdc[vId + 2] = cAr[id1 + 2];
        cdc[vId + 3] = cAr[id2];
        cdc[vId + 4] = cAr[id2 + 1];
        cdc[vId + 5] = cAr[id2 + 2];
        cdc[vId + 6] = cAr[id3];
        cdc[vId + 7] = cAr[id3 + 1];
        cdc[vId + 8] = cAr[id3 + 2];

        // material
        cdm[vId] = mAr[id1];
        cdm[vId + 1] = mAr[id1 + 1];
        cdm[vId + 2] = mAr[id1 + 2];
        cdm[vId + 3] = mAr[id2];
        cdm[vId + 4] = mAr[id2 + 1];
        cdm[vId + 5] = mAr[id2 + 2];
        cdm[vId + 6] = mAr[id3];
        cdm[vId + 7] = mAr[id3 + 1];
        cdm[vId + 8] = mAr[id3 + 2];

        // normals
        cdn[vId] = nAr[id1];
        cdn[vId + 1] = nAr[id1 + 1];
        cdn[vId + 2] = nAr[id1 + 2];
        cdn[vId + 3] = nAr[id2];
        cdn[vId + 4] = nAr[id2 + 1];
        cdn[vId + 5] = nAr[id2 + 2];
        cdn[vId + 6] = nAr[id3];
        cdn[vId + 7] = nAr[id3 + 1];
        cdn[vId + 8] = nAr[id3 + 2];

        if (id4 < 0)
          continue;

        vId += 9;
        // coordinates
        cdv[vId] = vAr[id1];
        cdv[vId + 1] = vAr[id1 + 1];
        cdv[vId + 2] = vAr[id1 + 2];
        cdv[vId + 3] = vAr[id3];
        cdv[vId + 4] = vAr[id3 + 1];
        cdv[vId + 5] = vAr[id3 + 2];
        cdv[vId + 6] = vAr[id4];
        cdv[vId + 7] = vAr[id4 + 1];
        cdv[vId + 8] = vAr[id4 + 2];

        // colors
        cdc[vId] = cAr[id1];
        cdc[vId + 1] = cAr[id1 + 1];
        cdc[vId + 2] = cAr[id1 + 2];
        cdc[vId + 3] = cAr[id3];
        cdc[vId + 4] = cAr[id3 + 1];
        cdc[vId + 5] = cAr[id3 + 2];
        cdc[vId + 6] = cAr[id4];
        cdc[vId + 7] = cAr[id4 + 1];
        cdc[vId + 8] = cAr[id4 + 2];

        // materials
        cdm[vId] = mAr[id1];
        cdm[vId + 1] = mAr[id1 + 1];
        cdm[vId + 2] = mAr[id1 + 2];
        cdm[vId + 3] = mAr[id3];
        cdm[vId + 4] = mAr[id3 + 1];
        cdm[vId + 5] = mAr[id3 + 2];
        cdm[vId + 6] = mAr[id4];
        cdm[vId + 7] = mAr[id4 + 1];
        cdm[vId + 8] = mAr[id4 + 2];

        // normals
        cdn[vId] = nAr[id1];
        cdn[vId + 1] = nAr[id1 + 1];
        cdn[vId + 2] = nAr[id1 + 2];
        cdn[vId + 3] = nAr[id3];
        cdn[vId + 4] = nAr[id3 + 1];
        cdn[vId + 5] = nAr[id3 + 2];
        cdn[vId + 6] = nAr[id4];
        cdn[vId + 7] = nAr[id4 + 1];
        cdn[vId + 8] = nAr[id4 + 2];
      }
      if (mesh.isUsingTexCoords())
        this.updateDrawArraysTexCoord(iFaces);
    },
    /** Updates the UV array data for drawArrays */
    updateDrawArraysTexCoord: function (iFaces) {
      var mesh = this._mesh;
      var nbTriangles = mesh.getNbTriangles();
      var facesToTris = mesh.getFacesToTriangles();

      var full = iFaces === undefined;
      var cdt = this._texCoordsST;
      if (!cdt || cdt.length !== nbTriangles * 6)
        cdt = this._texCoordsST = new Float32Array(nbTriangles * 6);

      var tAr = mesh.getTexCoords();
      var fArUV = mesh.getFacesTexCoord();

      var nbFaces = full ? mesh.getNbFaces() : iFaces.length;
      for (var i = 0; i < nbFaces; ++i) {
        var idFace = full ? i : iFaces[i];
        var ftt = facesToTris[idFace];
        var vIduv = ftt * 6;

        idFace *= 4;
        var id1uv = fArUV[idFace] * 2;
        var id2uv = fArUV[idFace + 1] * 2;
        var id3uv = fArUV[idFace + 2] * 2;
        var id4uv = fArUV[idFace + 3] * 2;

        cdt[vIduv] = tAr[id1uv];
        cdt[vIduv + 1] = tAr[id1uv + 1];
        cdt[vIduv + 2] = tAr[id2uv];
        cdt[vIduv + 3] = tAr[id2uv + 1];
        cdt[vIduv + 4] = tAr[id3uv];
        cdt[vIduv + 5] = tAr[id3uv + 1];

        if (id4uv < 0)
          continue;

        vIduv += 6;
        cdt[vIduv] = tAr[id1uv];
        cdt[vIduv + 1] = tAr[id1uv + 1];
        cdt[vIduv + 2] = tAr[id3uv];
        cdt[vIduv + 3] = tAr[id3uv + 1];
        cdt[vIduv + 4] = tAr[id4uv];
        cdt[vIduv + 5] = tAr[id4uv + 1];
      }
    }
  };

  module.exports = DrawArraysData;
});
define('mesh/meshData/EdgeData',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var EdgeData = function (mesh) {
    this._mesh = mesh; // the mesh

    this._edges = null; // edges (Uint8Array) (1 => outer edge, 0 or 2 => inner edge, >=3 non manifold)
  };

  EdgeData.prototype = {
    getEdges: function () {
      return this._edges;
    },
    getNbEdges: function () {
      return this._edges.length;
    },
    /** Computes the edges */
    initEdges: function () {
      var mesh = this._mesh;
      var fAr = mesh.getFaces();
      var feAr = mesh.getFaceEdges();
      var nbEdges = 0;
      var vertEdgeTemp = new Uint32Array(mesh.getNbVertices());
      var vrfStartCount = mesh.getVerticesRingFaceStartCount();
      var vertRingFace = mesh.getVerticesRingFace();
      for (var i = 0, nbVerts = mesh.getNbVertices(); i < nbVerts; ++i) {
        var start = vrfStartCount[i * 2];
        var end = start + vrfStartCount[i * 2 + 1];
        var compTest = nbEdges;
        for (var j = start; j < end; ++j) {
          var id = vertRingFace[j] * 4;
          var iv1 = fAr[id];
          var iv2 = fAr[id + 1];
          var iv3 = fAr[id + 2];
          var iv4 = fAr[id + 3];
          var t = 0;
          var idEdge = 0;
          if (iv4 < 0) {
            if (i > iv1) {
              t = vertEdgeTemp[iv1];
              idEdge = id + (i === iv2 ? 0 : 2);
              if (t <= compTest) {
                feAr[idEdge] = nbEdges;
                vertEdgeTemp[iv1] = ++nbEdges;
              } else {
                feAr[idEdge] = t - 1;
              }
            }
            if (i > iv2) {
              t = vertEdgeTemp[iv2];
              idEdge = id + (i === iv1 ? 0 : 1);
              if (t <= compTest) {
                feAr[idEdge] = nbEdges;
                vertEdgeTemp[iv2] = ++nbEdges;
              } else {
                feAr[idEdge] = t - 1;
              }
            }
            if (i > iv3) {
              t = vertEdgeTemp[iv3];
              idEdge = id + (i === iv1 ? 2 : 1);
              if (t <= compTest) {
                feAr[idEdge] = nbEdges;
                vertEdgeTemp[iv3] = ++nbEdges;
              } else {
                feAr[idEdge] = t - 1;
              }
            }
            feAr[id + 3] = -1;
          } else {
            if (i > iv1 && i !== iv3) {
              t = vertEdgeTemp[iv1];
              idEdge = id + (i === iv2 ? 0 : 3);
              if (t <= compTest) {
                feAr[idEdge] = nbEdges;
                vertEdgeTemp[iv1] = ++nbEdges;
              } else {
                feAr[idEdge] = t - 1;
              }
            }
            if (i > iv2 && i !== iv4) {
              t = vertEdgeTemp[iv2];
              idEdge = id + (i === iv1 ? 0 : 1);
              if (t <= compTest) {
                feAr[idEdge] = nbEdges;
                vertEdgeTemp[iv2] = ++nbEdges;
              } else {
                feAr[idEdge] = t - 1;
              }
            }
            if (i > iv3 && i !== iv1) {
              t = vertEdgeTemp[iv3];
              idEdge = id + (i === iv2 ? 1 : 2);
              if (t <= compTest) {
                feAr[idEdge] = nbEdges;
                vertEdgeTemp[iv3] = ++nbEdges;
              } else {
                feAr[idEdge] = t - 1;
              }
            }
            if (i > iv4 && i !== iv2) {
              t = vertEdgeTemp[iv4];
              idEdge = id + (i === iv1 ? 3 : 2);
              if (t <= compTest) {
                feAr[idEdge] = nbEdges;
                vertEdgeTemp[iv4] = ++nbEdges;
              } else {
                feAr[idEdge] = t - 1;
              }
            }
          }
        }
      }
      var eAr = this._edges = new Uint8Array(nbEdges);
      for (var k = 0, nbFaceEdges = feAr.length; k < nbFaceEdges; ++k)
        eAr[feAr[k]]++;
    }
  };

  module.exports = EdgeData;
});
define('mesh/meshData/FaceData',['require','exports','module','misc/Utils'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');

  var FaceData = function (mesh) {
    this._mesh = mesh; // the mesh

    this._facesABCD = null; // faces (Int32Array)

    this._faceEdges = null; // faces to edges (Int32Array)
    this._faceNormalsXYZ = null; // faces normals (Float32Array)
    this._faceBoxes = null; // faces bbox (Float32Array)
    this._faceCentersXYZ = null; // faces center (Float32Array)

    this._facesToTriangles = null; // faces to triangles (Uint32Array)
    this._UVtrianglesABC = null; // triangles tex coords (Uint32Array)
    this._trianglesABC = null; // triangles (Uint32Array)

    this._facesTagFlags = null; // triangles tag (<= Utils.TAG_FLAG) (Int32Array)
  };

  FaceData.prototype = {
    setFaces: function (fAr) {
      this._facesABCD = fAr;
    },
    getFaces: function () {
      return this._facesABCD;
    },
    hasOnlyTriangles: function () {
      return this._mesh.getNbTriangles() === this._mesh.getNbFaces();
    },
    hasOnlyQuads: function () {
      return this._mesh.getNbTriangles() === this._mesh.getNbFaces() * 2;
    },
    getNbQuads: function () {
      return this._mesh.getNbTriangles() - this._mesh.getNbFaces();
    },
    getFaceNormals: function () {
      return this._faceNormalsXYZ;
    },
    getFaceBoxes: function () {
      return this._faceBoxes;
    },
    getFaceCenters: function () {
      return this._faceCentersXYZ;
    },
    getFacesTagFlags: function () {
      return this._facesTagFlags;
    },
    getFaceEdges: function () {
      return this._faceEdges;
    },
    getFacesToTriangles: function () {
      return this._facesToTriangles;
    },
    getNbFaces: function () {
      return this._facesABCD ? this._facesABCD.length / 4 : 0;
    },
    getTrianglesTexCoord: function () {
      return this._UVtrianglesABC;
    },
    getTriangles: function () {
      return this._trianglesABC;
    },
    getNbTriangles: function () {
      return this._trianglesABC.length / 3;
    },
    allocateArrays: function () {
      var nbFaces = this._mesh.getNbFaces();

      this._faceEdges = new Int32Array(nbFaces * 4);
      this._facesToTriangles = new Uint32Array(nbFaces);

      this._faceBoxes = new Float32Array(nbFaces * 6);
      this._faceNormalsXYZ = new Float32Array(nbFaces * 3);
      this._faceCentersXYZ = new Float32Array(nbFaces * 3);

      this._facesTagFlags = new Int32Array(nbFaces);
    },
    /** ONLY FOR DYNAMIC MESH */
    reAllocateArrays: function (nbAddElements) {
      var mesh = this._mesh;
      var nbDyna = this._facesABCD.length / 4;
      var nbTriangles = mesh.getNbTriangles();
      var len = nbTriangles + nbAddElements;
      if (nbDyna < len || nbDyna > len * 4) {
        this._facesABCD = mesh.resizeArray(this._facesABCD, len * 4);
        this._trianglesABC = mesh.resizeArray(this._trianglesABC, len * 3);
        // this._faceEdges = mesh.resizeArray(this._faceEdges, len * 4); // TODO used ?
        // this._facesToTriangles = mesh.resizeArray(this._facesToTriangles, len); // TODO used ?

        this._faceBoxes = mesh.resizeArray(this._faceBoxes, len * 6);
        this._faceNormalsXYZ = mesh.resizeArray(this._faceNormalsXYZ, len * 3);
        this._faceCentersXYZ = mesh.resizeArray(this._faceCentersXYZ, len * 3);

        this._facesTagFlags = mesh.resizeArray(this._facesTagFlags, len);
      }
    },
    /** Update a group of faces normal and aabb */
    updateFacesAabbAndNormal: function (iFaces) {
      var mesh = this._mesh;
      var faceNormals = this.getFaceNormals();
      var faceBoxes = this.getFaceBoxes();
      var faceCenters = this.getFaceCenters();
      var vAr = mesh.getVertices();
      var fAr = this.getFaces();

      var full = iFaces === undefined;
      var nbFaces = full ? mesh.getNbFaces() : iFaces.length;
      for (var i = 0; i < nbFaces; ++i) {
        var ind = full ? i : iFaces[i];
        var idTri = ind * 3;
        var idFace = ind * 4;
        var idBox = ind * 6;
        var ind1 = fAr[idFace] * 3;
        var ind2 = fAr[idFace + 1] * 3;
        var ind3 = fAr[idFace + 2] * 3;
        var ind4 = fAr[idFace + 3] * 3;
        var v1x = vAr[ind1];
        var v1y = vAr[ind1 + 1];
        var v1z = vAr[ind1 + 2];
        var v2x = vAr[ind2];
        var v2y = vAr[ind2 + 1];
        var v2z = vAr[ind2 + 2];
        var v3x = vAr[ind3];
        var v3y = vAr[ind3 + 1];
        var v3z = vAr[ind3 + 2];
        // compute normals
        var ax = v2x - v1x;
        var ay = v2y - v1y;
        var az = v2z - v1z;
        var bx = v3x - v1x;
        var by = v3y - v1y;
        var bz = v3z - v1z;
        var crx = ay * bz - az * by;
        var cry = az * bx - ax * bz;
        var crz = ax * by - ay * bx;
        // compute boxes
        // for code readability of course
        var xmin = v1x < v2x ? v1x < v3x ? v1x : v3x : v2x < v3x ? v2x : v3x;
        var xmax = v1x > v2x ? v1x > v3x ? v1x : v3x : v2x > v3x ? v2x : v3x;
        var ymin = v1y < v2y ? v1y < v3y ? v1y : v3y : v2y < v3y ? v2y : v3y;
        var ymax = v1y > v2y ? v1y > v3y ? v1y : v3y : v2y > v3y ? v2y : v3y;
        var zmin = v1z < v2z ? v1z < v3z ? v1z : v3z : v2z < v3z ? v2z : v3z;
        var zmax = v1z > v2z ? v1z > v3z ? v1z : v3z : v2z > v3z ? v2z : v3z;
        if (ind4 >= 0) {
          var v4x = vAr[ind4];
          var v4y = vAr[ind4 + 1];
          var v4z = vAr[ind4 + 2];
          if (v4x < xmin) xmin = v4x;
          if (v4x > xmax) xmax = v4x;
          if (v4y < ymin) ymin = v4y;
          if (v4y > ymax) ymax = v4y;
          if (v4z < zmin) zmin = v4z;
          if (v4z > zmax) zmax = v4z;
          ax = v3x - v4x;
          ay = v3y - v4y;
          az = v3z - v4z;
          crx += ay * bz - az * by;
          cry += az * bx - ax * bz;
          crz += ax * by - ay * bx;
        }
        // normals
        faceNormals[idTri] = crx;
        faceNormals[idTri + 1] = cry;
        faceNormals[idTri + 2] = crz;
        // boxes
        faceBoxes[idBox] = xmin;
        faceBoxes[idBox + 1] = ymin;
        faceBoxes[idBox + 2] = zmin;
        faceBoxes[idBox + 3] = xmax;
        faceBoxes[idBox + 4] = ymax;
        faceBoxes[idBox + 5] = zmax;
        // compute centers
        faceCenters[idTri] = (xmin + xmax) * 0.5;
        faceCenters[idTri + 1] = (ymin + ymax) * 0.5;
        faceCenters[idTri + 2] = (zmin + zmax) * 0.5;
      }
    },
    /** Get more faces (n-ring) */
    expandsFaces: function (iFaces, nRing) {
      var mesh = this._mesh;
      var tagFlag = ++Utils.TAG_FLAG;
      var nbFaces = iFaces.length;
      var vrfStartCount = mesh.getVerticesRingFaceStartCount();
      var vertRingFace = mesh.getVerticesRingFace();
      var ringFaces = vertRingFace instanceof Array ? vertRingFace : null;
      var ftf = this.getFacesTagFlags();
      var fAr = this.getFaces();
      var acc = nbFaces;
      var iFacesExpanded = new Uint32Array(Utils.getMemory(4 * mesh.getNbFaces()), 0, mesh.getNbFaces());
      iFacesExpanded.set(iFaces);
      var i = 0;
      for (i = 0; i < nbFaces; ++i)
        ftf[iFacesExpanded[i]] = tagFlag;
      var iBegin = 0;
      while (nRing) {
        --nRing;
        for (i = iBegin; i < nbFaces; ++i) {
          var ind = iFacesExpanded[i] * 4;

          for (var j = 0; j < 4; ++j) {
            var idv = fAr[ind + j];
            if (idv < 0)
              break;
            var start, end;
            if (ringFaces) {
              vertRingFace = ringFaces[idv];
              start = 0;
              end = vertRingFace.length;
            } else {
              start = vrfStartCount[idv * 2];
              end = start + vrfStartCount[idv * 2 + 1];
            }
            for (var k = start; k < end; ++k) {
              var id = vertRingFace[k];
              if (ftf[id] === tagFlag)
                continue;
              ftf[id] = tagFlag;
              iFacesExpanded[acc++] = id;
            }
          }
        }
        iBegin = nbFaces;
        nbFaces = acc;
      }
      return new Uint32Array(iFacesExpanded.subarray(0, acc));
    },
    /** Return all the faces linked to a group of vertices */
    getFacesFromVertices: function (iVerts) {
      var mesh = this._mesh;
      var tagFlag = ++Utils.TAG_FLAG;
      var nbVerts = iVerts.length;
      var vrfStartCount = mesh.getVerticesRingFaceStartCount();
      var vertRingFace = mesh.getVerticesRingFace();
      var ringFaces = vertRingFace instanceof Array ? vertRingFace : null;
      var ftf = this.getFacesTagFlags();
      var acc = 0;
      var iFaces = new Uint32Array(Utils.getMemory(4 * mesh.getNbFaces()), 0, mesh.getNbFaces());
      for (var i = 0; i < nbVerts; ++i) {
        var idVert = iVerts[i];
        var start, end;
        if (ringFaces) {
          vertRingFace = ringFaces[idVert];
          start = 0;
          end = vertRingFace.length;
        } else {
          start = vrfStartCount[idVert * 2];
          end = start + vrfStartCount[idVert * 2 + 1];
        }
        for (var j = start; j < end; ++j) {
          var iFace = vertRingFace[j];
          if (ftf[iFace] !== tagFlag) {
            ftf[iFace] = tagFlag;
            iFaces[acc++] = iFace;
          }
        }
      }
      return new Uint32Array(iFaces.subarray(0, acc));
    },
    /** Computes triangles */
    initRenderTriangles: function () {
      var mesh = this._mesh;
      if (mesh.hasUV())
        this._UVtrianglesABC = this.computeTrianglesFromFaces(mesh.getFacesTexCoord());
      this._trianglesABC = this.computeTrianglesFromFaces(mesh.getFaces());
    },
    /** Computes triangles from faces */
    computeTrianglesFromFaces: function (faces) {
      var nbFaces = this._mesh.getNbFaces();
      var facesToTris = this.getFacesToTriangles();
      var iAr = new Uint32Array(Utils.getMemory(4 * nbFaces * 6), 0, nbFaces * 6);
      var acc = 0;
      for (var i = 0; i < nbFaces; ++i) {
        facesToTris[i] = acc;
        var iFace = i * 4;
        var iv1 = faces[iFace];
        var iv2 = faces[iFace + 1];
        var iv3 = faces[iFace + 2];
        var iv4 = faces[iFace + 3];
        var iTri = acc * 3;
        iAr[iTri] = iv1;
        iAr[iTri + 1] = iv2;
        iAr[iTri + 2] = iv3;
        ++acc;
        if (iv4 >= 0) {
          iTri = acc * 3;
          iAr[iTri] = iv1;
          iAr[iTri + 1] = iv3;
          iAr[iTri + 2] = iv4;
          ++acc;
        }
      }
      return new Uint32Array(iAr.subarray(0, acc * 3));
    }
  };

  module.exports = FaceData;
});
define('mesh/meshData/TexCoordsData',['require','exports','module','misc/Utils'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');

  var TexCoordsData = function (mesh) {
    this._mesh = mesh; // the mesh

    this._texCoordsST = null; // tex coords (Float32Array)
    this._duplicateStartCount = null; // array of vertex duplicates location (start/count) (Uint32Array)
    this._UVfacesABCD = null; // faces unwrap (Int32Array)

    // attributes vertex (duplicated for rendering because of tex coords)
    this._UVverticesXYZ = null; // vertices + duplicates (Float32Array)
    this._UVcolorsRGB = null; // color vertices + duplicates (Float32Array)
    this._UVmaterialsPBR = null; // materials vertices + duplicates (Float32Array)
    this._UVnormalsXYZ = null; // normals + duplicates (Float32Array)
  };

  TexCoordsData.prototype = {
    hasUV: function () {
      return this._texCoordsST !== null;
    },
    setTexCoords: function (tAr) {
      this._texCoordsST = tAr;
    },
    setVerticesDuplicateStartCount: function (startCount) {
      this._duplicateStartCount = startCount;
    },
    setFacesTexCoord: function (fuAr) {
      this._UVfacesABCD = fuAr;
    },
    getVerticesTexCoord: function () {
      return this._UVverticesXYZ;
    },
    getColorsTexCoord: function () {
      return this._UVcolorsRGB;
    },
    getMaterialsTexCoord: function () {
      return this._UVmaterialsPBR;
    },
    getNormalsTexCoord: function () {
      return this._UVnormalsXYZ;
    },
    getTexCoords: function () {
      return this._texCoordsST;
    },
    getVerticesDuplicateStartCount: function () {
      return this._duplicateStartCount;
    },
    getFacesTexCoord: function () {
      return this._UVfacesABCD;
    },
    getNbTexCoords: function () {
      return this._texCoordsST ? this._texCoordsST.length / 2 : 0;
    },
    allocateArrays: function () {
      if (!this.hasUV())
        return;

      var mesh = this._mesh;
      var nbTexCoords = this._texCoordsST.length / 2;
      var nbVertices = mesh.getNbVertices();

      var verts = this._UVverticesXYZ = new Float32Array(nbTexCoords * 3);
      verts.set(mesh.getVertices());
      mesh.setVertices(verts.subarray(0, nbVertices * 3));

      var normals = this._UVnormalsXYZ = new Float32Array(nbTexCoords * 3);
      normals.set(mesh.getNormals());
      mesh.setNormals(normals.subarray(0, nbVertices * 3));

      var colors = this._UVcolorsRGB = new Float32Array(nbTexCoords * 3);
      colors.set(mesh.getColors());
      mesh.setColors(colors.subarray(0, nbVertices * 3));

      var materials = this._UVmaterialsPBR = new Float32Array(nbTexCoords * 3);
      materials.set(mesh.getMaterials());
      mesh.setMaterials(materials.subarray(0, nbVertices * 3));
    },
    updateDuplicateGeometry: function (iVerts) {
      var mesh = this._mesh;
      if (!mesh.isUsingTexCoords() || !this.hasUV())
        return;

      var vAr = this.getVerticesTexCoord();
      var cAr = this.getColorsTexCoord();
      var mAr = this.getMaterialsTexCoord();
      var nAr = this.getNormalsTexCoord();
      var startCount = this.getVerticesDuplicateStartCount();

      var full = iVerts === undefined;
      var nbVerts = full ? mesh.getNbVertices() : iVerts.length;
      for (var i = 0; i < nbVerts; ++i) {
        var ind = full ? i : iVerts[i];
        var start = startCount[ind * 2];
        if (start === 0)
          continue;
        var end = start + startCount[ind * 2 + 1];
        var idOrig = ind * 3;
        var vx = vAr[idOrig];
        var vy = vAr[idOrig + 1];
        var vz = vAr[idOrig + 2];
        var nx = nAr[idOrig];
        var ny = nAr[idOrig + 1];
        var nz = nAr[idOrig + 2];
        var cx = cAr[idOrig];
        var cy = cAr[idOrig + 1];
        var cz = cAr[idOrig + 2];
        var mx = mAr[idOrig];
        var my = mAr[idOrig + 1];
        var mz = mAr[idOrig + 2];
        for (var j = start; j < end; ++j) {
          var idDup = j * 3;
          vAr[idDup] = vx;
          vAr[idDup + 1] = vy;
          vAr[idDup + 2] = vz;
          nAr[idDup] = nx;
          nAr[idDup + 1] = ny;
          nAr[idDup + 2] = nz;
          cAr[idDup] = cx;
          cAr[idDup + 1] = cy;
          cAr[idDup + 2] = cz;
          mAr[idDup] = mx;
          mAr[idDup + 1] = my;
          mAr[idDup + 2] = mz;
        }
      }
    },
    updateDuplicateColorsAndMaterials: function (iVerts) {
      var mesh = this._mesh;
      if (!mesh.isUsingTexCoords() || !this.hasUV())
        return;

      var cAr = this.getColorsTexCoord();
      var mAr = this.getMaterialsTexCoord();
      var startCount = this.getVerticesDuplicateStartCount();

      var full = iVerts === undefined;
      var nbVerts = full ? mesh.getNbVertices() : iVerts.length;
      for (var i = 0; i < nbVerts; ++i) {
        var ind = full ? i : iVerts[i];
        var start = startCount[ind * 2];
        if (start === 0)
          continue;
        var end = start + startCount[ind * 2 + 1];
        var idOrig = ind * 3;
        var cx = cAr[idOrig];
        var cy = cAr[idOrig + 1];
        var cz = cAr[idOrig + 2];
        var mx = mAr[idOrig];
        var my = mAr[idOrig + 1];
        var mz = mAr[idOrig + 2];
        for (var j = start; j < end; ++j) {
          var idDup = j * 3;
          cAr[idDup] = cx;
          cAr[idDup + 1] = cy;
          cAr[idDup + 2] = cz;
          mAr[idDup] = mx;
          mAr[idDup + 1] = my;
          mAr[idDup + 2] = mz;
        }
      }
    },
    initTexCoordsDataFromOBJData: function (uvAr, uvfArOrig) {
      var mesh = this._mesh;
      var fAr = mesh.getFaces();
      var nbVertices = mesh.getNbVertices();
      var i = 0;
      var j = 0;
      var iv = 0;
      var tag = 0;

      // detect duplicates vertices because of tex coords
      var tagV = new Int32Array(nbVertices);
      // vertex without uv might receive random values...
      var tArTemp = new Float32Array(Utils.getMemory(nbVertices * 4 * 2), 0, nbVertices * 2);
      var dup = [];
      var acc = 0;
      var nbDuplicates = 0;
      var len = fAr.length;
      for (i = 0; i < len; ++i) {
        iv = fAr[i];
        if (iv < 0)
          continue;
        var uv = uvfArOrig[i];
        tag = tagV[iv];
        if (tag === (uv + 1))
          continue;
        if (tag === 0) {
          tagV[iv] = uv + 1;
          tArTemp[iv * 2] = uvAr[uv * 2];
          tArTemp[iv * 2 + 1] = uvAr[uv * 2 + 1];
          continue;
        }
        // first duplicate
        if (tag > 0) {
          tagV[iv] = --acc;
          dup.push([uv]);
          ++nbDuplicates;
          continue;
        }
        // check if we need to insert a new duplicate
        var dupArray = dup[-tag - 1];
        var nbDup = dupArray.length;
        for (j = 0; j < nbDup; ++j) {
          if (dupArray[j] === uv)
            break;
        }
        // insert new duplicate
        if (j === nbDup) {
          ++nbDuplicates;
          dupArray.push(uv);
        }
      }

      // order the duplicates vertices (and tex coords)
      var tAr = new Float32Array((nbVertices + nbDuplicates) * 2);
      tAr.set(tArTemp);
      var startCount = this._duplicateStartCount = new Uint32Array(nbVertices * 2);
      acc = 0;
      for (i = 0; i < nbVertices; ++i) {
        tag = tagV[i];
        if (tag >= 0)
          continue;
        var dAr = dup[-tag - 1];
        var nbDu = dAr.length;
        var start = nbVertices + acc;
        startCount[i * 2] = start;
        startCount[i * 2 + 1] = nbDu;
        acc += nbDu;
        for (j = 0; j < nbDu; ++j) {
          var idUv = dAr[j] * 2;
          var idUvCoord = (start + j) * 2;
          tAr[idUvCoord] = uvAr[idUv];
          tAr[idUvCoord + 1] = uvAr[idUv + 1];
        }
      }

      // create faces that uses duplicates vertices (with textures coordinates)
      var uvfAr = new Int32Array(fAr);
      len = fAr.length;
      for (i = 0; i < len; ++i) {
        iv = uvfAr[i];
        if (iv < 0)
          continue;
        tag = tagV[iv];
        if (tag > 0)
          continue;
        var idtex = uvfArOrig[i];
        var dArray = dup[-tag - 1];
        var nbEl = dArray.length;
        for (j = 0; j < nbEl; ++j) {
          if (idtex === dArray[j]) {
            uvfAr[i] = startCount[iv * 2] + j;
            break;
          }
        }
      }

      this.setTexCoords(tAr);
      this.setFacesTexCoord(uvfAr);
    }
  };

  module.exports = TexCoordsData;
});
define('mesh/meshData/TransformData',['require','exports','module','lib/glMatrix','misc/Utils'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Utils = require('misc/Utils');

  var vec3 = glm.vec3;
  var mat3 = glm.mat3;
  var mat4 = glm.mat4;

  var TransformData = function (mesh) {
    this._mesh = mesh; // the mesh

    this._center = vec3.create(); // center of the mesh (local space, before transformation)
    this._matrix = mat4.create(); // transformation matrix of the mesh
    this._editMatrix = mat4.create(); // edit matrix

    this._symmetryNormal = [1.0, 0.0, 0.0]; // symmetry normal

    // the model-view and model-view-projection and normal matrices 
    // are computed at the beginning of each frame (after camera update)
    this._cacheMV = mat4.create(); // MV matrix
    this._cacheMVP = mat4.create(); // MVP matrix
    this._cacheN = mat3.create(); // N matrix
    this._cacheEN = mat3.create(); // Editmatrix N matrix
    this._cacheDepth = 0.0; // depth of center

    this._worldBound = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity];
  };

  TransformData.prototype = {
    getCenter: function () {
      return this._center;
    },
    getMV: function () {
      return this._cacheMV;
    },
    getMVP: function () {
      return this._cacheMVP;
    },
    getN: function () {
      return this._cacheN;
    },
    getEN: function () {
      return this._cacheEN;
    },
    getDepth: function () {
      return this._cacheDepth;
    },
    getMatrix: function () {
      return this._matrix;
    },
    getEditMatrix: function () {
      return this._editMatrix;
    },
    getScale2: function () {
      var m = this._matrix;
      return m[0] * m[0] + m[4] * m[4] + m[8] * m[8];
    },
    getScale: function () {
      return Math.sqrt(this.getScale2());
    },
    getSymmetryOrigin: function () {
      return this._center;
    },
    getSymmetryNormal: function () {
      return this._symmetryNormal;
    },
    updateCenter: function () {
      var box = this._mesh.getLocalBound();
      vec3.set(this._center, (box[0] + box[3]) * 0.5, (box[1] + box[4]) * 0.5, (box[2] + box[5]) * 0.5);
    },
    /** Pre compute mv and mvp matrices as well as the depth center */
    updateMatrices: function (camera) {
      mat3.normalFromMat4(this._cacheEN, this._editMatrix);
      mat4.mul(this._cacheMV, camera.getView(), this._matrix);
      mat3.normalFromMat4(this._cacheN, this._cacheMV);
      mat4.mul(this._cacheMVP, camera.getProjection(), this._cacheMV);
      var cen = this._center;
      var m = this._cacheMVP;
      this._cacheDepth = m[2] * cen[0] + m[6] * cen[1] + m[10] * cen[2] + m[14];
    },
    normalizeSize: function () {
      var box = this._mesh.getLocalBound();
      var diag = vec3.dist([box[0], box[1], box[2]], [box[3], box[4], box[5]]);
      var scale = Utils.SCALE / diag;
      mat4.scale(this._matrix, this._matrix, [scale, scale, scale]);
    },
    translate: function (trans) {
      mat4.translate(this._matrix, this._matrix, trans);
    },
    moveTo: (function () {
      var dummy = [0.0, 0.0, 0.0];
      return function (destination) {
        mat4.translate(this._matrix, this._matrix, vec3.sub(dummy, destination, this._center));
      };
    })(),
    getWorldBound: function () {
      var worldb = this._worldBound;
      var localb = this._mesh.getLocalBound();
      var mat = this._mesh.getMatrix();

      // trans
      worldb[0] = worldb[3] = mat[12];
      worldb[1] = worldb[4] = mat[13];
      worldb[2] = worldb[5] = mat[14];

      // rotate per component
      for (var i = 0; i < 3; ++i) {
        var i4 = i * 4;
        var mini = localb[i];
        var maxi = localb[i + 3];
        for (var j = 0; j < 3; ++j) {
          var cm = mat[i4 + j];
          var a = cm * maxi;
          var b = cm * mini;
          if (a < b) {
            worldb[j] += a;
            worldb[j + 3] += b;
          } else {
            worldb[j] += b;
            worldb[j + 3] += a;
          }
        }
      }

      return worldb;
    }
  };

  module.exports = TransformData;
});
define('mesh/meshData/VertexData',['require','exports','module','misc/Utils'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');

  var VertexData = function (mesh) {
    this._mesh = mesh; // the mesh

    // attributes vertex ( no duplicates )
    this._verticesXYZ = null; // vertices (Float32Array)
    this._colorsRGB = null; // color vertices (Float32Array)
    // it doesn't really make sense to put the masking data here but I am too lazy to manage
    // a separate buffer (it would imply changes on : subdivision/reversion/renderBuffer/dynamicMesh)
    this._materialsPBR = null; // pbr vertex data (Float32Array) roughness/metallic/masking
    this._normalsXYZ = null; // normals (Float32Array)

    // topology stuffs
    this._vertOnEdge = null; // vertices on edge (Uint8Array) (1 => on edge)
    this._vrfStartCount = null; // array of neighborhood faces (start/count) (Uint32Array)
    this._vertRingFace = null; // array of neighborhood faces (Uint32Array)
    this._vrvStartCount = null; // array of neighborhood vertices (start/count) (Uint32Array)
    this._vertRingVert = null; // array neighborhood vertices (Uint32Array)

    // flag for general purposes stuff
    this._vertTagFlags = null; // tag flags (<= Utils.TAG_FLAG) (Int32Array)
    // flag for editing (tag vertices on each start of a sculpting session)
    this._vertSculptFlags = null; // sculpt flags (<= Utils.SCULPT_FLAG) (Int32Array)
    // flag for history (tag vertices on each start of a sculpting session)
    this._vertStateFlags = null; // state flags (<= Utils.STATE_FLAG) (Int32Array)

    this._vertProxy = null; // vertex proxy (Float32Array)
  };

  VertexData.prototype = {
    setVertices: function (vAr) {
      this._verticesXYZ = vAr;
    },
    setNormals: function (nAr) {
      this._normalsXYZ = nAr;
    },
    setColors: function (cAr) {
      this._colorsRGB = cAr;
    },
    setMaterials: function (mAr) {
      this._materialsPBR = mAr;
    },
    getVertices: function () {
      return this._verticesXYZ;
    },
    getColors: function () {
      return this._colorsRGB;
    },
    getNormals: function () {
      return this._normalsXYZ;
    },
    getMaterials: function () {
      return this._materialsPBR;
    },
    getVerticesTagFlags: function () {
      return this._vertTagFlags;
    },
    getVerticesSculptFlags: function () {
      return this._vertSculptFlags;
    },
    getVerticesStateFlags: function () {
      return this._vertStateFlags;
    },
    getVerticesRingVertStartCount: function () {
      return this._vrvStartCount;
    },
    getVerticesRingVert: function () {
      return this._vertRingVert;
    },
    getVerticesRingFaceStartCount: function () {
      return this._vrfStartCount;
    },
    getVerticesRingFace: function () {
      return this._vertRingFace;
    },
    getVerticesOnEdge: function () {
      return this._vertOnEdge;
    },
    getVerticesProxy: function () {
      return this._vertProxy;
    },
    getNbVertices: function () {
      return this._verticesXYZ.length / 3;
    },
    allocateArrays: function () {
      var nbVertices = this._mesh.getNbVertices();

      this._normalsXYZ = new Float32Array(nbVertices * 3);
      this._colorsRGB = this._colorsRGB ? this._colorsRGB : new Float32Array(nbVertices * 3);
      this._materialsPBR = this._materialsPBR ? this._materialsPBR : new Float32Array(nbVertices * 3);

      this._vertOnEdge = new Uint8Array(nbVertices);

      this._vrvStartCount = new Uint32Array(nbVertices * 2);
      this._vrfStartCount = new Uint32Array(nbVertices * 2);

      this._vertTagFlags = new Int32Array(nbVertices);
      this._vertSculptFlags = new Int32Array(nbVertices);
      this._vertStateFlags = new Int32Array(nbVertices);

      this._vertProxy = new Float32Array(nbVertices * 3);
    },
    /** ONLY FOR DYNAMIC MESH */
    reAllocateArrays: function (nbAddElements) {
      var mesh = this._mesh;
      var nbDyna = this._verticesXYZ.length / 3;
      var nbVertices = mesh.getNbVertices();
      var len = nbVertices + nbAddElements;
      if (nbDyna < len || nbDyna > len * 4) {
        this._verticesXYZ = mesh.resizeArray(this._verticesXYZ, len * 3);
        this._normalsXYZ = mesh.resizeArray(this._normalsXYZ, len * 3);
        this._colorsRGB = mesh.resizeArray(this._colorsRGB, len * 3);
        this._materialsPBR = mesh.resizeArray(this._materialsPBR, len * 3);

        this._vertOnEdge = mesh.resizeArray(this._vertOnEdge, len);

        this._vertTagFlags = mesh.resizeArray(this._vertTagFlags, len);
        this._vertSculptFlags = mesh.resizeArray(this._vertSculptFlags, len);
        this._vertStateFlags = mesh.resizeArray(this._vertStateFlags, len);

        // this._vertProxy = mesh.resizeArray(this._vertProxy, len * 3);
      }
    },
    /** Init color and material array */
    initColorsAndMaterials: function () {
      var nbVertices = this._mesh.getNbVertices();
      var i = 0;
      var len = nbVertices * 3;
      if (!this._colorsRGB || this._colorsRGB.length !== len) {
        var cAr = this._colorsRGB = new Float32Array(len);
        for (i = 0; i < len; ++i)
          cAr[i] = 1.0;
      }
      if (!this._materialsPBR || this._materialsPBR.length !== len) {
        var mAr = this._materialsPBR = new Float32Array(len);
        for (i = 0; i < len; ++i) {
          var j = i * 3;
          mAr[j] = 0.18;
          mAr[j + 1] = 0.08;
          mAr[j + 2] = 1.0;
        }
      }
    },
    /** Computes faces ring around vertices */
    initFaceRings: function () {
      var mesh = this._mesh;
      var fAr = mesh.getFaces();
      var nbVertices = mesh.getNbVertices();
      var nbFaces = mesh.getNbFaces();
      var i = 0;
      var id = 0;
      var countRing = new Uint32Array(mesh.getNbVertices());
      for (i = 0; i < nbFaces; ++i) {
        id = i * 4;
        countRing[fAr[id]]++;
        countRing[fAr[id + 1]]++;
        countRing[fAr[id + 2]]++;
        var i4 = fAr[id + 3];
        if (i4 >= 0)
          countRing[i4]++;
      }
      var ringFace = this.getVerticesRingFaceStartCount();
      var acc = 0;
      for (i = 0; i < nbVertices; ++i) {
        var count = countRing[i];
        ringFace[i * 2] = acc;
        ringFace[i * 2 + 1] = count;
        acc += count;
      }
      var vrf = new Uint32Array(Utils.getMemory(4 * nbFaces * 6), 0, nbFaces * 6);
      acc = 0;
      for (i = 0; i < nbFaces; ++i) {
        id = i * 4;
        var iv1 = fAr[id];
        var iv2 = fAr[id + 1];
        var iv3 = fAr[id + 2];
        var iv4 = fAr[id + 3];
        vrf[ringFace[iv1 * 2] + (--countRing[iv1])] = i;
        vrf[ringFace[iv2 * 2] + (--countRing[iv2])] = i;
        vrf[ringFace[iv3 * 2] + (--countRing[iv3])] = i;
        if (iv4 >= 0) {
          vrf[ringFace[iv4 * 2] + (--countRing[iv4])] = i;
          ++acc;
        }
      }
      this._vertRingFace = new Uint32Array(vrf.subarray(0, nbFaces * 3 + acc));
    },
    /** Update a group of vertices' normal */
    updateVerticesNormal: function (iVerts) {
      var mesh = this._mesh;
      var vrfStartCount = this.getVerticesRingFaceStartCount();
      var vertRingFace = this.getVerticesRingFace();
      var ringFaces = vertRingFace instanceof Array ? vertRingFace : null;
      var nAr = this.getNormals();
      var faceNormals = mesh.getFaceNormals();

      var full = iVerts === undefined;
      var nbVerts = full ? mesh.getNbVertices() : iVerts.length;
      for (var i = 0; i < nbVerts; ++i) {
        var ind = full ? i : iVerts[i];
        var start, end;
        if (ringFaces) {
          vertRingFace = ringFaces[ind];
          start = 0;
          end = vertRingFace.length;
        } else {
          start = vrfStartCount[ind * 2];
          end = start + vrfStartCount[ind * 2 + 1];
        }
        var nx = 0.0;
        var ny = 0.0;
        var nz = 0.0;
        for (var j = start; j < end; ++j) {
          var id = vertRingFace[j] * 3;
          nx += faceNormals[id];
          ny += faceNormals[id + 1];
          nz += faceNormals[id + 2];
        }
        var len = 1.0 / (end - start);
        ind *= 3;
        nAr[ind] = nx * len;
        nAr[ind + 1] = ny * len;
        nAr[ind + 2] = nz * len;
      }
    },
    /** Computes vertex ring around vertices */
    initVertexRings: function () {
      var mesh = this._mesh;
      var vrvStartCount = this.getVerticesRingVertStartCount();
      var vertRingVert = this._vertRingVert = new Uint32Array(mesh.getNbEdges() * 2);
      var vrfStartCount = this.getVerticesRingFaceStartCount();
      var vertRingFace = this.getVerticesRingFace();
      var vertTagFlags = this.getVerticesTagFlags();
      var vertOnEdge = this.getVerticesOnEdge();
      var fAr = mesh.getFaces();
      var vrvStart = 0;
      for (var i = 0, l = mesh.getNbVertices(); i < l; ++i) {
        var tagFlag = ++Utils.TAG_FLAG;
        var vrfStart = vrfStartCount[i * 2];
        var vrfEnd = vrfStart + vrfStartCount[i * 2 + 1];
        var vrvCount = 0;
        for (var j = vrfStart; j < vrfEnd; ++j) {
          var ind = vertRingFace[j] * 4;
          var iVer1 = fAr[ind];
          var iVer2 = fAr[ind + 1];
          var iVer3 = fAr[ind + 2];
          var iVer4 = fAr[ind + 3];
          if (iVer1 === i)
            iVer1 = iVer4 >= 0 ? iVer4 : iVer3;
          else if (iVer2 === i || iVer4 === i)
            iVer2 = iVer3;
          else if (iVer3 === i && iVer4 >= 0)
            iVer1 = iVer4;
          if (vertTagFlags[iVer1] !== tagFlag) {
            vertRingVert[vrvStart + (vrvCount++)] = iVer1;
            vertTagFlags[iVer1] = tagFlag;
          }
          if (vertTagFlags[iVer2] !== tagFlag) {
            vertRingVert[vrvStart + (vrvCount++)] = iVer2;
            vertTagFlags[iVer2] = tagFlag;
          }
        }
        vrvStartCount[i * 2] = vrvStart;
        vrvStartCount[i * 2 + 1] = vrvCount;
        vrvStart += vrvCount;
        if ((vrfEnd - vrfStart) !== vrvCount)
          vertOnEdge[i] = 1;
      }
    },
    /** Get more vertices (n-ring) */
    expandsVertices: function (iVerts, nRing) {
      var tagFlag = ++Utils.TAG_FLAG;
      var nbVerts = iVerts.length;
      var vrvStartCount = this.getVerticesRingVertStartCount();
      var vertRingVert = this.getVerticesRingVert();
      var ringVerts = vertRingVert instanceof Array ? vertRingVert : null;
      var vertTagFlags = this.getVerticesTagFlags();
      var acc = nbVerts;
      var nbVertices = this._mesh.getNbVertices();
      var iVertsExpanded = new Uint32Array(Utils.getMemory(4 * nbVertices), 0, nbVertices);
      iVertsExpanded.set(iVerts);
      var i = 0;
      for (i = 0; i < nbVerts; ++i)
        vertTagFlags[iVertsExpanded[i]] = tagFlag;
      var iBegin = 0;
      while (nRing) {
        --nRing;
        for (i = iBegin; i < nbVerts; ++i) {
          var idVert = iVertsExpanded[i];
          var start, end;
          if (ringVerts) {
            vertRingVert = ringVerts[idVert];
            start = 0;
            end = vertRingVert.length;
          } else {
            start = vrvStartCount[idVert * 2];
            end = start + vrvStartCount[idVert * 2 + 1];
          }
          for (var j = start; j < end; ++j) {
            var id = vertRingVert[j];
            if (vertTagFlags[id] === tagFlag)
              continue;
            vertTagFlags[id] = tagFlag;
            iVertsExpanded[acc++] = id;
          }
        }
        iBegin = nbVerts;
        nbVerts = acc;
      }
      return new Uint32Array(iVertsExpanded.subarray(0, acc));
    },
    /** Return all the vertices linked to a group of faces */
    getVerticesFromFaces: function (iFaces) {
      var mesh = this._mesh;
      var tagFlag = ++Utils.TAG_FLAG;
      var nbFaces = iFaces.length;
      var vertTagFlags = this.getVerticesTagFlags();
      var fAr = mesh.getFaces();
      var acc = 0;
      var verts = new Uint32Array(Utils.getMemory(4 * iFaces.length * 4), 0, iFaces.length * 4);
      for (var i = 0; i < nbFaces; ++i) {
        var ind = iFaces[i] * 4;
        var iVer1 = fAr[ind];
        var iVer2 = fAr[ind + 1];
        var iVer3 = fAr[ind + 2];
        var iVer4 = fAr[ind + 3];
        if (vertTagFlags[iVer1] !== tagFlag) {
          vertTagFlags[iVer1] = tagFlag;
          verts[acc++] = iVer1;
        }
        if (vertTagFlags[iVer2] !== tagFlag) {
          vertTagFlags[iVer2] = tagFlag;
          verts[acc++] = iVer2;
        }
        if (vertTagFlags[iVer3] !== tagFlag) {
          vertTagFlags[iVer3] = tagFlag;
          verts[acc++] = iVer3;
        }
        if (iVer4 >= 0 && vertTagFlags[iVer4] !== tagFlag) {
          vertTagFlags[iVer4] = tagFlag;
          verts[acc++] = iVer4;
        }
      }
      return new Uint32Array(verts.subarray(0, acc));
    }
  };

  module.exports = VertexData;
});
define('mesh/meshData/WireframeData',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var WireframeData = function (mesh) {
    this._mesh = mesh; // the mesh
    this._drawArraysWireframe = null; // array for the wireframe (base on drawArrays vertices)
    this._drawElementsWireframe = null; // array for the wireframe (base on drawElements vertices)
  };

  WireframeData.prototype = {
    /** Return wireframe array (or compute it if not up to date) */
    getWireframe: function () {
      var mesh = this._mesh;
      var nbEdges = mesh.getNbEdges();
      var cdw;
      var useDrawArrays = this._mesh.isUsingDrawArrays();
      if (useDrawArrays) {
        if (this._drawArraysWireframe && this._drawArraysWireframe.length === nbEdges * 2) {
          return this._drawArraysWireframe;
        }
        cdw = this._drawArraysWireframe = new Uint32Array(nbEdges * 2);
      } else {
        if (this._drawElementsWireframe && this._drawElementsWireframe.length === nbEdges * 2) {
          return this._drawElementsWireframe;
        }
        cdw = this._drawElementsWireframe = new Uint32Array(nbEdges * 2);
      }

      var fAr = mesh.getFaces();
      var feAr = mesh.getFaceEdges();
      var nbFaces = mesh.getNbFaces();
      var facesToTris = mesh.getFacesToTriangles();

      var nbLines = 0;
      var tagEdges = new Int32Array(nbEdges);

      for (var i = 0; i < nbFaces; ++i) {
        var id = i * 4;

        var iv1, iv2, iv3;
        var iv4 = fAr[id + 3];
        if (useDrawArrays) {
          var idTri = facesToTris[i] * 3;
          iv1 = idTri;
          iv2 = idTri + 1;
          iv3 = idTri + 2;
          if (iv4 >= 0) iv4 = idTri + 5;
        } else {
          iv1 = fAr[id];
          iv2 = fAr[id + 1];
          iv3 = fAr[id + 2];
        }

        var ide1 = feAr[id];
        var ide2 = feAr[id + 1];
        var ide3 = feAr[id + 2];
        var ide4 = feAr[id + 3];

        if (tagEdges[ide1] === 0) {
          tagEdges[ide1] = 1;
          cdw[nbLines * 2] = iv1;
          cdw[nbLines * 2 + 1] = iv2;
          nbLines++;
        }
        if (tagEdges[ide2] === 0) {
          tagEdges[ide2] = 1;
          cdw[nbLines * 2] = iv2;
          cdw[nbLines * 2 + 1] = iv3;
          nbLines++;
        }
        if (tagEdges[ide3] === 0) {
          tagEdges[ide3] = 1;
          cdw[nbLines * 2] = iv3;
          cdw[nbLines * 2 + 1] = iv4 < 0 ? iv1 : iv4;
          nbLines++;
        }
        if (iv4 >= 0 && tagEdges[ide4] === 0) {
          tagEdges[ide4] = 1;
          cdw[nbLines * 2] = iv4;
          cdw[nbLines * 2 + 1] = iv1;
          nbLines++;
        }
      }
      return useDrawArrays ? this._drawArraysWireframe : this._drawElementsWireframe;
    }
  };

  module.exports = WireframeData;
});
define('mesh/meshData/MeshData',['require','exports','module','misc/Utils','mesh/meshData/DrawArraysData','mesh/meshData/EdgeData','mesh/meshData/FaceData','mesh/meshData/TexCoordsData','mesh/meshData/TransformData','mesh/meshData/VertexData','mesh/meshData/WireframeData'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var DrawArraysData = require('mesh/meshData/DrawArraysData');
  var EdgeData = require('mesh/meshData/EdgeData');
  var FaceData = require('mesh/meshData/FaceData');
  var TexCoordsData = require('mesh/meshData/TexCoordsData');
  var TransformData = require('mesh/meshData/TransformData');
  var VertexData = require('mesh/meshData/VertexData');
  var WireframeData = require('mesh/meshData/WireframeData');

  var MeshData = function (mesh) {
    this._mesh = mesh; // the mesh

    this._drawArraysData = new DrawArraysData(mesh); // the wireframe data
    this._edgeData = new EdgeData(mesh); // the edge data
    this._faceData = new FaceData(mesh); // the index data
    this._texCoordsData = new TexCoordsData(mesh); // the uv data
    this._vertexData = new VertexData(mesh); // the vertex data
    this._wireframeData = new WireframeData(mesh); // the wireframe data
    this._transformData = new TransformData(mesh); // the transform data
  };

  MeshData.prototype = {
    getDrawArraysData: function () {
      return this._drawArraysData;
    },
    getEdgeData: function () {
      return this._edgeData;
    },
    getFaceData: function () {
      return this._faceData;
    },
    getTexCoordsData: function () {
      return this._texCoordsData;
    },
    getTransformData: function () {
      return this._transformData;
    },
    getVertexData: function () {
      return this._vertexData;
    },
    getWireframeData: function () {
      return this._wireframeData;
    },
    setDrawArraysData: function (data) {
      this._drawArraysData = data;
    },
    setEdgeData: function (data) {
      this._edgeData = data;
    },
    setFaceData: function (data) {
      this._faceData = data;
    },
    setTexCoordsData: function (data) {
      this._texCoordsData = data;
    },
    setTransformData: function (data) {
      this._transformData = data;
    },
    setVertexData: function (data) {
      this._vertexData = data;
    },
    setWireframeData: function (data) {
      this._wireframeData = data;
    }
  };

  // Basically... Mesh is a proxy/interface of all the data stuffs

  Utils.makeProxy(DrawArraysData, MeshData, function (proto) {
    return function () {
      return proto.apply(this.getDrawArraysData(), arguments);
    };
  });

  Utils.makeProxy(EdgeData, MeshData, function (proto) {
    return function () {
      return proto.apply(this.getEdgeData(), arguments);
    };
  });

  Utils.makeProxy(FaceData, MeshData, function (proto) {
    return function () {
      return proto.apply(this.getFaceData(), arguments);
    };
  });

  Utils.makeProxy(TexCoordsData, MeshData, function (proto) {
    return function () {
      return proto.apply(this.getTexCoordsData(), arguments);
    };
  });

  Utils.makeProxy(TransformData, MeshData, function (proto) {
    return function () {
      return proto.apply(this.getTransformData(), arguments);
    };
  });

  Utils.makeProxy(VertexData, MeshData, function (proto) {
    return function () {
      return proto.apply(this.getVertexData(), arguments);
    };
  });

  Utils.makeProxy(WireframeData, MeshData, function (proto) {
    return function () {
      return proto.apply(this.getWireframeData(), arguments);
    };
  });

  module.exports = MeshData;
});
define('math3d/OctreeCell',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var OctreeCell = function (parent) {
    this._parent = parent ? parent : null; // parent
    this._depth = parent ? parent._depth + 1 : 0; // depth of current node
    this._children = []; // children
    // extended boundary for intersect test
    this._aabbLoose = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity];
    // boundary in order to store exactly the face according to their center
    this._aabbSplit = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity];
    this._iFaces = []; // faces (if cell is a leaf)
  };

  OctreeCell.MAX_DEPTH = 8; // maximum depth
  OctreeCell.MAX_FACES = 100; // maximum faces per cell
  (function () {
    var nb = OctreeCell.MAX_DEPTH * OctreeCell.MAX_DEPTH + OctreeCell.MAX_DEPTH;
    var stack = OctreeCell.STACK = new Array(nb);
    for (var i = 0; i < nb; ++i)
      stack[i] = null;
  })();

  OctreeCell.prototype = {
    /** Subdivide octree, aabbSplit must be already set, and aabbLoose will be expanded if it's a leaf  */
    build: function (mesh, iFaces) {
      var aabbLoose = this._aabbLoose;
      var aabbSplit = this._aabbSplit;
      var i = 0;
      for (i = 0; i < 6; ++i)
        aabbLoose[i] = aabbSplit[i];
      this._iFaces = iFaces;

      var stack = OctreeCell.STACK;
      stack[0] = this;
      var curStack = 1;
      var leaves = [];
      while (curStack > 0) {
        var cell = stack[--curStack];
        var nbFaces = cell._iFaces.length;
        if (nbFaces > OctreeCell.MAX_FACES && cell._depth < OctreeCell.MAX_DEPTH) {
          cell.constructChildren(mesh);
          var children = cell._children;
          for (i = 0; i < 8; ++i)
            stack[curStack + i] = children[i];
          curStack += 8;
        } else if (nbFaces > 0) {
          leaves.push(cell);
        }
      }
      var nbLeaves = leaves.length;
      for (i = 0; i < nbLeaves; ++i)
        leaves[i].constructLeaf(mesh);
    },
    /** Construct the leaf  */
    constructLeaf: function (mesh) {
      var iFaces = this._iFaces;
      var nbFaces = iFaces.length;
      var bxmin = Infinity;
      var bymin = Infinity;
      var bzmin = Infinity;
      var bxmax = -Infinity;
      var bymax = -Infinity;
      var bzmax = -Infinity;
      var faceBoxes = mesh.getFaceBoxes();
      var facePosInLeaf = mesh.getFacePosInLeaf();
      var faceLeaf = mesh.getFaceLeaf();
      for (var i = 0; i < nbFaces; ++i) {
        var id = iFaces[i];
        faceLeaf[id] = this;
        facePosInLeaf[id] = i;
        id *= 6;
        var xmin = faceBoxes[id];
        var ymin = faceBoxes[id + 1];
        var zmin = faceBoxes[id + 2];
        var xmax = faceBoxes[id + 3];
        var ymax = faceBoxes[id + 4];
        var zmax = faceBoxes[id + 5];
        if (xmin < bxmin) bxmin = xmin;
        if (xmax > bxmax) bxmax = xmax;
        if (ymin < bymin) bymin = ymin;
        if (ymax > bymax) bymax = ymax;
        if (zmin < bzmin) bzmin = zmin;
        if (zmax > bzmax) bzmax = zmax;
      }
      this.expandsAabbLoose(bxmin, bymin, bzmin, bxmax, bymax, bzmax);
    },
    /** Construct sub cells of the octree */
    constructChildren: function (mesh) {
      var split = this._aabbSplit;
      var xmin = split[0];
      var ymin = split[1];
      var zmin = split[2];
      var xmax = split[3];
      var ymax = split[4];
      var zmax = split[5];
      var dX = (xmax - xmin) * 0.5;
      var dY = (ymax - ymin) * 0.5;
      var dZ = (zmax - zmin) * 0.5;
      var xcen = (xmax + xmin) * 0.5;
      var ycen = (ymax + ymin) * 0.5;
      var zcen = (zmax + zmin) * 0.5;

      var child0 = new OctreeCell(this);
      var child1 = new OctreeCell(this);
      var child2 = new OctreeCell(this);
      var child3 = new OctreeCell(this);
      var child4 = new OctreeCell(this);
      var child5 = new OctreeCell(this);
      var child6 = new OctreeCell(this);
      var child7 = new OctreeCell(this);

      var iFaces0 = child0._iFaces;
      var iFaces1 = child1._iFaces;
      var iFaces2 = child2._iFaces;
      var iFaces3 = child3._iFaces;
      var iFaces4 = child4._iFaces;
      var iFaces5 = child5._iFaces;
      var iFaces6 = child6._iFaces;
      var iFaces7 = child7._iFaces;
      var faceCenters = mesh.getFaceCenters();
      var iFaces = this._iFaces;
      var nbFaces = iFaces.length;
      for (var i = 0; i < nbFaces; ++i) {
        var iFace = iFaces[i];
        var id = iFace * 3;
        var cx = faceCenters[id];
        var cy = faceCenters[id + 1];
        var cz = faceCenters[id + 2];

        if (cx > xcen) {
          if (cy > ycen) {
            if (cz > zcen) iFaces6.push(iFace);
            else iFaces5.push(iFace);
          } else {
            if (cz > zcen) iFaces2.push(iFace);
            else iFaces1.push(iFace);
          }
        } else {
          if (cy > ycen) {
            if (cz > zcen) iFaces7.push(iFace);
            else iFaces4.push(iFace);
          } else {
            if (cz > zcen) iFaces3.push(iFace);
            else iFaces0.push(iFace);
          }
        }
      }
      child0.setAabbSplit(xmin, ymin, zmin, xcen, ycen, zcen);
      child1.setAabbSplit(xmin + dX, ymin, zmin, xcen + dX, ycen, zcen);
      child2.setAabbSplit(xcen, ycen - dY, zcen, xmax, ymax - dY, zmax);
      child3.setAabbSplit(xmin, ymin, zmin + dZ, xcen, ycen, zcen + dZ);
      child4.setAabbSplit(xmin, ymin + dY, zmin, xcen, ycen + dY, zcen);
      child5.setAabbSplit(xcen, ycen, zcen - dZ, xmax, ymax, zmax - dZ);
      child6.setAabbSplit(xcen, ycen, zcen, xmax, ymax, zmax);
      child7.setAabbSplit(xcen - dX, ycen, zcen, xmax - dX, ymax, zmax);

      this._children.length = 0;
      this._children.push(child0, child1, child2, child3, child4, child5, child6, child7);
      iFaces.length = 0;
    },
    setAabbSplit: function (xmin, ymin, zmin, xmax, ymax, zmax) {
      var aabb = this._aabbSplit;
      aabb[0] = xmin;
      aabb[1] = ymin;
      aabb[2] = zmin;
      aabb[3] = xmax;
      aabb[4] = ymax;
      aabb[5] = zmax;
    },
    /** Collect faces in cells hit by a ray */
    collectIntersectRay: function (vNear, eyeDir, collectFaces) {
      var vx = vNear[0];
      var vy = vNear[1];
      var vz = vNear[2];
      var irx = 1.0 / eyeDir[0];
      var iry = 1.0 / eyeDir[1];
      var irz = 1.0 / eyeDir[2];
      var acc = 0;

      var stack = OctreeCell.STACK;
      stack[0] = this;
      var curStack = 1;
      while (curStack > 0) {
        var cell = stack[--curStack];
        var loose = cell._aabbLoose;
        var t1 = (loose[0] - vx) * irx;
        var t2 = (loose[3] - vx) * irx;
        var t3 = (loose[1] - vy) * iry;
        var t4 = (loose[4] - vy) * iry;
        var t5 = (loose[2] - vz) * irz;
        var t6 = (loose[5] - vz) * irz;
        var tmin = Math.max(Math.min(t1, t2), Math.min(t3, t4), Math.min(t5, t6));
        var tmax = Math.min(Math.max(t1, t2), Math.max(t3, t4), Math.max(t5, t6));
        if (tmax < 0 || tmin > tmax) // no intersection
          continue;
        var children = cell._children;
        if (children.length === 8) {
          for (var i = 0; i < 8; ++i)
            stack[curStack + i] = children[i];
          curStack += 8;
        } else {
          var iFaces = cell._iFaces;
          collectFaces.set(iFaces, acc);
          acc += iFaces.length;
        }
      }
      return new Uint32Array(collectFaces.subarray(0, acc));
    },
    /** Collect faces inside a sphere */
    collectIntersectSphere: function (vert, radiusSquared, leavesHit, collectFaces) {
      var vx = vert[0];
      var vy = vert[1];
      var vz = vert[2];
      var acc = 0;

      var stack = OctreeCell.STACK;
      stack[0] = this;
      var curStack = 1;
      while (curStack > 0) {
        var cell = stack[--curStack];
        var loose = cell._aabbLoose;
        var dx = 0.0;
        var dy = 0.0;
        var dz = 0.0;

        if (loose[0] > vx) dx = loose[0] - vx;
        else if (loose[3] < vx) dx = loose[3] - vx;
        else dx = 0.0;

        if (loose[1] > vy) dy = loose[1] - vy;
        else if (loose[4] < vy) dy = loose[4] - vy;
        else dy = 0.0;

        if (loose[2] > vz) dz = loose[2] - vz;
        else if (loose[5] < vz) dz = loose[5] - vz;
        else dz = 0.0;

        if ((dx * dx + dy * dy + dz * dz) > radiusSquared) // no intersection
          continue;

        var children = cell._children;
        if (children.length === 8) {
          for (var i = 0; i < 8; ++i)
            stack[curStack + i] = children[i];
          curStack += 8;
        } else {
          leavesHit.push(cell);
          var iFaces = cell._iFaces;
          collectFaces.set(iFaces, acc);
          acc += iFaces.length;
        }
      }
      return new Uint32Array(collectFaces.subarray(0, acc));
    },
    /** Add a face in the octree, subdivide the cell if necessary */
    addFace: function (faceId, bxmin, bymin, bzmin, bxmax, bymax, bzmax, cx, cy, cz) {
      var stack = OctreeCell.STACK;
      stack[0] = this;
      var curStack = 1;
      while (curStack > 0) {
        var cell = stack[--curStack];
        var split = cell._aabbSplit;
        if (cx <= split[0]) continue;
        if (cy <= split[1]) continue;
        if (cz <= split[2]) continue;
        if (cx > split[3]) continue;
        if (cy > split[4]) continue;
        if (cz > split[5]) continue;
        var loose = cell._aabbLoose;
        // expands cell aabb loose with aabb face
        if (bxmin < loose[0]) loose[0] = bxmin;
        if (bymin < loose[1]) loose[1] = bymin;
        if (bzmin < loose[2]) loose[2] = bzmin;
        if (bxmax > loose[3]) loose[3] = bxmax;
        if (bymax > loose[4]) loose[4] = bymax;
        if (bzmax > loose[5]) loose[5] = bzmax;
        var children = cell._children;
        if (children.length === 8) {
          for (var i = 0; i < 8; ++i)
            stack[curStack + i] = children[i];
          curStack += 8;
        } else {
          cell._iFaces.push(faceId);
          return cell;
        }
      }
    },
    /** Cut leaves if needed */
    checkEmptiness: function () {
      var stack = OctreeCell.STACK;
      stack[0] = this;
      var curStack = 1;
      while (curStack > 0) {
        var cell = stack[--curStack];
        var parent = cell._parent;
        if (!parent)
          continue;
        var children = parent._children;
        if (children.length === 0)
          continue;
        var pushParent = true;
        for (var i = 0; i < 8; ++i) {
          var child = children[i];
          if (child._iFaces.length > 0 || child._children.length === 8) {
            pushParent = false;
            break;
          }
        }
        if (pushParent === true) {
          children.length = 0;
          cell[curStack++] = parent;
        }
      }
    },
    /** Expand aabb loose */
    expandsAabbLoose: function (bxmin, bymin, bzmin, bxmax, bymax, bzmax) {
      var parent = this;
      while (parent) {
        var pLoose = parent._aabbLoose;
        var proceed = false;
        if (bxmin < pLoose[0]) {
          pLoose[0] = bxmin;
          proceed = true;
        }
        if (bymin < pLoose[1]) {
          pLoose[1] = bymin;
          proceed = true;
        }
        if (bzmin < pLoose[2]) {
          pLoose[2] = bzmin;
          proceed = true;
        }
        if (bxmax > pLoose[3]) {
          pLoose[3] = bxmax;
          proceed = true;
        }
        if (bymax > pLoose[4]) {
          pLoose[4] = bymax;
          proceed = true;
        }
        if (bzmax > pLoose[5]) {
          pLoose[5] = bzmax;
          proceed = true;
        }
        parent = proceed ? parent._parent : null;
      }
    }
  };

  module.exports = OctreeCell;
});
define('math3d/Octree',['require','exports','module','misc/Utils','math3d/OctreeCell'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var OctreeCell = require('math3d/OctreeCell');

  var Octree = function (mesh) {
    this._mesh = mesh; // the mesh
    this._root = null; // root octree cell

    this._facePosInLeaf = null; // position index in the leaf (Uint32Array)
    this._faceLeaf = []; // octree leaf
    this._leavesUpdate = []; // leaves of the octree to check
  };

  Octree.prototype = {
    getFacePosInLeaf: function () {
      return this._facePosInLeaf;
    },
    getFaceLeaf: function () {
      return this._faceLeaf;
    },
    getLeavesUpdate: function () {
      return this._leavesUpdate;
    },
    getLocalBound: function () {
      return this._root._aabbSplit;
    },
    allocateArrays: function () {
      var nbFaces = this._mesh.getNbFaces();
      this._facePosInLeaf = new Uint32Array(nbFaces);
      var faceLeaf = this._faceLeaf;
      faceLeaf.length = nbFaces;
      for (var i = 0; i < nbFaces; ++i)
        faceLeaf[i] = null;
    },
    /** ONLY FOR DYNAMIC MESH */
    reAllocateArrays: function (nbAddElements) {
      var mesh = this._mesh;
      var nbDyna = this._facePosInLeaf.length;
      var nbTriangles = mesh.getNbTriangles();
      var len = nbTriangles + nbAddElements;
      if (nbDyna < len || nbDyna > len * 4) {
        this._facePosInLeaf = mesh.resizeArray(this._facePosInLeaf, len);
      }
    },
    /** Return faces intersected by a ray */
    intersectRay: function (vNear, eyeDir, hint) {
      var collectFaces = new Uint32Array(Utils.getMemory(hint * 4), 0, hint);
      return this._root.collectIntersectRay(vNear, eyeDir, collectFaces);
    },
    /** Return faces inside a sphere */
    intersectSphere: function (vert, radiusSquared, leavesHit, hint) {
      var collectFaces = new Uint32Array(Utils.getMemory(hint * 4), 0, hint);
      return this._root.collectIntersectSphere(vert, radiusSquared, leavesHit, collectFaces);
    },
    /**
     * Update Octree
     * For each faces we check if its position inside the octree has changed
     * if so... we mark this face and we remove it from its former cells
     * We push back the marked faces into the octree
     */
    updateOctree: function (iFaces) {
      if (iFaces)
        this.updateOctreeAdd(this.updateOctreeRemove(iFaces));
      else
        this.computeOctree(0.3);
    },
    computeAabb: function () {
      var mesh = this._mesh;
      var nbVertices = mesh.getNbVertices();
      var vAr = mesh.getVertices();
      var xmin = Infinity;
      var ymin = Infinity;
      var zmin = Infinity;
      var xmax = -Infinity;
      var ymax = -Infinity;
      var zmax = -Infinity;
      for (var i = 0; i < nbVertices; ++i) {
        var j = i * 3;
        var vx = vAr[j];
        var vy = vAr[j + 1];
        var vz = vAr[j + 2];
        if (vx < xmin) xmin = vx;
        if (vx > xmax) xmax = vx;
        if (vy < ymin) ymin = vy;
        if (vy > ymax) ymax = vy;
        if (vz < zmin) zmin = vz;
        if (vz > zmax) zmax = vz;
      }
      return [xmin, ymin, zmin, xmax, ymax, zmax];
    },
    /** Compute the mesh octree */
    computeOctree: function (factor) {
      var mesh = this._mesh;
      var abRoot = this.computeAabb();
      var xmin = abRoot[0];
      var ymin = abRoot[1];
      var zmin = abRoot[2];
      var xmax = abRoot[3];
      var ymax = abRoot[4];
      var zmax = abRoot[5];
      var dx = xmax - xmin;
      var dy = ymax - ymin;
      var dz = zmax - zmin;
      // root octree bigger than minimum aabb...
      if (factor) {
        var dfx = dx * factor;
        var dfy = dy * factor;
        var dfz = dz * factor;
        xmin -= dfx;
        xmax += dfx;
        ymin -= dfy;
        ymax += dfy;
        zmin -= dfz;
        zmax += dfz;
      }
      var offset = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.2;
      if (xmin === xmax) {
        xmin -= offset;
        xmax += offset;
      }
      if (ymin === ymax) {
        ymin -= offset;
        ymax += offset;
      }
      if (zmin === zmax) {
        zmin -= offset;
        zmax += offset;
      }

      // octree construction
      var nbFaces = mesh.getNbFaces();
      var facesAll = [];
      facesAll.length = nbFaces;
      for (var i = 0; i < nbFaces; ++i)
        facesAll[i] = i;
      this._root = new OctreeCell();
      this._root.setAabbSplit(xmin, ymin, zmin, xmax, ymax, zmax);
      this._root.build(mesh, facesAll);
    },
    updateOctreeRemove: function (iFaces) {
      var mesh = this._mesh;
      var faceCenters = mesh.getFaceCenters();
      var fboxes = mesh.getFaceBoxes();
      var facePosInLeaf = this._facePosInLeaf;
      var faceLeaf = this._faceLeaf;
      var nbFaces = iFaces.length;
      var acc = 0;
      var facesToMove = new Uint32Array(Utils.getMemory(4 * nbFaces), 0, nbFaces);
      // recompute position inside the octree
      for (var i = 0; i < nbFaces; ++i) {
        var idFace = iFaces[i];
        var idb = idFace * 6;
        var idCen = idFace * 3;
        var leaf = faceLeaf[idFace];
        var ab = leaf._aabbSplit;

        var vx = faceCenters[idCen];
        var vy = faceCenters[idCen + 1];
        var vz = faceCenters[idCen + 2];

        if (vx <= ab[0] || vy <= ab[1] || vz <= ab[2] || vx > ab[3] || vy > ab[4] || vz > ab[5]) {
          // a face center has moved from its cell
          facesToMove[acc++] = iFaces[i];
          var facesInLeaf = leaf._iFaces;
          if (facesInLeaf.length > 0) { // remove faces from octree cell
            var iFaceLast = facesInLeaf[facesInLeaf.length - 1];
            var iPos = facePosInLeaf[idFace];
            facesInLeaf[iPos] = iFaceLast;
            facePosInLeaf[iFaceLast] = iPos;
            facesInLeaf.pop();
          }
        } else { // expands cell aabb loose if necessary
          leaf.expandsAabbLoose(fboxes[idb], fboxes[idb + 1], fboxes[idb + 2], fboxes[idb + 3], fboxes[idb + 4], fboxes[idb + 5]);
        }
      }
      return new Uint32Array(facesToMove.subarray(0, acc));
    },
    updateOctreeAdd: function (facesToMove) {
      var mesh = this._mesh;
      var fc = mesh.getFaceCenters();
      var fb = mesh.getFaceBoxes();
      var facePosInLeaf = this._facePosInLeaf;
      var faceLeaf = this._faceLeaf;
      var nbFacesToMove = facesToMove.length;

      var root = this._root;
      var rootLoose = root._aabbLoose;
      var xmin = rootLoose[0];
      var ymin = rootLoose[1];
      var zmin = rootLoose[2];
      var xmax = rootLoose[3];
      var ymax = rootLoose[4];
      var zmax = rootLoose[5];
      for (var i = 0; i < nbFacesToMove; ++i) { // add face to the octree
        var idFace = facesToMove[i];
        var idb = idFace * 6;
        var ibux = fb[idb];
        var ibuy = fb[idb + 1];
        var ibuz = fb[idb + 2];
        var iblx = fb[idb + 3];
        var ibly = fb[idb + 4];
        var iblz = fb[idb + 5];
        if (ibux > xmax || iblx < xmin || ibuy > ymax || ibly < ymin || ibuz > zmax || iblz < zmin) {
          // a face is outside the root node
          // we reconstruct the whole octree, slow... but rare
          this.computeOctree(0.3);
          this._leavesUpdate.length = 0;
          break;
        } else {
          var idc = idFace * 3;
          var leaf = faceLeaf[idFace];
          var newleaf = root.addFace(idFace, ibux, ibuy, ibuz, iblx, ibly, iblz, fc[idc], fc[idc + 1], fc[idc + 2]);
          if (newleaf) {
            facePosInLeaf[idFace] = newleaf._iFaces.length - 1;
            faceLeaf[idFace] = newleaf;
          } else { // failed to insert face in octree, re-insert it back
            var facesInLeaf = leaf._iFaces;
            facePosInLeaf[idFace] = facesInLeaf.length;
            facesInLeaf.push(facesToMove[i]);
          }
        }
      }
    },
    /** End of stroke, update octree (cut empty leaves or go deeper if needed) */
    checkLeavesUpdate: function () {
      Utils.tidy(this._leavesUpdate);
      var leavesUpdate = this._leavesUpdate;
      var nbLeaves = leavesUpdate.length;
      var cutLeaves = [];
      var maxFaces = OctreeCell.MAX_FACES;
      var maxDepth = OctreeCell.MAX_DEPTH;
      for (var i = 0; i < nbLeaves; ++i) {
        var leaf = leavesUpdate[i];
        if (!leaf)
          break;
        if (!leaf._iFaces.length)
          leaf.checkEmptiness(cutLeaves);
        else if (leaf._iFaces.length > maxFaces && leaf._depth < maxDepth)
          leaf.build(this._mesh, leaf._iFaces);
      }
      this._leavesUpdate.length = 0;
    }
  };

  module.exports = Octree;
});
define('render/Attribute',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var Attribute = function (gl, program, name, size, type) {
    this._gl = gl; // webgl context
    this._location = gl.getAttribLocation(program, name); // the location
    this._size = size; // numbe of components
    this._type = type; // type of the components
  };

  Attribute.prototype = {
    /** Update the buffer content */
    bindToBuffer: function (buffer) {
      var gl = this._gl;
      buffer.bind();
      gl.enableVertexAttribArray(this._location);
      gl.vertexAttribPointer(this._location, this._size, this._type, false, 0, 0);
    }
  };

  module.exports = Attribute;
});
/**
 * @license RequireJS text 2.0.14 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('text',['module'], function (module) {
    'use strict';

    var text, fs, Cc, Ci, xpcIsWindows,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.14',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.lastIndexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config && config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config && config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            // Do not load if it is an empty: url
            if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
            }

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node &&
            !process.versions['node-webkit'] &&
            !process.versions['atom-shell'])) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file[0] === '\uFEFF') {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                if (errback) {
                    errback(e);
                }
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status || 0;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        if (errback) {
                            errback(err);
                        }
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes;
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');
        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

        text.get = function (url, callback) {
            var inStream, convertStream, fileObj,
                readData = {};

            if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
            }

            fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});

define('text!render/shaders/glsl/colorSpace.glsl',[],function () { return '// reference\n// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt\n\n// approximation\n// http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html\nfloat lineartoSRGB(const in float c) {\n    float S1 = sqrt(c);\n    float S2 = sqrt(S1);\n    float S3 = sqrt(S2);\n    return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;\n}\nvec3 lineartoSRGB(const in vec3 c) {\n    vec3 S1 = sqrt(c);\n    vec3 S2 = sqrt(S1);\n    vec3 S3 = sqrt(S2);\n    return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;\n}\nvec4 lineartoSRGB(const in vec4 c) {\n    vec3 S1 = sqrt(c.rgb);\n    vec3 S2 = sqrt(S1);\n    vec3 S3 = sqrt(S2);\n    return vec4(0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c.rgb, c.a);\n}\n\nfloat sRGBToLinear(const in float c) {\n    return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\n}\nvec3 sRGBToLinear(const in vec3 c) {\n    return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\n}\nvec4 sRGBToLinear(const in vec4 c) {\n    return vec4(c.rgb * (c.rgb * (c.rgb * 0.305306011 + 0.682171111) + 0.012522878), c.a);\n}\n\n#define RANGE 1.0\n// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html\nvec4 encodeRGBM(const in vec3 col) {\n    vec4 rgbm;\n    vec3 color = col / RANGE;\n    rgbm.a = clamp( max( max( color.r, color.g ), max( color.b, 1e-6 ) ), 0.0, 1.0 );\n    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;\n    rgbm.rgb = color / rgbm.a;\n    return rgbm;\n}\n\nvec3 decodeRGBM(const in vec4 col) {\n  return RANGE * col.rgb * col.a;\n}';});


define('text!render/shaders/glsl/curvature.glsl',[],function () { return '// http://madebyevan.com/shaders/curvature/\n#extension GL_OES_standard_derivatives : enable\nvec3 computeCurvature( const in vec3 vertex, const in vec3 normal, const in vec3 color, const in float str, const in float fov) {\n  if(str < 1e-3)\n    return color;\n  #ifndef GL_OES_standard_derivatives\n    return color * pow(length(normal), str * 100.0);\n  #endif\n  vec3 n = normalize(normal);\n  // Compute curvature\n  vec3 dx = dFdx(n);\n  vec3 dy = dFdy(n);\n  vec3 xneg = n - dx;\n  vec3 xpos = n + dx;\n  vec3 yneg = n - dy;\n  vec3 ypos = n + dy;\n  // fov < 0.0 means ortho\n  float depth = fov > 0.0 ? length(vertex) * fov : -fov;\n  float cur = (cross(xneg, xpos).y - cross(yneg, ypos).x) * str * 80.0 / depth;\n  return mix(mix(color, color * 0.3, clamp(-cur * 15.0, 0.0, 1.0)), color * 2.0, clamp(cur * 25.0, 0.0, 1.0));\n}\n';});

define('render/shaders/ShaderBase',['require','exports','module','lib/glMatrix','misc/getOptionsURL','misc/Utils','render/Attribute','text!render/shaders/glsl/colorSpace.glsl','text!render/shaders/glsl/curvature.glsl'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var getOptionsURL = require('misc/getOptionsURL');
  var Utils = require('misc/Utils');
  var Attribute = require('render/Attribute');
  var colorSpaceGLSL = require('text!render/shaders/glsl/colorSpace.glsl');
  var curvatureGLSL = require('text!render/shaders/glsl/curvature.glsl');

  var vec3 = glm.vec3;

  var ShaderBase = {};
  ShaderBase.vertexName = 'VertexName';
  ShaderBase.fragmentName = 'FragmentName';

  ShaderBase.activeAttributes = {
    vertex: true,
    normal: true,
    material: true,
    color: true
  };

  ShaderBase.showSymmetryLine = getOptionsURL().mirrorline;
  ShaderBase.darkenUnselected = getOptionsURL().darkenunselected;
  ShaderBase.uniformNames = {};
  ShaderBase.uniformNames.commonUniforms = ['uMV', 'uMVP', 'uN', 'uEM', 'uEN', 'uFlat', 'uPlaneO', 'uPlaneN', 'uSym', 'uCurvature', 'uAlpha', 'uFov', 'uDarken'];

  ShaderBase.strings = {};
  ShaderBase.strings.colorSpaceGLSL = colorSpaceGLSL;
  ShaderBase.strings.vertUniforms = [
    'uniform mat4 uMV;',
    'uniform mat4 uMVP;',
    'uniform mat3 uN;',
    'uniform mat4 uEM;',
    'uniform mat3 uEN;',
    'uniform float uAlpha;'
  ].join('\n');
  ShaderBase.strings.fragColorUniforms = [
    'uniform vec3 uPlaneN;',
    'uniform vec3 uPlaneO;',
    'uniform int uSym;',
    'uniform int uDarken;',
    'uniform float uCurvature;',
    'uniform float uFov;',
    'varying float vMasking;',
    'uniform int uFlat;'
  ].join('\n');
  ShaderBase.strings.fragColorFunction = [
    curvatureGLSL,
    colorSpaceGLSL,
    '#extension GL_OES_standard_derivatives : enable',
    'vec3 getNormal() {',
    '  #ifndef GL_OES_standard_derivatives',
    '    return normalize(gl_FrontFacing ? vNormal : -vNormal);',
    '  #else',
    '    return uFlat == 0 ? normalize(gl_FrontFacing ? vNormal : -vNormal) : -normalize(cross(dFdy(vVertex), dFdx(vVertex)));',
    '  #endif',
    '}',
    'vec4 encodeFragColor(const in vec3 frag, const in float alpha) {',
    '  vec3 col = computeCurvature(vVertex, vNormal, frag, uCurvature, uFov);',
    '  if(uDarken == 1) col *= 0.3;',
    '  col *= (0.3 + 0.7 * vMasking);',
    '  if(uSym == 1 && abs(dot(uPlaneN, vVertex - uPlaneO)) < 0.15)',
    '      col = min(col * 1.5, 1.0);',
    '  return alpha != 1.0 ? vec4(col * alpha, alpha) : encodeRGBM(col);',
    '}'
  ].join('\n');

  var moveExtension = function (str) {
    // move extension enable/require to the top of file
    var matches = str.match(/^\s*(#extension).*/gm);
    if (!matches) return str;
    var extMap = {};
    var exts = '';

    for (var i = 0, nb = matches.length; i < nb; ++i) {
      var ext = matches[i].substr(matches[i].indexOf('#extension'));
      str = str.replace(matches[i], '');
      if (extMap[ext])
        continue;
      extMap[ext] = true;
      exts += ext + '\n';
    }
    str = exts + str;
    return str;
  };

  ShaderBase.getOrCreate = function (gl) {
    if (this.program)
      return this;

    var vname = '\n#define SHADER_NAME ' + this.vertexName + '\n';
    var fname = '\n#define SHADER_NAME ' + this.fragmentName + '\n';

    var vShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vShader, moveExtension(this.vertex + vname));
    gl.compileShader(vShader);

    var fShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fShader, moveExtension(this.fragment + fname));
    gl.compileShader(fShader);

    var program = this.program = gl.createProgram();

    gl.attachShader(program, vShader);
    gl.attachShader(program, fShader);
    gl.linkProgram(program);
    gl.useProgram(program);

    var logV = gl.getShaderInfoLog(vShader);
    var logF = gl.getShaderInfoLog(fShader);
    var logP = gl.getProgramInfoLog(program);
    if (logV) console.warn(this.vertexName + ' (vertex)\n' + logV);
    if (logF) console.warn(this.fragmentName + ' (fragment)\n' + logF);
    if (logP) console.warn(this.fragmentName + ' (program)\n' + logP);

    this.initAttributes(gl);
    this.initUniforms(gl);

    // no clean up for quick webgl inspector debugging
    // gl.detachShader(program, fShader);
    // gl.deleteShader(fShader);
    // gl.detachShader(program, vShader);
    // gl.deleteShader(vShader);
    return this;
  };
  ShaderBase.initUniforms = function (gl) {
    var program = this.program;
    var unifNames = this.uniformNames;
    var unifs = this.uniforms;
    for (var i = 0, l = unifNames.length; i < l; ++i) {
      var name = unifNames[i];
      unifs[name] = gl.getUniformLocation(program, name);
    }
  };
  ShaderBase.updateUniforms = (function () {
    var tmp = [0.0, 0.0, 0.0];
    return function (render, main) {
      var gl = render.getGL();
      var mesh = render.getMesh();

      var sels = main.getSelectedMeshes();
      var darken = ShaderBase.darkenUnselected && sels.length !== 0 && sels.indexOf(mesh) === -1;
      var useSym = ShaderBase.showSymmetryLine && (mesh === main.getMesh()) && main.getSculpt().getSymmetry();

      var uniforms = this.uniforms;

      gl.uniformMatrix4fv(uniforms.uEM, false, mesh.getEditMatrix());
      gl.uniformMatrix3fv(uniforms.uEN, false, mesh.getEN());
      gl.uniformMatrix4fv(uniforms.uMV, false, mesh.getMV());
      gl.uniformMatrix4fv(uniforms.uMVP, false, mesh.getMVP());
      gl.uniformMatrix3fv(uniforms.uN, false, mesh.getN());

      gl.uniform1i(uniforms.uDarken, darken ? 1 : 0);
      gl.uniform1i(uniforms.uFlat, mesh.getFlatShading());
      gl.uniform3fv(uniforms.uPlaneO, vec3.transformMat4(tmp, mesh.getSymmetryOrigin(), mesh.getMV()));
      gl.uniform3fv(uniforms.uPlaneN, vec3.normalize(tmp, vec3.transformMat3(tmp, mesh.getSymmetryNormal(), mesh.getN())));
      gl.uniform1i(uniforms.uSym, useSym ? 1 : 0);
      gl.uniform1f(uniforms.uAlpha, mesh.getOpacity());

      gl.uniform1f(uniforms.uCurvature, mesh.getCurvature());
      var cam = main.getCamera();
      gl.uniform1f(uniforms.uFov, cam.isOrthographic() ? -Math.abs(cam._trans[2]) * 25.0 : cam.getFov());
    };
  })();
  ShaderBase.draw = function (render, main) {
    var gl = render.getGL();
    gl.useProgram(this.program);
    this.bindAttributes(render);
    this.updateUniforms(render, main);
    this.drawBuffer(render);
  };
  ShaderBase.drawBuffer = function (render) {
    var gl = render.getGL();
    if (render.isUsingDrawArrays()) {
      gl.drawArrays(render.getMode(), 0, render.getCount());
    } else {
      render.getIndexBuffer().bind();
      gl.drawElements(render.getMode(), render.getCount(), gl.UNSIGNED_INT, 0);
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  };
  ShaderBase.setTextureParameters = function (gl, tex) {
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    if (Utils.isPowerOfTwo(tex.width) && Utils.isPowerOfTwo(tex.height)) {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
      gl.generateMipmap(gl.TEXTURE_2D);
    } else {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
  };
  ShaderBase.onLoadTexture0 = function (gl, tex, main) {
    this.texture0 = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.texture0);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tex);
    ShaderBase.setTextureParameters(gl, tex);
    gl.bindTexture(gl.TEXTURE_2D, null);
    if (main)
      main.render();
  };
  ShaderBase.getOrCreateTexture0 = function (gl, texPath, main) {
    if (this.texture0 !== undefined)
      return this.texture0;
    this.texture0 = null; // trigger loading
    var tex = new Image();
    tex.src = texPath;
    tex.onload = this.onLoadTexture0.bind(this, gl, tex, main);
    return false;
  };
  ShaderBase.initAttributes = function (gl) {
    var program = this.program;
    var attrs = this.attributes;
    attrs.aVertex = new Attribute(gl, program, 'aVertex', 3, gl.FLOAT);
    attrs.aNormal = new Attribute(gl, program, 'aNormal', 3, gl.FLOAT);
    attrs.aColor = new Attribute(gl, program, 'aColor', 3, gl.FLOAT);
    attrs.aMaterial = new Attribute(gl, program, 'aMaterial', 3, gl.FLOAT);
  };
  ShaderBase.bindAttributes = function (render) {
    var attrs = this.attributes;
    var active = this.activeAttributes;
    if (active.vertex) attrs.aVertex.bindToBuffer(render.getVertexBuffer());
    if (active.normal) attrs.aNormal.bindToBuffer(render.getNormalBuffer());
    if (active.color) attrs.aColor.bindToBuffer(render.getColorBuffer());
    if (active.material) attrs.aMaterial.bindToBuffer(render.getMaterialBuffer());
  };

  ShaderBase.getCopy = function () {
    var keys = Object.keys(ShaderBase);
    var obj = {};
    for (var i = 0, nb = keys.length; i < nb; ++i)
      obj[keys[i]] = this[keys[i]];
    obj.program = null;
    return obj;
  };

  module.exports = ShaderBase;
});
define('render/shaders/ShaderBackground',['require','exports','module','render/shaders/ShaderBase','render/Attribute'],function (require, exports, module) {

  'use strict';

  var ShaderBase = require('render/shaders/ShaderBase');
  var Attribute = require('render/Attribute');

  var ShaderBackground = ShaderBase.getCopy();
  ShaderBackground.vertexName = ShaderBackground.fragmentName = 'Background';

  ShaderBackground.uniforms = {};
  ShaderBackground.attributes = {};

  ShaderBackground.uniformNames = ['uTexture0'];

  ShaderBackground.vertex = [
    'attribute vec2 aVertex;',
    'attribute vec2 aTexCoord;',
    'varying vec2 vTexCoord;',
    'void main() {',
    '  vTexCoord = aTexCoord;',
    '  gl_Position = vec4(aVertex, 1.0, 1.0);',
    '}'
  ].join('\n');

  ShaderBackground.fragment = [
    'precision mediump float;',
    'uniform sampler2D uTexture0;',
    'varying vec2 vTexCoord;',
    ShaderBase.strings.colorSpaceGLSL,
    'void main() {',
    '  gl_FragColor = encodeRGBM(sRGBToLinear(texture2D(uTexture0, vTexCoord)).rgb);',
    '}'
  ].join('\n');

  ShaderBackground.draw = function (bg) {
    var gl = bg.getGL();
    gl.useProgram(this.program);
    this.bindAttributes(bg);
    this.updateUniforms(bg);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  };
  ShaderBackground.initAttributes = function (gl) {
    var program = ShaderBackground.program;
    var attrs = ShaderBackground.attributes;
    attrs.aVertex = new Attribute(gl, program, 'aVertex', 2, gl.FLOAT);
    attrs.aTexCoord = new Attribute(gl, program, 'aTexCoord', 2, gl.FLOAT);
  };
  ShaderBackground.bindAttributes = function (bg) {
    var attrs = ShaderBackground.attributes;
    attrs.aVertex.bindToBuffer(bg.getVertexBuffer());
    attrs.aTexCoord.bindToBuffer(bg.getTexCoordBuffer());
  };
  ShaderBackground.updateUniforms = function (bg) {
    var gl = bg.getGL();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, bg.getTexture());
    gl.uniform1i(this.uniforms.uTexture0, 0);
  };

  module.exports = ShaderBackground;
});
define('render/shaders/ShaderContour',['require','exports','module','misc/getOptionsURL','render/shaders/ShaderBase','render/Attribute'],function (require, exports, module) {

  'use strict';

  var getOptionsURL = require('misc/getOptionsURL');
  var ShaderBase = require('render/shaders/ShaderBase');
  var Attribute = require('render/Attribute');

  var ShaderContour = ShaderBase.getCopy();
  ShaderContour.vertexName = ShaderContour.fragmentName = 'SobelContour';

  ShaderContour.color = getOptionsURL().outlinecolor;
  ShaderContour.uniforms = {};
  ShaderContour.attributes = {};

  ShaderContour.uniformNames = ['uTexture0', 'uColor'];

  ShaderContour.vertex = [
    'attribute vec2 aVertex;',
    'varying vec2 vTexCoord;',
    'void main() {',
    '  vTexCoord = aVertex * 0.5 + 0.5;',
    '  gl_Position = vec4(aVertex, 0.0, 1.0);',
    '}'
  ].join('\n');

  ShaderContour.fragment = [
    '#extension GL_OES_standard_derivatives : enable',
    'precision mediump float;',
    'uniform sampler2D uTexture0;',
    'uniform vec4 uColor;',
    'varying vec2 vTexCoord;',
    'void main() {',
    '  float fac0 = 2.0;',
    '  float fac1 = 1.0;',
    '  float ox = dFdx(vTexCoord).x;',
    '  float oy = dFdy(vTexCoord).y;',
    '  vec4 texel0 = texture2D(uTexture0, vTexCoord + vec2(ox, oy));',
    '  vec4 texel1 = texture2D(uTexture0, vTexCoord + vec2(ox, 0.0));',
    '  vec4 texel2 = texture2D(uTexture0, vTexCoord + vec2(ox, -oy));',
    '  vec4 texel3 = texture2D(uTexture0, vTexCoord + vec2(0.0, -oy));',
    '  vec4 texel4 = texture2D(uTexture0, vTexCoord + vec2(-ox, -oy));',
    '  vec4 texel5 = texture2D(uTexture0, vTexCoord + vec2(-ox, 0.0));',
    '  vec4 texel6 = texture2D(uTexture0, vTexCoord + vec2(-ox, oy));',
    '  vec4 texel7 = texture2D(uTexture0, vTexCoord + vec2(0.0, oy));',
    '  vec4 rowx = -fac0*texel5 + fac0*texel1 + -fac1*texel6 + fac1*texel0 + -fac1*texel4 + fac1*texel2;',
    '  vec4 rowy = -fac0*texel3 + fac0*texel7 + -fac1*texel4 + fac1*texel6 + -fac1*texel2 + fac1*texel0;',
    '  float mag = dot(rowy, rowy) + dot(rowx, rowx);',
    '  if (mag < 1.5) discard;',
    '  gl_FragColor = vec4(uColor.rgb * uColor.a, uColor.a);',
    '}'
  ].join('\n');

  ShaderContour.draw = function (rtt) {
    var gl = rtt.getGL();
    gl.useProgram(this.program);

    ShaderContour.attributes.aVertex.bindToBuffer(rtt.getVertexBuffer());

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, rtt.getTexture());
    gl.uniform1i(this.uniforms.uTexture0, 0);
    gl.uniform4fv(this.uniforms.uColor, ShaderContour.color);

    gl.drawArrays(gl.TRIANGLES, 0, 3);
  };
  ShaderContour.initAttributes = function (gl) {
    ShaderContour.attributes.aVertex = new Attribute(gl, ShaderContour.program, 'aVertex', 2, gl.FLOAT);
  };

  module.exports = ShaderContour;
});
define('render/shaders/ShaderSelection',['require','exports','module','render/shaders/ShaderBase'],function (require, exports, module) {

  'use strict';

  var ShaderBase = require('render/shaders/ShaderBase');

  var ShaderSelection = ShaderBase.getCopy();
  ShaderSelection.vertexName = ShaderSelection.fragmentName = 'ShowSelection';

  ShaderSelection.uniforms = {};
  ShaderSelection.attributes = {};
  ShaderSelection.activeAttributes = {
    vertex: true
  };

  ShaderSelection.uniformNames = ['uMVP', 'uColor'];

  ShaderSelection.vertex = [
    'attribute vec3 aVertex;',
    'uniform mat4 uMVP;',
    'void main() {',
    '  gl_Position = uMVP * vec4(aVertex, 1.0);',
    '}'
  ].join('\n');

  ShaderSelection.fragment = [
    'precision mediump float;',
    'uniform vec3 uColor;',
    'void main() {',
    '  gl_FragColor = vec4(uColor, 1.0);',
    '}'
  ].join('\n');

  ShaderSelection.draw = function (geom, drawCircle, drawSym) {
    var gl = geom.getGL();
    gl.useProgram(this.program);

    gl.uniform3fv(this.uniforms.uColor, geom.getColor());

    if (drawCircle) {
      gl.uniformMatrix4fv(this.uniforms.uMVP, false, geom.getCircleMVP());
      ShaderSelection.attributes.aVertex.bindToBuffer(geom.getCircleBuffer());
      gl.drawArrays(gl.LINE_LOOP, 0, geom.getCircleBuffer()._size / 3);
    }

    gl.uniformMatrix4fv(this.uniforms.uMVP, false, geom.getDotMVP());
    ShaderSelection.attributes.aVertex.bindToBuffer(geom.getDotBuffer());
    gl.drawArrays(gl.TRIANGLE_FAN, 0, geom.getDotBuffer()._size / 3);

    if (drawSym) {
      gl.uniformMatrix4fv(this.uniforms.uMVP, false, geom.getDotSymmetryMVP());
      gl.drawArrays(gl.TRIANGLE_FAN, 0, geom.getDotBuffer()._size / 3);
    }
  };

  module.exports = ShaderSelection;
});
define('render/shaders/ShaderFlat',['require','exports','module','render/shaders/ShaderBase'],function (require, exports, module) {

  'use strict';

  var ShaderBase = require('render/shaders/ShaderBase');

  var ShaderFlat = ShaderBase.getCopy();
  ShaderFlat.vertexName = ShaderFlat.fragmentName = 'FlatColor';

  ShaderFlat.uniforms = {};
  ShaderFlat.attributes = {};
  ShaderFlat.activeAttributes = {
    vertex: true,
    material: true
  };

  ShaderFlat.uniformNames = ['uColor'];
  Array.prototype.push.apply(ShaderFlat.uniformNames, ShaderBase.uniformNames.commonUniforms);

  ShaderFlat.vertex = [
    'precision mediump float;',
    'attribute vec3 aVertex;',
    'attribute vec3 aMaterial;',
    ShaderBase.strings.vertUniforms,
    'varying vec3 vVertex;',
    'void main() {',
    '  vec4 vertex4 = vec4(aVertex, 1.0);',
    '  gl_Position = uMVP * mix(vertex4, uEM * vertex4, aMaterial.z);',
    '}'
  ].join('\n');

  ShaderFlat.fragment = [
    'precision mediump float;',
    'uniform vec3 uColor;',
    'void main() {',
    '  gl_FragColor = vec4(uColor, 1.0);',
    '}'
  ].join('\n');

  ShaderFlat.updateUniforms = function (render, main) {
    render.getGL().uniform3fv(this.uniforms.uColor, render.getFlatColor());
    ShaderBase.updateUniforms.call(this, render, main);
  };

  module.exports = ShaderFlat;
});

define('text!render/shaders/glsl/fxaa.glsl',[],function () { return '// https://github.com/mattdesl/glsl-fxaa\n#define FXAA_REDUCE_MIN (1.0/ 128.0)\n#define FXAA_REDUCE_MUL (1.0 / 8.0)\n#define FXAA_SPAN_MAX 8.0\n\nvec3 fxaa(const in sampler2D tex, const in vec2 uvNW, const in vec2 uvNE, const in vec2 uvSW, const in vec2 uvSE, const in vec2 uvM, const in vec2 invRes) {\n    const vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(texture2D(tex, uvNW).xyz, luma);\n    float lumaNE = dot(texture2D(tex, uvNE).xyz, luma);\n    float lumaSW = dot(texture2D(tex, uvSW).xyz, luma);\n    float lumaSE = dot(texture2D(tex, uvSE).xyz, luma);\n    float lumaM  = dot(texture2D(tex, uvM).xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * invRes;\n    \n    vec3 rgbA = 0.5 * ( texture2D(tex, uvM + dir * (1.0 / 3.0 - 0.5)).xyz + texture2D(tex, uvM + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * ( texture2D(tex, uvM - dir * 0.5).xyz + texture2D(tex, uvM + dir * 0.5).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n    if((lumaB < lumaMin) || (lumaB > lumaMax))\n      return rgbA;\n    return rgbB;\n}';});

define('render/shaders/ShaderFxaa',['require','exports','module','render/shaders/ShaderBase','render/Attribute','misc/getOptionsURL','text!render/shaders/glsl/fxaa.glsl'],function (require, exports, module) {

  'use strict';

  var ShaderBase = require('render/shaders/ShaderBase');
  var Attribute = require('render/Attribute');
  var getOptionsURL = require('misc/getOptionsURL');
  var fxaaGLSL = require('text!render/shaders/glsl/fxaa.glsl');

  var ShaderFxaa = ShaderBase.getCopy();
  ShaderFxaa.vertexName = ShaderFxaa.fragmentName = 'Fxaa';

  ShaderFxaa.FILMIC = getOptionsURL().filmic; // edited by the gui

  ShaderFxaa.uniforms = {};
  ShaderFxaa.attributes = {};

  ShaderFxaa.uniformNames = ['uTexture0', 'uInvSize'];

  ShaderFxaa.vertex = [
    'precision mediump float;',
    'attribute vec2 aVertex;',
    'uniform vec2 uInvSize;',
    'varying vec2 vUVNW;',
    'varying vec2 vUVNE;',
    'varying vec2 vUVSW;',
    'varying vec2 vUVSE;',
    'varying vec2 vUVM;',
    'void main() {',
    '  vUVM = aVertex * 0.5 + 0.5;',
    '  vUVNW = vUVM + vec2(-1.0, -1.0) * uInvSize;',
    '  vUVNE = vUVM + vec2(1.0, -1.0) * uInvSize;',
    '  vUVSW = vUVM + vec2(-1.0, 1.0) * uInvSize;',
    '  vUVSE = vUVM + vec2(1.0, 1.0) * uInvSize;',
    '  gl_Position = vec4(aVertex, 0.5, 1.0);',
    '}'
  ].join('\n');

  ShaderFxaa.fragment = [
    'precision mediump float;',
    'uniform sampler2D uTexture0;',
    'uniform vec2 uInvSize;',
    'varying vec2 vUVNW;',
    'varying vec2 vUVNE;',
    'varying vec2 vUVSW;',
    'varying vec2 vUVSE;',
    'varying vec2 vUVM;',
    fxaaGLSL,
    ShaderBase.strings.colorSpaceGLSL,
    'void main() {',
    '  gl_FragColor = vec4(fxaa(uTexture0, vUVNW, vUVNE, vUVSW, vUVSE, vUVM, uInvSize), 1.0);',
    '}'
  ].join('\n');

  ShaderFxaa.draw = function (rtt, main) {
    var gl = rtt.getGL();
    gl.useProgram(this.program);

    ShaderFxaa.attributes.aVertex.bindToBuffer(rtt.getVertexBuffer());

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, main._rttMerge.getTexture());
    gl.uniform1i(this.uniforms.uTexture0, 0);

    gl.uniform2fv(this.uniforms.uInvSize, rtt.getInverseSize());

    gl.drawArrays(gl.TRIANGLES, 0, 3);
  };
  ShaderFxaa.initAttributes = function (gl) {
    ShaderFxaa.attributes.aVertex = new Attribute(gl, ShaderFxaa.program, 'aVertex', 2, gl.FLOAT);
  };

  module.exports = ShaderFxaa;
});
define('gui/tr/english',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var TR = {
    // background
    backgroundTitle: 'Background',
    backgroundReset: 'Reset',
    backgroundImport: 'Import (jpg, png...)',
    backgroundFill: 'Fill',

    // camera
    cameraTitle: 'Camera',
    cameraReset: 'View',
    cameraCenter: 'Reset (bar)',
    cameraFront: 'Front (F)',
    cameraLeft: 'Left (L)',
    cameraTop: 'Top (T)',
    cameraMode: 'Mode',
    cameraOrbit: 'Orbit (Turntable)',
    cameraSpherical: 'Spherical (Trackball)',
    cameraPlane: 'Plane (Trackball)',
    cameraProjection: 'Projection',
    cameraPerspective: 'Perspective',
    cameraOrthographic: 'Orthographic',
    cameraFov: 'Fov',
    cameraPivot: 'Picking pivot',

    // file
    fileTitle: 'Files (import/export)',
    fileImportTitle: 'Import',
    fileAdd: 'Add (obj, sgl, ply, stl)',
    fileAutoMatrix: 'Scale and center',
    fileVertexSRGB: 'sRGB vertex color',
    fileExportMeshTitle: 'Export Mesh',
    fileExportSceneTitle: 'Export Scene',
    fileExportSGL: 'Save .sgl (SculptGL)',
    fileExportOBJ: 'Save .obj',
    fileExportPLY: 'Save .ply',
    fileExportSTL: 'Save .stl',

    // scene
    sceneTitle: 'Scene',
    sceneReset: 'Clear scene',
    sceneAddSphere: 'Add sphere',
    sceneAddCube: 'Add cube',
    sceneAddCylinder: 'Add cylinder',
    sceneAddTorus: 'Add torus',
    sceneSelection: 'Selection',
    sceneMerge: 'Merge selection',

    // mesh
    meshTitle: 'Mesh',
    meshNbVertices: 'Vertex : ',
    meshNbFaces: 'Faces : ',

    // topology
    topologyTitle: 'Topology',

    //multires
    multiresTitle: 'Multiresolution',
    multiresSubdivide: 'Subdivide',
    multiresReverse: 'Reverse',
    multiresResolution: 'Resolution',
    multiresNoLower: 'There is no lower resolution level.',
    multiresNoHigher: 'There is no higher resolution level.',
    multiresDelHigher: 'Delete higher',
    multiresDelLower: 'Delete lower',
    multiresSelectLowest: 'Select the lowest resolution before reversing.',
    multiresSelectHighest: 'Select the highest resolution before subdividing.',
    multiresWarnBigMesh: function (nbFacesNext) {
      return 'The next subdivision level will reach ' + nbFacesNext + ' faces.\n' +
        'If you know what you are doing, click again on "subdivide".';
    },
    multiresNotReversible: 'Sorry it is not possile to reverse this mesh.\n' +
      'The mesh is not a product of a (loop-catmull) subdivision surface on a manifold mesh.',

    // remesh
    remeshTitle: 'Voxel Remeshing',
    remeshRemesh: 'Remesh',
    remeshResolution: 'Resolution',
    remeshBlock: 'Block',

    // dynamic
    dynamicTitle: 'Dynamic Topology',
    dynamicActivated: 'Activated (no quads)',
    dynamicSubdivision: 'Subdivision',
    dynamicDecimation: 'Decimation',
    dynamicLinear: 'Linear subdivision',

    // sculpt
    sculptTitle: 'Sculpting & Painting',
    sculptBrush: 'Brush',
    sculptInflate: 'Inflate',
    sculptTwist: 'Twist',
    sculptSmooth: 'Smooth (-Shift)',
    sculptFlatten: 'Flatten',
    sculptPinch: 'Pinch',
    sculptCrease: 'Crease',
    sculptDrag: 'Drag',
    sculptPaint: 'Paint',
    sculptMasking: 'Masking (-Ctrl)',
    sculptMove: 'Move',
    sculptLocalScale: 'Local scale',
    sculptTransform: 'Transform (E)',

    sculptCommon: 'Common',
    sculptTool: 'Tool',
    sculptSymmetry: 'Symmetry',
    sculptContinuous: 'Continuous',
    sculptRadius: 'Radius (-X)',
    sculptIntensity: 'Intensity (-C)',
    sculptHardness: 'Hardness',
    sculptCulling: 'Thin surface (front vertex only)',
    sculptAlphaTitle: 'Alpha',
    sculptLockPositon: 'Lock position',
    sculptAlphaTex: 'Texture',
    sculptImportAlpha: 'Import alpha tex (jpg, png...)',
    sculptNegative: 'Negative (N or -Alt)',
    sculptColor: 'Albedo',
    sculptRoughness: 'Roughness',
    sculptMetallic: 'Metallic',
    sculptClay: 'Clay',
    sculptAccumulate: 'Accumulate (no limit per stroke)',
    sculptColorGlobal: 'Global',
    sculptPickColor: 'Material / Color picker (-S)',
    sculptTangentialSmoothing: 'Relax only',
    sculptTopologicalCheck: 'Topological check',
    sculptMoveAlongNormal: 'Move along normal (N or -Alt)',
    sculptMaskingClear: 'Clear (-Ctrl + Drag)',
    sculptMaskingInvert: 'Invert (-Ctrl + Click)',
    sculptMaskingBlur: 'Blur',
    sculptMaskingSharpen: 'Sharpen',
    sculptPBRTitle: 'PBR materials',
    sculptPaintAll: 'Paint all',
    sculptExtractTitle: 'Extract',
    sculptExtractThickness: 'Thickness',
    sculptExtractAction: 'Extract !',

    // states
    stateTitle: 'History',
    stateUndo: 'Undo',
    stateRedo: 'Redo',
    stateMaxStack: 'Max Stack',

    // wacom
    wacomTitle: 'Wacom tablet',
    wacomRadius: 'Pressure radius',
    wacomIntensity: 'Pressure intensity',

    // rendering
    renderingTitle: 'Rendering',
    renderingGrid: 'Show grid',
    renderingSymmetryLine: 'Show mirror line',
    renderingMatcap: 'Matcap',
    renderingCurvature: 'Curvature',
    renderingPBR: 'PBR',
    renderingTransparency: 'Transparency',
    renderingNormal: 'Normal shader',
    renderingUV: 'UV shader',
    renderingShader: 'Shader',
    renderingMaterial: 'Material',
    renderingImportUV: 'Import (jpg, png...)',
    renderingImportMatcap: 'Import (jpg, png...)',
    renderingExtra: 'Extra',
    renderingFlat: 'Flat shading',
    renderingWireframe: 'Wireframe (W)',
    renderingExposure: 'Exposure',
    renderingEnvironment: 'Environment',
    renderingIsolate: 'Isolate/Show (I)',
    renderingFilmic: 'Filmic tonemapping',

    // contour
    contour: 'Contour',
    contourShow: 'Show contour',
    contourColor: 'Color',
    darkenUnselected: 'Darken unselected',

    // pixel ratio
    resolution: 'Resolution',

    // matcaps
    matcapPearl: 'Pearl',
    matcapClay: 'Clay',
    matcapSkin: 'Skin',
    matcapGreen: 'Green',
    matcapWhite: 'White',

    // sketchfab
    sketchfabTitle: 'Go to Sketchfab !',
    sketchfabUpload: 'Upload',
    sketchfabUploadMessage: 'Please enter your sketchfab API Key.\n' +
      'You can also leave "guest" to upload anonymously.\n' +
      '(a new window will pop up when the uploading and processing is finished)',
    sketchfabUploadError: function (error) {
      return 'Sketchfab upload error :\n' + error;
    },
    sketchfabUploadSuccess: 'Upload success !\nHere is your link :',
    sketchfabAbort: 'Abort the last upload ?',
    sketchfabUploadProcessing: 'Processing...\nYour model will be available at :',

    about: 'About & Help',

    alphaNone: 'None',
    alphaSquare: 'Square',
    alphaSkin: 'Skin',

    envFootPrint: 'Foot Print',
    envGlazedPatio: 'Glazed Patio',
    envNicolausChurch: 'St Nicolaus church',
    envTerrace: 'Terrace',
    envBryantPark: 'BryantPark'
  };

  module.exports = TR;
});
define('gui/tr/chinese',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var TR = {
    // background
    backgroundTitle: '背景',
    backgroundReset: '重設',
    backgroundImport: '匯入 (jpg, png...)',
    backgroundFill: '填色',

    // camera
    cameraTitle: '鏡頭',
    cameraReset: '檢視',
    cameraCenter: '重設 (空白鍵)',
    cameraFront: '前視角 (F)',
    cameraLeft: '左視角 (L)',
    cameraTop: '俯視角 (T)',
    cameraMode: '模式',
    cameraOrbit: '軌道 (轉盤)',
    cameraSpherical: '球面 (軌跡球)',
    cameraPlane: '平面 (軌跡球)',
    cameraProjection: '投影',
    cameraPerspective: '透視角',
    cameraOrthographic: '等視角',
    cameraFov: '視野範圍',
    cameraPivot: '選擇軸心',

    // file
    fileTitle: '檔案 (匯入/匯出)',
    fileImportTitle: '匯入',
    fileAdd: '加入 (obj, sgl, ply, stl)',
    fileAutoMatrix: null,
    fileVertexSRGB: null,
    fileExportMeshTitle: '匯出網面',
    fileExportSceneTitle: '匯出場景',
    fileExportSGL: '儲存 .sgl (SculptGL)',
    fileExportOBJ: '儲存 .obj',
    fileExportPLY: '儲存 .ply',
    fileExportSTL: '儲存 .stl',

    // scene
    sceneTitle: '場景',
    sceneReset: '清除場景',
    sceneAddSphere: '加入球體',
    sceneAddCube: null,
    sceneAddCylinder: null,
    sceneAddTorus: null,
    sceneSelection: null,
    sceneMerge: null,

    // mesh
    meshTitle: '網面',
    meshNbVertices: '頂點 : ',
    meshNbFaces: '面 : ',

    // topology
    topologyTitle: '網面結構',

    //multires
    multiresTitle: '多重解析度',
    multiresSubdivide: '細分',
    multiresReverse: '反轉',
    multiresResolution: '解析度',
    multiresNoLower: '沒有更低等級的解析度。',
    multiresNoHigher: '沒有更高等級的解析度。',
    multiresDelHigher: '刪除較高等級',
    multiresDelLower: '刪除較低等級',
    multiresSelectLowest: '反轉前請先選擇最低的解析度。',
    multiresSelectHighest: '細分前請先選擇最高的解析度。',
    multiresWarnBigMesh: function (nbFacesNext) {
      return '下一個細分等級會達到 ' + nbFacesNext + ' 個面。\n' +
        '若你清楚你自己正在做什麼，再點擊「細分」一次。';
    },
    multiresNotReversible: '抱歉，無法反轉此網面。\n' +
      '此網面不是由流形網面經過細分曲面 (loop-catmull) 而來。',

    // remesh
    remeshTitle: '立體像素網面重構',
    remeshRemesh: '網面重構',
    remeshResolution: '解析度',
    remeshBlock: null,

    // dynamic
    dynamicTitle: '動態網面結構',
    dynamicActivated: '已啟用 (無四邊形)',
    dynamicSubdivision: '細分',
    dynamicDecimation: '削減面數',
    dynamicLinear: '線性細分',

    // sculpt
    sculptTitle: '雕刻和塗繪',
    sculptBrush: '筆刷',
    sculptInflate: '膨脹',
    sculptTwist: '扭轉',
    sculptSmooth: '平滑 (-Shift)',
    sculptFlatten: '抹平',
    sculptPinch: '夾捏',
    sculptCrease: '皺褶',
    sculptDrag: '拖拉',
    sculptPaint: '塗繪',
    sculptMasking: null,
    sculptMove: null,
    sculptLocalScale: null,
    sculptTransform: '縮放 移動 旋轉 (E)',

    sculptCommon: null,
    sculptTool: '工具',
    sculptSymmetry: '對稱',
    sculptContinuous: '連續',
    sculptRadius: '半徑 (-X)',
    sculptIntensity: '強度 (-C)',
    sculptHardness: null,
    sculptCulling: '薄曲面 (僅前面頂點)',
    sculptAlphaTitle: null,
    sculptLockPositon: null,
    sculptAlphaTex: null,
    sculptImportAlpha: null,
    sculptNegative: '反向 (N or -Alt)',
    sculptColor: '反照率',
    sculptRoughness: '粗糙度',
    sculptMetallic: '金屬',
    sculptClay: '黏土',
    sculptAccumulate: '累積 (每道筆劃無限制)',
    sculptColorGlobal: '全域',
    sculptPickColor: '選擇材質 (-S)',
    sculptTangentialSmoothing: '僅放鬆',
    sculptTopologicalCheck: null,
    sculptMoveAlongNormal: null,
    sculptMaskingClear: null,
    sculptMaskingInvert: null,
    sculptMaskingBlur: null,
    sculptMaskingSharpen: null,
    sculptPBRTitle: null,
    sculptPaintAll: null,
    sculptExtractTitle: null,
    sculptExtractThickness: null,
    sculptExtractAction: null,

    // states
    stateTitle: '記錄',
    stateUndo: '復原',
    stateRedo: '取消復原',
    stateMaxStack: '最大堆疊',

    // wacom
    wacomTitle: 'Wacom 繪圖板',
    wacomRadius: '感壓半徑',
    wacomIntensity: '感壓強度',

    // rendering
    renderingTitle: '繪算',
    renderingGrid: '顯示格線',
    renderingSymmetryLine: null,
    renderingMatcap: null,
    renderingCurvature: null,
    renderingPBR: '物理式繪算(PBR)',
    renderingTransparency: '透明',
    renderingNormal: '法線著色器',
    renderingUV: 'UV 著色器',
    renderingShader: '著色器',
    renderingMaterial: '材質',
    renderingImportUV: '匯入 (jpg, png...)',
    renderingImportMatcap: '匯入 (jpg, png...)',
    renderingExtra: '額外項目',
    renderingFlat: '平整面 (較慢)',
    renderingWireframe: '線框 (較慢) (W)',
    renderingExposure: null,
    renderingEnvironment: null,
    renderingIsolate: null,
    renderingFilmic: null,

    // contour
    contour: null,
    contourShow: null,
    contourColor: null,
    darkenUnselected: null,

    // pixel ratio
    resolution: null,

    // matcaps
    matcapPearl: '珍珠',
    matcapClay: '黏土',
    matcapSkin: '膚色',
    matcapGreen: '綠色',
    matcapWhite: '白色',

    // sketchfab
    sketchfabTitle: '前往 Sketchfab !',
    sketchfabUpload: '上傳',
    sketchfabUploadMessage: '請輸入你的 sketchfab API 密鑰。\n' +
      '你也可以留下 "guest" 進行匿名上傳。\n' +
      '(當上傳中和完成時會跳出新視窗)',
    sketchfabUploadError: function (error) {
      return 'Sketchfab 上傳錯誤 :\n' + error;
    },
    sketchfabUploadSuccess: '上傳成功 !\n這是你的連結 :',
    sketchfabAbort: '中止最近一次的上傳 ?',
    sketchfabUploadProcessing: null,

    about: null,

    alphaNone: null,
    alphaSquare: null,
    alphaSkin: null,

    envFootPrint: null,
    envGlazedPatio: null,
    envNicolausChurch: null,
    envTerrace: null,
    envBryantPark: null
  };

  module.exports = TR;
});
define('gui/tr/japanese',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var TR = {
    // background
    backgroundTitle: 'バックグラウンド',
    backgroundReset: 'リセット',
    backgroundImport: 'インポート  (jpg, png...)',
    backgroundFill: null,

    // camera
    cameraTitle: 'カメラ',
    cameraReset: 'View',
    cameraCenter: null,
    cameraFront: null,
    cameraLeft: null,
    cameraTop: null,
    cameraMode: 'モード',
    cameraOrbit: null,
    cameraSpherical: '球体 (Trackball)',
    cameraPlane: '平面 (Trackball)',
    cameraProjection: 'タイプ',
    cameraPerspective: '透視投影',
    cameraOrthographic: '平行投影',
    cameraFov: '視野',
    cameraPivot: 'ピボット選択',

    // file
    fileTitle: 'ファイル (インポート/エクスポート)',
    fileImportTitle: null,
    fileAdd: 'Add (obj, sgl, ply, stl)',
    fileAutoMatrix: null,
    fileVertexSRGB: null,
    fileExportMeshTitle: null,
    fileExportSceneTitle: null,
    fileExportSGL: null,
    fileExportOBJ: null,
    fileExportPLY: null,
    fileExportSTL: null,

    // scene
    sceneTitle: null,
    sceneReset: null,
    sceneAddSphere: null,
    sceneAddCube: null,
    sceneAddCylinder: null,
    sceneAddTorus: null,
    sceneSelection: null,
    sceneMerge: null,

    // mesh
    meshTitle: 'メッシュ',
    meshNbVertices: null,
    meshNbFaces: null,

    // topology
    topologyTitle: null,

    // multires
    multiresTitle: null,
    multiresSubdivide: null,
    multiresReverse: null,
    multiresResolution: null,
    multiresNoLower: null,
    multiresNoHigher: null,
    multiresDelHigher: null,
    multiresDelLower: null,
    multiresSelectLowest: null,
    multiresSelectHighest: null,
    multiresWarnBigMesh: null,
    // 
    // 
    //
    multiresNotReversible: null,
    // 

    // remesh
    remeshTitle: null,
    remeshRemesh: null,
    remeshResolution: null,
    remeshBlock: null,

    // dynamic
    dynamicTitle: null,
    dynamicActivated: null,
    dynamicSubdivision: null,
    dynamicDecimation: null,
    dynamicLinear: null,

    // sculpt
    sculptTitle: null,
    sculptBrush: 'ブラシ',
    sculptInflate: '膨張',
    sculptTwist: '回転',
    sculptSmooth: 'スムーズ化 (-Shift)',
    sculptFlatten: 'フラット化',
    sculptPinch: 'つまむ',
    sculptCrease: 'しわ',
    sculptDrag: 'ドラッグ',
    sculptPaint: 'ペイント',
    sculptMasking: null,
    sculptMove: null,
    sculptLocalScale: null,
    sculptTransform: null,

    sculptCommon: null,
    sculptTool: 'ツール',
    sculptSymmetry: '対称加工',
    sculptContinuous: '連続加工',
    sculptRadius: '半径 (-X)',
    sculptIntensity: '明るさ (-C)',
    sculptHardness: null,
    sculptCulling: null,
    sculptAlphaTitle: null,
    sculptLockPositon: null,
    sculptAlphaTex: null,
    sculptImportAlpha: null,
    sculptNegative: 'ネガティブ (N or -Alt)',
    sculptColor: null,
    sculptRoughness: null,
    sculptMetallic: null,
    sculptClay: 'クレイ',
    sculptAccumulate: null,
    sculptColorGlobal: null,
    sculptPickColor: null,
    sculptTangentialSmoothing: null,
    sculptTopologicalCheck: null,
    sculptMoveAlongNormal: null,
    sculptMaskingClear: null,
    sculptMaskingInvert: null,
    sculptMaskingBlur: null,
    sculptMaskingSharpen: null,
    sculptPBRTitle: null,
    sculptPaintAll: null,
    sculptExtractTitle: null,
    sculptExtractThickness: null,
    sculptExtractAction: null,

    // states
    stateTitle: '履歴',
    stateUndo: 'アンドゥ',
    stateRedo: 'リドゥ',
    stateMaxStack: null,

    // wacom
    wacomTitle: 'ワコムタブレット',
    wacomRadius: '圧力半径？',
    wacomIntensity: '圧力の強さ？',

    // rendering
    renderingTitle: null,
    renderingGrid: null,
    renderingSymmetryLine: null,
    renderingMatcap: null,
    renderingCurvature: null,
    renderingPBR: null,
    renderingTransparency: '透過',
    renderingNormal: 'ノーマル',
    renderingUV: null,
    renderingShader: 'シェーダー',
    renderingMaterial: null,
    renderingImportUV: null,
    renderingImportMatcap: null,
    renderingExtra: null,
    renderingFlat: 'フラットシェーディング',
    renderingWireframe: 'ワイヤーフレーム (W)',
    renderingExposure: null,
    renderingEnvironment: null,
    renderingIsolate: null,
    renderingFilmic: null,

    // contour
    contour: null,
    contourShow: null,
    contourColor: null,
    darkenUnselected: null,

    // pixel ratio
    resolution: null,

    // matcaps
    matcapPearl: null,
    matcapClay: 'クレイ',
    matcapSkin: 'スキン',
    matcapGreen: null,
    matcapWhite: null,

    // sketchfab
    sketchfabTitle: 'Sketchfabへ移動',
    sketchfabUpload: 'アップロード',
    sketchfabUploadMessage: null,
    // 

    sketchfabUploadError: null,
    // 

    sketchfabUploadSuccess: null,
    sketchfabAbort: null,
    sketchfabUploadProcessing: null,

    about: null,

    alphaNone: null,
    alphaSquare: null,
    alphaSkin: null,

    envFootPrint: null,
    envGlazedPatio: null,
    envNicolausChurch: null,
    envTerrace: null,
    envBryantPark: null
  };

  module.exports = TR;
});
define('gui/tr/korean',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var TR = {
    // background
    backgroundTitle: '배경',
    backgroundReset: '초기화',
    backgroundImport: '배경 (jpg, png...)',
    backgroundFill: '채우기',

    // camera
    cameraTitle: '카메라',
    cameraReset: '뷰',
    cameraCenter: '초기화 (bar)',
    cameraFront: '앞쪽 (F)',
    cameraLeft: '왼쪽 (L)',
    cameraTop: '위쪽 (T)',
    cameraMode: '모드',
    cameraOrbit: '궤도 (Turntable)',
    cameraSpherical: '구 (Trackball)',
    cameraPlane: '평면 (Trackball)',
    cameraProjection: '투사',
    cameraPerspective: '원근법',
    cameraOrthographic: '정사영법',
    cameraFov: '시야각',
    cameraPivot: '피봇 고르기',

    // file
    fileTitle: '파일 (가져오기/내보내기)',
    fileImportTitle: '가져오기',
    fileAdd: '파일 (obj, sgl, ply, stl)',
    fileAutoMatrix: null,
    fileVertexSRGB: null,
    fileExportMeshTitle: '메쉬 내보내기',
    fileExportSceneTitle: '장면 내보내기',
    fileExportSGL: 'sgl로 저장하기',
    fileExportOBJ: 'obj로 저장하기',
    fileExportPLY: 'ply로 저장하기',
    fileExportSTL: 'stl로 저장하기',

    // scene
    sceneTitle: '장면',
    sceneReset: '장면 초기화',
    sceneAddSphere: '구 추가하기 ',
    sceneAddCube: null,
    sceneAddCylinder: null,
    sceneAddTorus: null,
    sceneSelection: null,
    sceneMerge: null,

    // mesh
    meshTitle: '메쉬',
    meshNbVertices: '점들 : ',
    meshNbFaces: '면들 : ',

    // topology
    topologyTitle: '토폴로지',

    //multires
    multiresTitle: '다중 해상도',
    multiresSubdivide: '세분화',
    multiresReverse: '리버스',
    multiresResolution: '해상도',
    multiresNoLower: '더 낮은 해상도가 존재하지 않습니다.',
    multiresNoHigher: '더 높은 해상도가 존재하지 않습니다.',
    multiresDelHigher: '더 높은 것을 삭제',
    multiresDelLower: '더 낮은 것을 삭제',
    multiresSelectLowest: '리버싱 하기 전에 더 낮은 해상도를 고르세요.',
    multiresSelectHighest: '세분화 하기 전에 더 높은 해상도를 고르세요',
    multiresWarnBigMesh: function (nbFacesNext) {
      return '다음 세분화 레벨은 ' + nbFacesNext + ' 면만큼 도달할 것입니다.\n' +
        '만약 당신이 무엇을 하는지 안다면 "세분화"를 다시 클릭하세요.';
    },
    multiresNotReversible: '이 메쉬는 리버싱할 수 없습니다.\n' +
      '이 메쉬는 여러가지 메쉬의 표면의 세분화를 product한 것이 아닙니다.(loop-catmull)',

    // remesh
    remeshTitle: null,
    remeshRemesh: null,
    remeshResolution: null,
    remeshBlock: null,

    // dynamic
    dynamicTitle: null,
    dynamicActivated: null,
    dynamicSubdivision: null,
    dynamicDecimation: null,
    dynamicLinear: null,

    // sculpt
    sculptTitle: null,
    sculptBrush: '브러쉬',
    sculptInflate: null,
    sculptTwist: null,
    sculptSmooth: null,
    sculptFlatten: null,
    sculptPinch: null,
    sculptCrease: null,
    sculptDrag: null,
    sculptPaint: null,
    sculptMasking: null,
    sculptMove: null,
    sculptLocalScale: null,
    sculptTransform: null,

    sculptCommon: null,
    sculptTool: null,
    sculptSymmetry: null,
    sculptContinuous: null,
    sculptRadius: null,
    sculptIntensity: null,
    sculptHardness: null,
    sculptCulling: null,
    sculptAlphaTitle: null,
    sculptLockPositon: null,
    sculptAlphaTex: null,
    sculptImportAlpha: null,
    sculptNegative: null,
    sculptColor: null,
    sculptRoughness: null,
    sculptMetallic: null,
    sculptClay: null,
    sculptAccumulate: null,
    sculptColorGlobal: null,
    sculptPickColor: null,
    sculptTangentialSmoothing: null,
    sculptTopologicalCheck: null,
    sculptMoveAlongNormal: null,
    sculptMaskingClear: null,
    sculptMaskingInvert: null,
    sculptMaskingBlur: null,
    sculptMaskingSharpen: null,
    sculptPBRTitle: null,
    sculptPaintAll: null,
    sculptExtractTitle: null,
    sculptExtractThickness: null,
    sculptExtractAction: null,

    // states
    stateTitle: '역사',
    stateUndo: '되돌리기',
    stateRedo: '다시하기',
    stateMaxStack: '최대 스택',

    // wacom
    wacomTitle: '와콤 테블릿',
    wacomRadius: '압력 반지름',
    wacomIntensity: '압력 강도',

    // rendering
    renderingTitle: '렌더링',
    renderingGrid: '그리드 보이기',
    renderingSymmetryLine: '대칭선 보이기',
    renderingMatcap: null,
    renderingCurvature: null,
    renderingPBR: null,
    renderingTransparency: '투명도',
    renderingNormal: '노말 쉐이더',
    renderingUV: 'UV 쉐이더',
    renderingShader: '쉐이더',
    renderingMaterial: '질',
    renderingImportUV: '가져오기 (jpg, png...)',
    renderingImportMatcap: '가져오기 (jpg, png...)',
    renderingExtra: '추가',
    renderingFlat: '편평한 (느리게)',
    renderingWireframe: '와이어프레임 (느리게) (W)',
    renderingExposure: null,
    renderingEnvironment: null,
    renderingIsolate: null,
    renderingFilmic: null,

    // contour
    contour: null,
    contourShow: null,
    contourColor: null,
    darkenUnselected: null,

    // pixel ratio
    resolution: null,

    // matcaps
    matcapPearl: null,
    matcapClay: null,
    matcapSkin: null,
    matcapGreen: null,
    matcapWhite: null,

    // sketchfab
    sketchfabTitle: 'Sketchfab으로 가기 !',
    sketchfabUpload: '올리기',
    sketchfabUploadMessage: null,
    // 

    sketchfabUploadError: null,
    // 

    sketchfabUploadSuccess: null,
    sketchfabAbort: null,
    sketchfabUploadProcessing: null,

    about: null,

    alphaNone: null,
    alphaSquare: null,
    alphaSkin: null,

    envFootPrint: null,
    envGlazedPatio: null,
    envNicolausChurch: null,
    envTerrace: null,
    envBryantPark: null
  };

  module.exports = TR;
});
define('gui/tr/russian',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var TR = {
    // background
    backgroundTitle: 'Фон',
    backgroundReset: 'Сброс',
    backgroundImport: 'Импорт (jpg, png...)',
    backgroundFill: 'Заполнить',

    // camera
    cameraTitle: 'Камера',
    cameraReset: 'Вид',
    cameraCenter: 'Сброс (bar)',
    cameraFront: 'Спереди (F)',
    cameraLeft: 'Слева (L)',
    cameraTop: 'Сверху (T)',
    cameraMode: null,
    cameraOrbit: 'Орбита (Вращение)',
    cameraSpherical: null,
    cameraPlane: 'Плоскость (трекбол)',
    cameraProjection: 'Проекция',
    cameraPerspective: 'Перспективная',
    cameraOrthographic: 'Ортогональная',
    cameraFov: 'Угол обзора',
    cameraPivot: 'Выбор вращения',

    // file
    fileTitle: 'Файл',
    fileImportTitle: 'Импорт',
    fileAdd: 'Добавить(obj,sgl,ply,stl)',
    fileAutoMatrix: 'Масштаб-вид',
    fileVertexSRGB: null,
    fileExportMeshTitle: 'Эксорт модели',
    fileExportSceneTitle: 'Экспорт сцены',
    fileExportSGL: 'Сохранить .sgl',
    fileExportOBJ: 'Сохранить .obj',
    fileExportPLY: 'Сохранить .ply',
    fileExportSTL: 'Сохранить .stl',

    // scene
    sceneTitle: 'Сцена',
    sceneReset: 'Очистить сцену',
    sceneAddSphere: 'Добавить сферу',
    sceneAddCube: 'Добавить куб',
    sceneAddCylinder: null,
    sceneAddTorus: null,
    sceneSelection: 'Выбрать',
    sceneMerge: 'Объединить',

    // mesh
    meshTitle: 'Сетка',
    meshNbVertices: 'Вершины : ',
    meshNbFaces: 'Грани : ',

    // topology
    topologyTitle: 'Топология',

    //multires
    multiresTitle: 'Детализация',
    multiresSubdivide: 'Увеличить',
    multiresReverse: 'Реверс',
    multiresResolution: 'Разрешение',
    multiresNoLower: 'Ниже уровня не существует.',
    multiresNoHigher: 'Выше уровня не существует.',
    multiresDelHigher: 'Удалить высокое',
    multiresDelLower: 'Удалить низкое',
    multiresSelectLowest: 'Выберете низкий перед реверсом.',
    multiresSelectHighest: 'Выберете бысокий перед увеличением.',
    multiresWarnBigMesh: function (nbFacesNext) {
      return 'Следующий уровень ' + nbFacesNext + ' faces.\n' +
        'Если вы уверены, снова нажмите на "разрешение".';
    },
    multiresNotReversible: 'К сожалению это не возможно, чтобы изменить эту сетку.\n' +
      'Сетка не продуктивна.',

    // remesh
    remeshTitle: 'Перестроить воксели',
    remeshRemesh: 'Перестроить',
    remeshResolution: 'Разрешение',
    remeshBlock: 'Блоки-кубики',

    // dynamic
    dynamicTitle: 'Динамическая топология',
    dynamicActivated: 'Активировать (без кубиков)',
    dynamicSubdivision: 'Увеличить',
    dynamicDecimation: 'Прореживание',
    dynamicLinear: 'Линейное увеличение',

    // sculpt
    sculptTitle: 'Лепить и красить',
    sculptBrush: '3D Кисть',
    sculptInflate: '3D Надуть',
    sculptTwist: '3D Закручивание',
    sculptSmooth: '3D Сгладить (-Shift)',
    sculptFlatten: '3D Расплющить',
    sculptPinch: '3D Сдавить',
    sculptCrease: '3D Складка',
    sculptDrag: '3D Тянучка',
    sculptMove: '3D Перемещать',
    sculptLocalScale: '3D масштабирование',
    sculptPaint: '2D Кисть',
    sculptMasking: '2D Маска (-Ctrl)',
    sculptTransform: null,

    sculptCommon: null,
    sculptTool: 'Инструмент',
    sculptSymmetry: 'Симетрия',
    sculptContinuous: 'Спрей',
    sculptRadius: 'Размер (-X)',
    sculptIntensity: 'Сила (-C)',
    sculptHardness: 'Жесткость',
    sculptCulling: 'Тонкая поверхность(передние вершины)',
    sculptAlphaTitle: 'Альфа',
    sculptLockPositon: 'Фиксация',
    sculptAlphaTex: 'Текстура',
    sculptImportAlpha: 'Импорт альфа текстуры (jpg, png...)',
    sculptNegative: 'Негатив (N или -Alt)',
    sculptColor: 'Палитра',
    sculptRoughness: 'Шероховатость',
    sculptMetallic: 'Металлический',
    sculptClay: 'Без учета содержимого',
    sculptAccumulate: 'Наращивать без ограничений',
    sculptColorGlobal: 'Глобальный',
    sculptPickColor: 'Пипетка материал (-S)',
    sculptTangentialSmoothing: null,
    sculptTopologicalCheck: null,
    sculptMoveAlongNormal: null,
    sculptMaskingClear: 'Очистить (-Ctrl + Drag)',
    sculptMaskingInvert: 'Инверсия (-Ctrl + Click)',
    sculptMaskingBlur: 'Сгладить',
    sculptMaskingSharpen: 'Резко',
    sculptPBRTitle: 'PBR материал',
    sculptPaintAll: 'Краска',
    sculptExtractTitle: 'Извлечь',
    sculptExtractThickness: 'Толщина',
    sculptExtractAction: 'Извлечь !',

    // states
    stateTitle: 'История',
    stateUndo: 'Назад',
    stateRedo: 'Вперед',
    stateMaxStack: 'Количество шагов',

    // wacom
    wacomTitle: 'Планшет Wacom',
    wacomRadius: 'Нажим-размер',
    wacomIntensity: 'Нажим-жесткость',

    // rendering
    renderingTitle: 'Визуализация',
    renderingGrid: 'Показать сетку',
    renderingSymmetryLine: 'Линия симетрии',
    renderingMatcap: null,
    renderingCurvature: 'Рельефность',
    renderingPBR: 'PBR',
    renderingTransparency: 'Прозрачность',
    renderingNormal: 'Normal Map',
    renderingUV: 'UV',
    renderingShader: 'Шейдеры',
    renderingMaterial: 'Материал',
    renderingImportUV: 'Импорт (jpg, png...)',
    renderingImportMatcap: 'Импорт (jpg, png...)',
    renderingExtra: 'Дополнительно',
    renderingFlat: 'Плоское-рельефное',
    renderingWireframe: 'Каркас (W)',
    renderingExposure: 'Экспозиция',
    renderingEnvironment: 'Отражение',
    renderingIsolate: 'Изолировать / Показать (I)',
    renderingFilmic: null,

    // contour
    contour: 'Контур',
    contourShow: 'Показать контур',
    contourColor: 'Цвет',
    darkenUnselected: null,

    // pixel ratio
    resolution: null,

    // matcaps
    matcapPearl: 'Жемчуг',
    matcapClay: 'Глина',
    matcapSkin: 'Кожа',
    matcapGreen: 'Зеленый',
    matcapWhite: 'Белый',

    // sketchfab
    sketchfabTitle: 'В Sketchfab.com ',
    sketchfabUpload: 'Загрузить',
    sketchfabUploadMessage: 'Ведите ключ sketchfab API Key.\n' +
      'Вы также можете оставить «Гость», чтобы загрузить anonymously.\n' +
      '(Откроется новое окно, когда загрузка и обработка закончена)',
    sketchfabUploadError: function (error) {
      return 'Sketchfab ошибка загрузки :\n' + error;
    },
    sketchfabUploadSuccess: 'Загрузка выполнена !\nHere is your link :',
    sketchfabAbort: 'Прервать загрузку ?',
    sketchfabUploadProcessing: 'Загружается...\nВаша модель доступна :',

    about: null,

    alphaNone: 'Нет',
    alphaSquare: 'Квадрат',
    alphaSkin: 'Кожа',

    envFootPrint: 'Китайский театр Граумана',
    envGlazedPatio: 'Застекленный дворик',
    envNicolausChurch: 'Церковь Святого Николая',
    envTerrace: 'Терраса',
    envBryantPark: 'Бра́йант-парк'
  };

  module.exports = TR;
});
define('gui/GuiTR',['require','exports','module','misc/getOptionsURL','gui/tr/english','gui/tr/chinese','gui/tr/japanese','gui/tr/korean','gui/tr/russian'],function (require, exports, module) {

  'use strict';

  var getOptionsURL = require('misc/getOptionsURL');
  var english = require('gui/tr/english');
  var chinese = require('gui/tr/chinese');
  var japanese = require('gui/tr/japanese');
  var korean = require('gui/tr/korean');
  var russian = require('gui/tr/russian');

  var GuiTR = function (key) {
    var str = GuiTR.languages[GuiTR.select][key] || GuiTR.languages.english[key];
    if (typeof str === 'string')
      return str;
    if (typeof str === 'function')
      return str.apply(this, Array.prototype.slice.call(arguments, 1));
    console.error('No TR found for : ' + key);
    return key;
  };

  GuiTR.languages = {
    'english': english,
    '日本語': japanese,
    '中文': chinese,
    '한국어': korean,
    'русский': russian
  };

  GuiTR.select = 'english';
  var language = window.navigator.language || window.navigator.userLanguage;
  if (language) language = language.substr(0, 2);
  if (language === 'ja') GuiTR.select = '日本語';
  else if (language === 'zh') GuiTR.select = '中文';
  else if (language === 'ko') GuiTR.select = '한국어';
  else if (language === 'ru') GuiTR.select = 'русский';

  switch (getOptionsURL().language) {
  case 'english':
    GuiTR.select = 'english';
    break;
  case 'chinese':
    GuiTR.select = '中文';
    break;
  case 'korean':
    GuiTR.select = '한국어';
    break;
  case 'japanese':
    GuiTR.select = '日本語';
    break;
  case 'russian':
    GuiTR.select = 'русский';
    break;
  }

  module.exports = GuiTR;
});
define('render/shaders/ShaderMatcap',['require','exports','module','gui/GuiTR','render/shaders/ShaderBase'],function (require, exports, module) {

  'use strict';

  var TR = require('gui/GuiTR');
  var ShaderBase = require('render/shaders/ShaderBase');

  var ShaderMatcap = ShaderBase.getCopy();
  ShaderMatcap.vertexName = ShaderMatcap.fragmentName = 'Matcap';

  ShaderMatcap.textures = {};

  ShaderMatcap.createTexture = function (gl, img, idMaterial) {
    var idTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, idTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
    ShaderMatcap.setTextureParameters(gl, img);
    gl.bindTexture(gl.TEXTURE_2D, null);
    ShaderMatcap.textures[idMaterial] = idTex;
  };

  var texPath = 'resources/matcaps/';
  ShaderMatcap.matcaps = [{
    path: texPath + 'matcapFV.jpg',
    name: 'matcap FV' // too lazy to tr
  }, {
    path: texPath + 'redClay.jpg',
    name: 'Red clay' // too lazy to tr
  }, {
    path: texPath + 'skinHazardousarts.jpg',
    name: 'Skin hazardousarts' // too lazy to tr
  }, {
    path: texPath + 'skinHazardousarts2.jpg',
    name: 'Skin Hazardousarts2' // too lazy to tr
  }, {
    path: texPath + 'pearl.jpg',
    name: TR('matcapPearl')
  }, {
    path: texPath + 'clay.jpg',
    name: TR('matcapClay')
  }, {
    path: texPath + 'skin.jpg',
    name: TR('matcapSkin')
  }, {
    path: texPath + 'green.jpg',
    name: TR('matcapGreen')
  }, {
    path: texPath + 'white.jpg',
    name: TR('matcapWhite')
  }];

  ShaderMatcap.uniforms = {};
  ShaderMatcap.attributes = {};

  ShaderMatcap.uniformNames = ['uTexture0', 'uAlbedo'];
  Array.prototype.push.apply(ShaderMatcap.uniformNames, ShaderBase.uniformNames.commonUniforms);

  ShaderMatcap.vertex = [
    'precision mediump float;',
    'attribute vec3 aVertex;',
    'attribute vec3 aNormal;',
    'attribute vec3 aColor;',
    'attribute vec3 aMaterial;',
    ShaderBase.strings.vertUniforms,
    'varying vec3 vVertex;',
    'varying vec3 vNormal;',
    'varying vec3 vColor;',
    'varying float vMasking;',
    'varying vec3 vVertexPres;',
    'uniform vec3 uAlbedo;',
    'void main() {',
    '  vColor = uAlbedo.x >= 0.0 ? uAlbedo : aColor;',
    '  vMasking = aMaterial.z;',
    '  vNormal = mix(aNormal, uEN * aNormal, vMasking);',
    '  vNormal = normalize(uN * vNormal);',
    '  vec4 vertex4 = vec4(aVertex, 1.0);',
    '  vertex4 = mix(vertex4, uEM *vertex4, vMasking);',
    '  vVertex = vec3(uMV * vertex4);',
    // annoying stuffs : on mobile + with ortho matrix 
    // there's a precision issue with vVertex lerp between VS and FS
    // it is caused by the big ortho z translation factor, one solutions
    // is to use highp, one another to compute the matcap UV in the VS (but 
    // no flat shading in that case)
    '  vVertexPres = vVertex / max(1.0, abs(uMV[3][2]));',
    '  gl_Position = uMVP * vertex4;',
    '}'
  ].join('\n');

  ShaderMatcap.fragment = [
    'precision mediump float;',
    'uniform sampler2D uTexture0;',
    'varying vec3 vVertex;',
    'varying vec3 vVertexPres;',
    'varying vec3 vNormal;',
    'varying vec3 vColor;',
    'uniform float uAlpha;',
    ShaderBase.strings.fragColorUniforms,
    ShaderBase.strings.fragColorFunction,
    'void main() {',
    '  vec3 normal = getNormal();',
    '  vec3 nm_z = normalize(vVertexPres);',
    '  vec3 nm_x = vec3(-nm_z.z, 0.0, nm_z.x);',
    '  vec3 nm_y = cross(nm_x, nm_z);',
    '  vec2 texCoord = 0.5 + 0.5 * vec2(dot(normal, nm_x), dot(normal, nm_y));',
    '  vec3 color = sRGBToLinear(texture2D(uTexture0, texCoord).rgb) * sRGBToLinear(vColor);',
    '  gl_FragColor = encodeFragColor(color, uAlpha);',
    '}'
  ].join('\n');

  ShaderMatcap.updateUniforms = function (render, main) {
    var gl = render.getGL();
    var uniforms = this.uniforms;

    gl.activeTexture(gl.TEXTURE0);
    render.setTexture0(ShaderMatcap.textures[render.getMatcap()] || ShaderMatcap.textures[0]);
    gl.bindTexture(gl.TEXTURE_2D, render.getTexture0());
    gl.uniform1i(uniforms.uTexture0, 0);

    gl.uniform3fv(uniforms.uAlbedo, render.getAlbedo());
    ShaderBase.updateUniforms.call(this, render, main);
  };

  module.exports = ShaderMatcap;
});
define('render/shaders/ShaderMerge',['require','exports','module','render/shaders/ShaderBase','render/Attribute','misc/getOptionsURL'],function (require, exports, module) {

  'use strict';

  var ShaderBase = require('render/shaders/ShaderBase');
  var Attribute = require('render/Attribute');
  var getOptionsURL = require('misc/getOptionsURL');

  var ShaderMerge = ShaderBase.getCopy();
  ShaderMerge.vertexName = ShaderMerge.fragmentName = 'Merge';

  ShaderMerge.FILMIC = getOptionsURL().filmic; // edited by the gui

  ShaderMerge.uniforms = {};
  ShaderMerge.attributes = {};

  ShaderMerge.uniformNames = ['uTexture0', 'uTexture1', 'uFilmic'];

  ShaderMerge.vertex = [
    'precision mediump float;',
    'attribute vec2 aVertex;',
    'varying vec2 vTexCoord;',
    'void main() {',
    '  vTexCoord = aVertex * 0.5 + 0.5;',
    '  gl_Position = vec4(aVertex, 0.5, 1.0);',
    '}'
  ].join('\n');

  ShaderMerge.fragment = [
    'precision mediump float;',
    'uniform sampler2D uTexture0;',
    'uniform sampler2D uTexture1;',
    'uniform int uFilmic;',
    'varying vec2 vTexCoord;',
    ShaderBase.strings.colorSpaceGLSL,
    'void main() {',
    '  vec4 transparent = texture2D(uTexture1, vTexCoord);',
    '  vec3 color = decodeRGBM(texture2D(uTexture0, vTexCoord))*(1.0-transparent.a) + transparent.rgb;',
    // http://filmicgames.com/archives/75
    '  if(uFilmic == 1){',
    '    vec3 x = max(vec3(0.0), color - vec3(0.004));',
    '    gl_FragColor = vec4((x*(6.2*x+0.5))/(x*(6.2*x+1.7)+0.06), 1.0);',
    '  }else{',
    '    gl_FragColor = vec4(lineartoSRGB(color), 1.0);',
    '  }',
    '}'
  ].join('\n');

  ShaderMerge.draw = function (rtt, main) {
    var gl = rtt.getGL();
    gl.useProgram(this.program);

    ShaderMerge.attributes.aVertex.bindToBuffer(rtt.getVertexBuffer());

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, main._rttOpaque.getTexture());
    gl.uniform1i(this.uniforms.uTexture0, 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, main._rttTransparent.getTexture());
    gl.uniform1i(this.uniforms.uTexture1, 1);

    gl.uniform1i(this.uniforms.uFilmic, ShaderMerge.FILMIC);

    gl.drawArrays(gl.TRIANGLES, 0, 3);
  };
  ShaderMerge.initAttributes = function (gl) {
    ShaderMerge.attributes.aVertex = new Attribute(gl, ShaderMerge.program, 'aVertex', 2, gl.FLOAT);
  };

  module.exports = ShaderMerge;
});
define('render/shaders/ShaderNormal',['require','exports','module','render/shaders/ShaderBase'],function (require, exports, module) {

  'use strict';

  var ShaderBase = require('render/shaders/ShaderBase');

  var ShaderNormal = ShaderBase.getCopy();
  ShaderNormal.vertexName = ShaderNormal.fragmentName = 'ShowNormal';

  ShaderNormal.uniforms = {};
  ShaderNormal.attributes = {};
  ShaderNormal.activeAttributes = {
    vertex: true,
    normal: true,
    material: true
  };

  ShaderNormal.uniformNames = [];
  Array.prototype.push.apply(ShaderNormal.uniformNames, ShaderBase.uniformNames.commonUniforms);

  ShaderNormal.vertex = [
    'precision mediump float;',
    'attribute vec3 aVertex;',
    'attribute vec3 aNormal;',
    'attribute vec3 aMaterial;',
    ShaderBase.strings.vertUniforms,
    'varying vec3 vVertex;',
    'varying vec3 vNormal;',
    'varying float vMasking;',
    'void main() {',
    '  vMasking = aMaterial.z;',
    '  vNormal = mix(aNormal, uEN * aNormal, vMasking);',
    '  vNormal = normalize(uN * vNormal);',
    '  vec4 vertex4 = vec4(aVertex, 1.0);',
    '  vertex4 = mix(vertex4, uEM *vertex4, vMasking);',
    '  vVertex = vec3(uMV * vertex4);',
    '  gl_Position = uMVP * vertex4;',
    '}'
  ].join('\n');

  ShaderNormal.fragment = [
    'precision mediump float;',
    'varying vec3 vVertex;',
    'varying vec3 vNormal;',
    'uniform float uAlpha;',
    ShaderBase.strings.fragColorUniforms,
    ShaderBase.strings.fragColorFunction,
    'void main() {',
    '  gl_FragColor = encodeFragColor(sRGBToLinear(getNormal() * 0.5 + 0.5), uAlpha);',
    '}'
  ].join('\n');

  module.exports = ShaderNormal;
});

define('text!render/shaders/glsl/pbr.glsl',[],function () { return '#define PI 3.1415926535897932384626433832795\n#define PI_2 (2.0*3.1415926535897932384626433832795)\n#define INV_PI 1.0/PI\n#define INV_LOG2 1.4426950408889634073599246810019\n\nuniform sampler2D uTexture0;\nuniform float uExposure;\nuniform mat3 uIblTransform;\n\nvec2 environmentSize = vec2(1024, 512);\nvec2 environmentLodRange = vec2(10, 5);\n\nconst mat3 LUVInverse = mat3( 6.0013, -2.700, -1.7995, -1.332, 3.1029, -5.7720, 0.3007, -1.088, 5.6268 );\nvec3 LUVToRGB( const in vec4 vLogLuv ) {\n  float Le = vLogLuv.z * 255.0 + vLogLuv.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;\n  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;\n  return max(LUVInverse * Xp_Y_XYZp, 0.0);\n}\n\nvec2 computeUVForMipmap( const in float level, const in vec2 uv, const in float size, const in float maxLOD ) {\n  float widthForLevel = exp2( maxLOD - level);\n  vec2 uvSpaceLocal =  vec2(1.0) + uv * vec2(widthForLevel - 2.0, widthForLevel * 0.5 - 2.0);\n  uvSpaceLocal.y += size - widthForLevel;\n  return uvSpaceLocal / size;\n}\n\nvec2 normalToPanoramaUVY( const in vec3 dir ) {\n  float n = length(dir.xz);\n  vec2 pos = vec2( (n>0.0000001) ? max(-1.0,dir.x / n) : 0.0, dir.y);\n  if ( pos.x > 0.0 ) pos.x = min( 0.999999, pos.x );\n  pos = acos(pos)*INV_PI;\n  pos.x = (dir.z > 0.0) ? pos.x*0.5 : 1.0-(pos.x*0.5);\n  pos.x = mod(pos.x-0.25+1.0, 1.0 );\n  pos.y = 1.0-pos.y;\n  return pos;\n}\n\nvec3 texturePanoramaLod(const in sampler2D texture, const in vec2 size , const in vec3 direction, const in float lodInput, const in float maxLOD ) {\n  float lod = min( maxLOD, lodInput );\n  vec2 uvBase = normalToPanoramaUVY( direction );\n  vec3 texel0 = LUVToRGB(texture2D( texture, computeUVForMipmap(floor(lod), uvBase, size.x, maxLOD )));\n  vec3 texel1 = LUVToRGB(texture2D( texture, computeUVForMipmap(ceil(lod), uvBase, size.x, maxLOD )));\n  return mix(texel0, texel1, fract( lod ) );\n}\n\nvec3 integrateBRDFApprox(const in vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specular * AB.x + AB.y;\n}\n\nvec3 getSpecularDominantDir( const in vec3 N, const in vec3 R, const in float realRoughness ) {\n    float smoothness = 1.0 - realRoughness;\n    return mix( N, R, smoothness * ( sqrt( smoothness ) + realRoughness ) );\n}\n\nvec3 approximateSpecularIBL( const in vec3 specularColor, float rLinear, const in vec3 N, const in vec3 V ) {\n  float NoV = clamp( dot( N, V ), 0.0, 1.0 );\n  vec3 R = normalize( (2.0 * NoV ) * N - V);\n  R = getSpecularDominantDir(N, R, rLinear);\n  vec3 prefilteredColor = texturePanoramaLod( uTexture0, environmentSize, uIblTransform * R, rLinear * environmentLodRange[1], environmentLodRange[0] );\n  return prefilteredColor * integrateBRDFApprox(specularColor, rLinear, NoV);\n}\n\n// expect shCoefs uniform\n// https://github.com/cedricpinson/envtools/blob/master/Cubemap.cpp#L523\nvec3 sphericalHarmonics( const in vec3 N ) {\n  float x = N.x;\n  float y = N.y;\n  float z = N.z;\n  vec3 result = uSPH[0] + uSPH[1] * y + uSPH[2] * z + uSPH[3] * x + uSPH[4] * y * x + uSPH[5] * y * z + uSPH[6] * (3.0 * z * z - 1.0) + uSPH[7] * (z * x) + uSPH[8] * (x*x - y*y);\n  return max(result, vec3(0.0));\n}\n\nvec3 computeIBL_UE4( const in vec3 N, const in vec3 V, const in vec3 albedo, const in float roughness, const in vec3 specular) {\n  vec3 color = vec3(0.0);\n  if ( albedo != color )\n    color += albedo * sphericalHarmonics( uIblTransform * N );\n  color += approximateSpecularIBL(specular, roughness, N, V);\n  return color;\n}\n';});

define('render/shaders/ShaderPBR',['require','exports','module','lib/glMatrix','misc/getOptionsURL','render/shaders/ShaderBase','text!render/shaders/glsl/pbr.glsl','gui/GuiTR'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var getOptionsURL = require('misc/getOptionsURL');
  var ShaderBase = require('render/shaders/ShaderBase');
  var pbrGLSL = require('text!render/shaders/glsl/pbr.glsl');
  var TR = require('gui/GuiTR');

  var mat3 = glm.mat3;

  var ShaderPBR = ShaderBase.getCopy();
  ShaderPBR.vertexName = ShaderPBR.fragmentName = 'ShadingPBR';

  ShaderPBR.textures = {};

  // TODO update i18n strings in a dynamic way
  var texPath = 'resources/environments/';
  ShaderPBR.environments = [{
    path: texPath + 'footPrint.bin',
    sph: [0.96097, 0.856821, 1.11124, -0.313999, -0.358144, -0.625599, 0.0870941, 0.1109, 0.171528, -0.100569, -0.0498991, -0.0302566, 0.02047, 0.0151743, 0.0182682, -0.00652953, -0.0188746, -0.0525354, 0.00192821, -0.0279455, -0.110808, -0.0180287, -0.0227345, -0.0422744, 0.0139192, -0.0187345, -0.0812033],
    name: TR('envFootPrint')
  }, {
    path: texPath + 'glazedPatio.bin',
    sph: [0.475424, 0.460106, 0.407626, -0.0626622, -0.0978501, -0.148369, -0.029662, -0.022522, -0.0109794, -0.0893952, -0.116715, -0.139033, 0.0450059, 0.0514445, 0.0619667, 0.00471057, 0.00393219, 0.00522881, -0.0508041, -0.0540791, -0.0530655, -0.0278953, -0.0258599, -0.0191718, -0.0137735, -0.0186312, -0.0286948],
    name: TR('envGlazedPatio')
  }, {
    path: texPath + 'nicolausChurch.bin',
    sph: [1.67609, 1.52776, 1.05807, -0.261794, -0.293249, -0.225056, 0.0371792, 0.0263728, -0.0174064, 0.142577, 0.121132, 0.0724402, 0.00827981, 0.00263222, 0.00184229, 0.0208164, 0.0128967, 0.0139606, 0.0795516, 0.0909961, 0.0897778, 0.058084, 0.0541786, 0.0401144, -0.0664757, -0.0587091, -0.0386655],
    name: TR('envNicolausChurch')
  }, {
    path: texPath + 'terrace.bin',
    sph: [0.688602, 0.636799, 0.515733, -0.192892, -0.219448, -0.242244, 0.126328, 0.124547, 0.0928089, 0.308754, 0.307826, 0.214901, -0.0713295, -0.0740211, -0.0583892, -0.0283229, -0.0290954, -0.0224256, -0.030012, -0.0302393, -0.0280645, 0.0766113, 0.0653549, 0.0388244, 0.104034, 0.0751443, 0.0221583],
    name: TR('envTerrace')
  }, {
    path: texPath + 'bryantPark.bin',
    sph: [0.583073, 0.794556, 0.966801, -0.218899, -0.334516, -0.690954, -0.0581536, -0.0912214, -0.13112, 0.0180201, 0.0683966, 0.157536, -0.0427475, -0.073612, -0.112892, 0.0490024, 0.06527, 0.0841072, -0.0243839, -0.0429701, -0.0792229, -0.0441213, -0.0562622, -0.0728875, -0.0267015, -0.0586719, -0.11978],
    name: TR('envBryantPark')
  }];
  var opts = getOptionsURL();
  ShaderPBR.idEnv = Math.min(opts.environment, ShaderPBR.environments.length - 1);
  ShaderPBR.exposure = Math.min(opts.exposure, 5);

  ShaderPBR.uniforms = {};
  ShaderPBR.attributes = {};

  ShaderPBR.uniformNames = ['uIblTransform', 'uTexture0', 'uAlbedo', 'uRoughness', 'uMetallic', 'uExposure', 'uSPH'];
  Array.prototype.push.apply(ShaderPBR.uniformNames, ShaderBase.uniformNames.commonUniforms);

  ShaderPBR.vertex = [
    'precision mediump float;',
    'attribute vec3 aVertex;',
    'attribute vec3 aNormal;',
    'attribute vec3 aColor;',
    'attribute vec3 aMaterial;',
    ShaderBase.strings.vertUniforms,
    'uniform float uRoughness;',
    'uniform float uMetallic;',
    'uniform vec3 uAlbedo;',
    'varying vec3 vVertex;',
    'varying vec3 vNormal;',
    'varying vec3 vAlbedo;',
    'varying float vRoughness;',
    'varying float vMetallic;',
    'varying float vMasking;',
    'void main() {',
    '  vAlbedo = uAlbedo.x >= 0.0 ? uAlbedo : aColor;',
    '  vRoughness = uRoughness >= 0.0 ? uRoughness : aMaterial.x;',
    '  vMetallic = uMetallic >= 0.0 ? uMetallic : aMaterial.y;',
    '  vMasking = aMaterial.z;',
    '  vNormal = mix(aNormal, uEN * aNormal, vMasking);',
    '  vNormal = normalize(uN * vNormal);',
    '  vec4 vertex4 = vec4(aVertex, 1.0);',
    '  vertex4 = mix(vertex4, uEM * vertex4, vMasking);',
    '  vVertex = vec3(uMV * vertex4);',
    '  gl_Position = uMVP * vertex4;',
    '}'
  ].join('\n');

  ShaderPBR.fragment = [
    'precision mediump float;',
    'varying vec3 vVertex;',
    'varying vec3 vNormal;',
    'varying vec3 vAlbedo;',
    'varying float vRoughness;',
    'varying float vMetallic;',
    'uniform float uAlpha;',
    'uniform vec3 uSPH[9];',
    ShaderBase.strings.fragColorUniforms,
    ShaderBase.strings.fragColorFunction,
    pbrGLSL,
    '',
    'void main(void) {',
    '  vec3 normal = getNormal();',
    '  float roughness = max( 0.0001, vRoughness );',
    '  vec3 linColor = sRGBToLinear(vAlbedo);',
    '  vec3 albedo = linColor * (1.0 - vMetallic);',
    '  vec3 specular = mix( vec3(0.04), linColor, vMetallic);',
    '',
    '  vec3 color = uExposure * computeIBL_UE4( normal, -normalize(vVertex), albedo, roughness, specular );',
    '  gl_FragColor = encodeFragColor(color, uAlpha);',
    '}'
  ].join('\n');

  ShaderPBR.onLoadEnvironment = function (xhr, gl, main, env) {
    // nodejs context : status is 0 for some reasons
    if (xhr.status !== 200 && (!xhr.response || !xhr.response.byteLength))
      return;
    env.texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, env.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1024, 1024, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(xhr.response));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.bindTexture(gl.TEXTURE_2D, null);
    if (main)
      main.render();
  };
  ShaderPBR.getOrCreateEnvironment = function (gl, main, env) {
    if (env.texture !== undefined) return env.texture;
    env.texture = null;

    var xhr = new XMLHttpRequest();
    xhr.open('GET', env.path, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = ShaderPBR.onLoadEnvironment.bind(this, xhr, gl, main, env);
    xhr.send(null);

    return null;
  };

  ShaderPBR.getOrCreateSPH = function (env) {
    if (env.sphCoef) return env.sphCoef;
    var c0 = 1.0 / (2.0 * Math.sqrt(Math.PI));
    var c1 = -(Math.sqrt(3.0 / Math.PI) * 0.5);
    var c2 = -c1;
    var c3 = c1;
    var c4 = Math.sqrt(15.0 / Math.PI) * 0.5;
    var c5 = -c4;
    var c6 = Math.sqrt(5.0 / Math.PI) * 0.25;
    var c7 = c5;
    var c8 = Math.sqrt(15.0 / Math.PI) * 0.25;
    var coef = [c0, c0, c0, c1, c1, c1, c2, c2, c2, c3, c3, c3, c4, c4, c4, c5, c5, c5, c6, c6, c6, c7, c7, c7, c8, c8, c8];
    var sphCoef = env.sphCoef = new Float32Array(27);
    var sph = env.sph;
    for (var i = 0; i < 27; ++i)
      sphCoef[i] = sph[i] * coef[i];
    return sphCoef;
  };

  var uIBLTmp = mat3.create();
  ShaderPBR.updateUniforms = function (render, main) {
    var gl = render.getGL();
    var uniforms = this.uniforms;

    mat3.fromMat4(uIBLTmp, main.getCamera().getView());
    gl.uniformMatrix3fv(uniforms.uIblTransform, false, mat3.transpose(uIBLTmp, uIBLTmp));

    gl.uniform3fv(uniforms.uAlbedo, render.getAlbedo());
    gl.uniform1f(uniforms.uRoughness, render.getRoughness());
    gl.uniform1f(uniforms.uMetallic, render.getMetallic());
    gl.uniform1f(uniforms.uExposure, ShaderPBR.exposure);

    var env = ShaderPBR.environments[ShaderPBR.idEnv];
    gl.uniform3fv(uniforms.uSPH, ShaderPBR.getOrCreateSPH(env));

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, ShaderPBR.getOrCreateEnvironment(gl, main, env));
    gl.uniform1i(uniforms.uTexture0, 0);

    ShaderBase.updateUniforms.call(this, render, main);
  };

  module.exports = ShaderPBR;
});
define('render/shaders/ShaderUV',['require','exports','module','render/shaders/ShaderBase','render/Attribute'],function (require, exports, module) {

  'use strict';

  var ShaderBase = require('render/shaders/ShaderBase');
  var Attribute = require('render/Attribute');

  var ShaderUV = ShaderBase.getCopy();
  ShaderUV.vertexName = ShaderUV.fragmentName = 'ShowUV';

  ShaderUV.texPath = 'resources/uv.jpg';

  ShaderUV.uniforms = {};
  ShaderUV.attributes = {};

  ShaderUV.uniformNames = ['uTexture0', 'uAlbedo'];
  Array.prototype.push.apply(ShaderUV.uniformNames, ShaderBase.uniformNames.commonUniforms);

  ShaderUV.vertex = [
    'precision mediump float;',
    'attribute vec3 aVertex;',
    'attribute vec3 aNormal;',
    'attribute vec3 aColor;',
    'attribute vec2 aTexCoord;',
    'attribute vec3 aMaterial;',
    ShaderBase.strings.vertUniforms,
    'varying vec3 vVertex;',
    'varying vec3 vNormal;',
    'varying vec3 vColor;',
    'varying vec2 vTexCoord;',
    'varying float vMasking;',
    'uniform vec3 uAlbedo;',
    'void main() {',
    '  vColor = uAlbedo.x >= 0.0 ? uAlbedo : aColor;',
    '  vTexCoord = aTexCoord;',
    '  vMasking = aMaterial.z;',
    '  vNormal = mix(aNormal, uEN * aNormal, vMasking);',
    '  vNormal = normalize(uN * vNormal);',
    '  vec4 vertex4 = vec4(aVertex, 1.0);',
    '  vertex4 = mix(vertex4, uEM *vertex4, vMasking);',
    '  vVertex = vec3(uMV * vertex4);',
    '  gl_Position = uMVP * vertex4;',
    '}'
  ].join('\n');

  ShaderUV.fragment = [
    'precision mediump float;',
    'uniform sampler2D uTexture0;',
    'varying vec3 vVertex;',
    'varying vec3 vNormal;',
    'varying vec3 vColor;',
    'varying vec2 vTexCoord;',
    'uniform float uAlpha;',
    ShaderBase.strings.fragColorUniforms,
    ShaderBase.strings.fragColorFunction,
    'void main() {',
    '  vec3 color = sRGBToLinear(texture2D(uTexture0, vTexCoord).rgb) * sRGBToLinear(vColor);',
    '  gl_FragColor = encodeFragColor(color, uAlpha);',
    '}'
  ].join('\n');

  ShaderUV.draw = ShaderBase.draw;
  ShaderUV.drawBuffer = ShaderBase.drawBuffer;
  ShaderUV.getOrCreate = ShaderBase.getOrCreate;
  ShaderUV.initUniforms = ShaderBase.initUniforms;
  ShaderUV.initAttributes = function (gl) {
    ShaderBase.initAttributes.call(this, gl);
    ShaderUV.attributes.aTexCoord = new Attribute(gl, ShaderUV.program, 'aTexCoord', 2, gl.FLOAT);
  };
  ShaderUV.bindAttributes = function (render) {
    ShaderBase.bindAttributes.call(this, render);
    ShaderUV.attributes.aTexCoord.bindToBuffer(render.getTexCoordBuffer());
  };
  ShaderUV.updateUniforms = function (render, main) {
    var gl = render.getGL();
    var uniforms = this.uniforms;

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, ShaderBase.getOrCreateTexture0.call(this, gl, ShaderUV.texPath, main) || null);
    gl.uniform1i(uniforms.uTexture0, 0);

    gl.uniform3fv(uniforms.uAlbedo, render.getAlbedo());
    ShaderBase.updateUniforms.call(this, render, main);
  };

  module.exports = ShaderUV;
});
define('render/shaders/ShaderWireframe',['require','exports','module','render/shaders/ShaderBase'],function (require, exports, module) {

  'use strict';

  var ShaderBase = require('render/shaders/ShaderBase');

  var ShaderWireframe = ShaderBase.getCopy();
  ShaderWireframe.vertexName = ShaderWireframe.fragmentName = 'Wireframe';

  ShaderWireframe.uniforms = {};
  ShaderWireframe.attributes = {};
  ShaderWireframe.activeAttributes = {
    vertex: true,
    material: true
  };

  ShaderWireframe.uniformNames = ['uMVP', 'uEM'];

  ShaderWireframe.vertex = [
    'attribute vec3 aVertex;',
    'attribute vec3 aMaterial;',
    'uniform mat4 uMVP;',
    'uniform mat4 uEM;',
    'void main() {',
    '  vec4 vertex4 = vec4(aVertex, 1.0);',
    '  vec4 pos = uMVP * mix(vertex4, uEM * vertex4, aMaterial.z);',
    '  pos[3] += 0.0001;',
    '  gl_Position = pos;',
    '}'
  ].join('\n');

  ShaderWireframe.fragment = [
    'precision mediump float;',
    'void main() {',
    '  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.4);',
    '}'
  ].join('\n');

  ShaderWireframe.getOrCreate = ShaderBase.getOrCreate;
  ShaderWireframe.draw = function (render /*, main*/ ) {
    var gl = render.getGL();
    gl.useProgram(this.program);
    this.bindAttributes(render);
    this.updateUniforms(render);
    render.getWireframeBuffer().bind();

    gl.drawElements(gl.LINES, render.getMesh().getRenderNbEdges() * 2, gl.UNSIGNED_INT, 0);
  };
  ShaderWireframe.updateUniforms = function (render) {
    render.getGL().uniformMatrix4fv(this.uniforms.uMVP, false, render.getMesh().getMVP());
    render.getGL().uniformMatrix4fv(this.uniforms.uEM, false, render.getMesh().getEditMatrix());
  };

  module.exports = ShaderWireframe;
});
define('render/ShaderLib',['require','exports','module','render/shaders/ShaderBackground','render/shaders/ShaderContour','render/shaders/ShaderSelection','render/shaders/ShaderFlat','render/shaders/ShaderFxaa','render/shaders/ShaderMatcap','render/shaders/ShaderMerge','render/shaders/ShaderNormal','render/shaders/ShaderPBR','render/shaders/ShaderUV','render/shaders/ShaderWireframe'],function (require, exports, module) {

  'use strict';

  var Sbackground = require('render/shaders/ShaderBackground');
  var Scontour = require('render/shaders/ShaderContour');
  var Sselection = require('render/shaders/ShaderSelection');
  var Sflat = require('render/shaders/ShaderFlat');
  var Sfxaa = require('render/shaders/ShaderFxaa');
  var Smatcap = require('render/shaders/ShaderMatcap');
  var Smerge = require('render/shaders/ShaderMerge');
  var Snormal = require('render/shaders/ShaderNormal');
  var SPBR = require('render/shaders/ShaderPBR');
  var Suv = require('render/shaders/ShaderUV');
  var Swireframe = require('render/shaders/ShaderWireframe');

  var ShaderLib = {};

  // 3D shaders
  ShaderLib.PBR = SPBR;
  ShaderLib.MATCAP = Smatcap;
  ShaderLib.NORMAL = Snormal;
  ShaderLib.UV = Suv;
  ShaderLib.WIREFRAME = Swireframe;
  ShaderLib.FLAT = Sflat;
  ShaderLib.SELECTION = Sselection;

  // 2D screen shaders
  ShaderLib.BACKGROUND = Sbackground;
  ShaderLib.MERGE = Smerge;
  ShaderLib.FXAA = Sfxaa;
  ShaderLib.CONTOUR = Scontour;

  module.exports = ShaderLib;
});
define('render/Buffer',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var Buffer = function (gl, type, hint) {
    this._gl = gl; // webgl context
    this._buffer = gl.createBuffer(); // the buffer
    this._type = type; // the type (vert data vs index)
    this._hint = hint; //the buffer update hint
    this._size = 0; // the size of the buffer
  };

  Buffer.prototype = {
    /** Bind the buffer */
    bind: function () {
      this._gl.bindBuffer(this._type, this._buffer);
    },
    /** Release the buffer */
    release: function () {
      this._gl.deleteBuffer(this._buffer);
    },
    /** Update the buffer content */
    update: function (data) {
      this._gl.bindBuffer(this._type, this._buffer);
      if (data.length > this._size) {
        this._gl.bufferData(this._type, data, this._hint);
        this._size = data.length;
      } else {
        this._gl.bufferSubData(this._type, 0, data);
      }
    }
  };

  module.exports = Buffer;
});
define('mesh/Render',['require','exports','module','misc/getOptionsURL','render/ShaderLib','render/Buffer','render/shaders/ShaderMatcap'],function (require, exports, module) {

  'use strict';

  var getOptionsURL = require('misc/getOptionsURL');
  var Shader = require('render/ShaderLib');
  var Buffer = require('render/Buffer');
  var ShaderMatcap = require('render/shaders/ShaderMatcap');

  var Render = function (gl, mesh) {
    this._mesh = mesh;
    this._gl = gl;

    var opts = getOptionsURL();
    this._shaderName = opts.shader;
    this._flatShading = opts.flatshading;
    this._showWireframe = opts.wireframe;
    this._matcap = Math.min(opts.matcap, ShaderMatcap.matcaps.length - 1); // matcap id
    this._curvature = Math.min(opts.curvature, 5.0);
    this._texture0 = null;

    this._useDrawArrays = false;
    this._vertexBuffer = new Buffer(gl, gl.ARRAY_BUFFER, gl.DYNAMIC_DRAW);
    this._normalBuffer = new Buffer(gl, gl.ARRAY_BUFFER, gl.DYNAMIC_DRAW);
    this._colorBuffer = new Buffer(gl, gl.ARRAY_BUFFER, gl.DYNAMIC_DRAW);
    this._materialBuffer = new Buffer(gl, gl.ARRAY_BUFFER, gl.DYNAMIC_DRAW);
    this._texCoordBuffer = new Buffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
    this._indexBuffer = new Buffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW);
    this._wireframeBuffer = new Buffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW);

    // these material values overrides the vertex attributes
    // it's here for debug or preview
    this._albedo = new Float32Array([-1.0, -1.0, -1.0]);
    this._roughness = -0.18;
    this._metallic = -0.78;
    this._alpha = 1.0;

    this._flatColor = new Float32Array([1.0, 0.0, 0.0]);
    this._mode = gl.TRIANGLES;
  };

  Render.ONLY_DRAW_ARRAYS = false;

  Render.prototype = {
    ////////////////
    // GETTERS
    ////////////////
    getCount: function () {
      var gl = this._gl;
      if (this._mode === gl.TRIANGLES)
        return this._mesh.getNbTriangles() * 3;
      if (this._mode === gl.LINES)
        return this._mesh.getNbVertices();
      return 0;
    },
    getGL: function () {
      return this._gl;
    },
    getMesh: function () {
      return this._mesh;
    },
    getVertexBuffer: function () {
      return this._vertexBuffer;
    },
    getNormalBuffer: function () {
      return this._normalBuffer;
    },
    getColorBuffer: function () {
      return this._colorBuffer;
    },
    getMaterialBuffer: function () {
      return this._materialBuffer;
    },
    getTexCoordBuffer: function () {
      return this._texCoordBuffer;
    },
    getIndexBuffer: function () {
      return this._indexBuffer;
    },
    getWireframeBuffer: function () {
      return this._wireframeBuffer;
    },
    ////////////////
    // GETTERS / SETTERS
    ////////////////
    getFlatColor: function () {
      return this._flatColor;
    },
    setFlatColor: function (val) {
      this._flatColor.set(val);
    },
    getMode: function () {
      return this._mode;
    },
    setMode: function (mode) {
      this._mode = mode;
    },
    getAlbedo: function () {
      return this._albedo;
    },
    setAlbedo: function (val) {
      this._albedo.set(val);
    },
    getRoughness: function () {
      return this._roughness;
    },
    setRoughness: function (val) {
      this._roughness = val;
    },
    getMetallic: function () {
      return this._metallic;
    },
    setMetallic: function (val) {
      this._metallic = val;
    },
    getOpacity: function () {
      return this._alpha;
    },
    setOpacity: function (alpha) {
      this._alpha = alpha;
    },
    getTexture0: function () {
      return this._texture0;
    },
    setTexture0: function (tex) {
      this._texture0 = tex;
    },
    getMatcap: function () {
      return this._matcap;
    },
    setMatcap: function (idMat) {
      this._matcap = idMat;
    },
    getCurvature: function () {
      return this._curvature;
    },
    setCurvature: function (cur) {
      this._curvature = cur;
    },
    getFlatShading: function () {
      return this._flatShading;
    },
    setFlatShading: function (flatShading) {
      this._flatShading = flatShading;
    },
    getShowWireframe: function () {
      return this._showWireframe;
    },
    setShowWireframe: function (showWireframe) {
      this._showWireframe = Render.ONLY_DRAW_ARRAYS ? false : showWireframe;
      this.updateWireframeBuffer();
    },
    isUsingDrawArrays: function () {
      return this._useDrawArrays || Render.ONLY_DRAW_ARRAYS;
    },
    setUseDrawArrays: function (bool) {
      this._useDrawArrays = bool;
    },
    isUsingTexCoords: function () {
      return this._shaderName === 'UV';
    },
    isTransparent: function () {
      return this._alpha < 0.99;
    },
    getShaderName: function () {
      return this._shaderName;
    },
    setShaderName: function (shaderName) {
      var hasUV = this._mesh.hasUV();
      if (shaderName === 'UV' && !hasUV)
        return;

      this._shaderName = shaderName;
      if (hasUV) {
        this._mesh.updateDuplicateGeometry();
        this._mesh.updateDuplicateColorsAndMaterials();
        this._mesh.updateDrawArrays();
      }
      this.updateBuffers();
    },
    initRender: function () {
      if (this._shaderName === 'MATCAP' && !this._texture0) this.setMatcap(this._matcap);
      this.setShaderName(this._shaderName);
      this.setShowWireframe(this.getShowWireframe());
    },
    ////////////////
    // RENDER
    ////////////////
    render: function (main) {
      Shader[this._shaderName].getOrCreate(this.getGL()).draw(this, main);
    },
    renderWireframe: function (main) {
      Shader.WIREFRAME.getOrCreate(this.getGL()).draw(this, main);
    },
    renderFlatColor: function (main) {
      Shader.FLAT.getOrCreate(this.getGL()).draw(this, main);
    },
    ////////////////
    // UPDATE BUFFERS
    ////////////////
    updateVertexBuffer: function () {
      this.getVertexBuffer().update(this._mesh.getRenderVertices());
    },
    updateNormalBuffer: function () {
      this.getNormalBuffer().update(this._mesh.getRenderNormals());
    },
    updateColorBuffer: function () {
      this.getColorBuffer().update(this._mesh.getRenderColors());
    },
    updateMaterialBuffer: function () {
      this.getMaterialBuffer().update(this._mesh.getRenderMaterials());
    },
    updateTexCoordBuffer: function () {
      if (this.isUsingTexCoords())
        this.getTexCoordBuffer().update(this._mesh.getRenderTexCoords());
    },
    updateIndexBuffer: function () {
      if (!this.isUsingDrawArrays())
        this.getIndexBuffer().update(this._mesh.getRenderTriangles());
    },
    updateWireframeBuffer: function () {
      if (this.getShowWireframe())
        this.getWireframeBuffer().update(this._mesh.getWireframe());
    },
    updateGeometryBuffers: function () {
      this.updateVertexBuffer();
      this.updateNormalBuffer();
    },
    updateBuffers: function () {
      this.updateGeometryBuffers();
      this.updateColorBuffer();
      this.updateMaterialBuffer();
      this.updateTexCoordBuffer();
      this.updateIndexBuffer();
      this.updateWireframeBuffer();
    },
    release: function () {
      if (this.getTexture0())
        this.getGL().deleteTexture(this.getTexture0());
      this.getVertexBuffer().release();
      this.getNormalBuffer().release();
      this.getColorBuffer().release();
      this.getMaterialBuffer().release();
      this.getIndexBuffer().release();
      this.getWireframeBuffer().release();
    },
    copyRenderConfig: function (mesh) {
      this.setFlatShading(mesh.getFlatShading());
      this.setShowWireframe(mesh.getShowWireframe());
      this.setShaderName(mesh.getShaderName());
      this.setMatcap(mesh.getMatcap());
      this.setTexture0(mesh.getTexture0());
      this.setCurvature(mesh.getCurvature());
      this.setOpacity(mesh.getOpacity());
    }
  };

  module.exports = Render;
});
define('mesh/Mesh',['require','exports','module','misc/Utils','mesh/meshData/MeshData','math3d/Octree','mesh/Render'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var MeshData = require('mesh/meshData/MeshData');
  var Octree = require('math3d/Octree');
  var Render = require('mesh/Render');

  var Mesh = function (gl) {
    this._meshData = new MeshData(this); // the mesh data
    this._octree = new Octree(this); // octree
    this._render = gl ? new Render(gl, this) : null; // octree
    this._id = Mesh.ID++; // useful id to retrieve a mesh (dynamic mesh, multires mesh, voxel mesh)
  };

  Mesh.ID = 0;
  Mesh.sortFunction = function (meshA, meshB) {
    // render transparent (back to front) after opaque (front to back) ones
    var aTr = meshA.isTransparent();
    var bTr = meshB.isTransparent();
    if (aTr && !bTr) return 1;
    if (!aTr && bTr) return -1;
    return (meshB.getDepth() - meshA.getDepth()) * (aTr && bTr ? 1.0 : -1.0);
  };

  Mesh.prototype = {
    getID: function () {
      return this._id;
    },
    setID: function (id) {
      this._id = id;
    },
    getMeshData: function () {
      return this._meshData;
    },
    getOctree: function () {
      return this._octree;
    },
    getRender: function () {
      return this._render;
    },
    setMeshData: function (data) {
      this._meshData = data;
    },
    setOctree: function (octree) {
      this._octree = octree;
    },
    setRender: function (render) {
      this._render = render;
    },
    getRenderVertices: function () {
      if (this.isUsingDrawArrays()) return this.getVerticesDrawArrays();
      return this.isUsingTexCoords() ? this.getVerticesTexCoord() : this.getVertices();
    },
    getRenderNormals: function () {
      if (this.isUsingDrawArrays()) return this.getNormalsDrawArrays();
      return this.isUsingTexCoords() ? this.getNormalsTexCoord() : this.getNormals();
    },
    getRenderColors: function () {
      if (this.isUsingDrawArrays()) return this.getColorsDrawArrays();
      return this.isUsingTexCoords() ? this.getColorsTexCoord() : this.getColors();
    },
    getRenderMaterials: function () {
      if (this.isUsingDrawArrays()) return this.getMaterialsDrawArrays();
      return this.isUsingTexCoords() ? this.getMaterialsTexCoord() : this.getMaterials();
    },
    getRenderTexCoords: function () {
      return this.isUsingDrawArrays() ? this.getTexCoordsDrawArrays() : this.getTexCoords();
    },
    getRenderTriangles: function () {
      return this.isUsingTexCoords() ? this.getTrianglesTexCoord() : this.getTriangles();
    },
    getRenderNbEdges: function () {
      return this.getNbEdges();
    },
    init: function () {
      this.initColorsAndMaterials();
      this.allocateArrays();
      this.initTopology();
      this.updateGeometry();
      if (this._render)
        this.updateDuplicateColorsAndMaterials();
      this.updateCenter();
    },
    initTopology: function () {
      this.initFaceRings();
      this.initEdges();
      this.initVertexRings();
      this.initRenderTriangles();
    },
    updateGeometry: function (iFaces, iVerts) {
      this.updateFacesAabbAndNormal(iFaces);
      this.updateVerticesNormal(iVerts);
      this.updateOctree(iFaces);
      if (this._render) {
        this.updateDuplicateGeometry(iVerts);
        this.updateDrawArrays(iFaces);
      }
    },
    allocateArrays: function () {
      this.getFaceData().allocateArrays();
      this.getVertexData().allocateArrays();
      this.getTexCoordsData().allocateArrays();
      this.getOctree().allocateArrays();
    }
  };

  // Basically... Mesh is a proxy/interface of all the stuffs below

  Utils.makeProxy(MeshData, Mesh, function (proto) {
    return function () {
      return proto.apply(this.getMeshData(), arguments);
    };
  });

  Utils.makeProxy(Render, Mesh, function (proto) {
    return function () {
      return proto.apply(this.getRender(), arguments);
    };
  });

  Utils.makeProxy(Octree, Mesh, function (proto) {
    return function () {
      return proto.apply(this.getOctree(), arguments);
    };
  });

  module.exports = Mesh;
});
define('editing/tools/Masking',['require','exports','module','lib/glMatrix','misc/Utils','editing/tools/SculptBase','editing/tools/Paint','editing/tools/Smooth','mesh/Mesh'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Utils = require('misc/Utils');
  var SculptBase = require('editing/tools/SculptBase');
  var Paint = require('editing/tools/Paint');
  var Smooth = require('editing/tools/Smooth');
  var Mesh = require('mesh/Mesh');

  var vec3 = glm.vec3;
  var mat3 = glm.mat3;

  var Masking = function (main) {
    SculptBase.call(this, main);
    this._radius = 50;
    this._hardness = 0.25;
    this._intensity = 1.0;
    this._negative = true;
    this._culling = false;
    this._idAlpha = 0;
    this._lockPosition = false;

    this._thickness = 1.0;
  };

  Masking.prototype = {
    pushState: function () {
      // too lazy to add a pushStateMaterial
      this._states.pushStateColorAndMaterial(this.getMesh());
    },
    updateMeshBuffers: function () {
      var mesh = this.getMesh();
      if (mesh.getDynamicTopology)
        mesh.updateBuffers();
      else
        mesh.updateMaterialBuffer();
    },
    stroke: function (picking) {
      Paint.prototype.stroke.call(this, picking);
    },
    /** Paint color vertices */
    paint: function (iVerts, center, radiusSquared, intensity, hardness, picking) {
      var mesh = this.getMesh();
      var vAr = mesh.getVertices();
      var mAr = mesh.getMaterials();
      var radius = Math.sqrt(radiusSquared);
      var cx = center[0];
      var cy = center[1];
      var cz = center[2];
      var softness = 2 * (1 - hardness);
      var maskIntensity = this._negative ? -intensity : intensity;
      for (var i = 0, l = iVerts.length; i < l; ++i) {
        var ind = iVerts[i] * 3;
        var vx = vAr[ind];
        var vy = vAr[ind + 1];
        var vz = vAr[ind + 2];
        var dx = vx - cx;
        var dy = vy - cy;
        var dz = vz - cz;
        var dist = Math.sqrt(dx * dx + dy * dy + dz * dz) / radius;
        var fallOff = Math.pow(1 - dist, softness);
        fallOff *= maskIntensity * picking.getAlpha(vx, vy, vz);
        mAr[ind + 2] = Math.min(Math.max(mAr[ind + 2] + fallOff, 0.0), 1.0);
      }
    },
    updateAndRenderMask: function () {
      var mesh = this.getMesh();
      mesh.updateDuplicateColorsAndMaterials();
      mesh.updateDrawArrays();
      this.updateRender();
    },
    blur: function () {
      var mesh = this.getMesh();
      var iVerts = this.getMaskedVertices();
      if (iVerts.length === 0)
        return;
      iVerts = mesh.expandsVertices(iVerts, 1);

      this.pushState();
      this._states.pushVertices(iVerts);

      var mAr = mesh.getMaterials();
      var nbVerts = iVerts.length;
      var smoothVerts = new Float32Array(nbVerts * 3);
      this.laplacianSmooth(iVerts, smoothVerts, mAr);
      for (var i = 0; i < nbVerts; ++i)
        mAr[iVerts[i] * 3 + 2] = smoothVerts[i * 3 + 2];
      this.updateAndRenderMask();
    },
    sharpen: function () {
      var mesh = this.getMesh();
      var iVerts = this.getMaskedVertices();
      if (iVerts.length === 0)
        return;

      this.pushState();
      this._states.pushVertices(iVerts);

      var mAr = mesh.getMaterials();
      var nbVerts = iVerts.length;
      for (var i = 0; i < nbVerts; ++i) {
        var idm = iVerts[i] * 3 + 2;
        var val = mAr[idm];
        mAr[idm] = val > 0.5 ? Math.min(val + 0.1, 1.0) : Math.max(val - 1.0, 0.0);
      }
      this.updateAndRenderMask();
    },
    clear: function () {
      var mesh = this.getMesh();
      var iVerts = this.getMaskedVertices();
      if (iVerts.length === 0)
        return;

      this.pushState();
      this._states.pushVertices(iVerts);

      var mAr = mesh.getMaterials();
      for (var i = 0, nb = iVerts.length; i < nb; ++i)
        mAr[iVerts[i] * 3 + 2] = 1.0;

      this.updateAndRenderMask();
    },
    invert: function (isState, meshState) {
      var mesh = meshState;
      if (!mesh) mesh = this.getMesh();
      if (!isState)
        this._states.pushStateCustom(this.invert.bind(this, true, mesh));

      var mAr = mesh.getMaterials();
      for (var i = 0, nb = mesh.getNbVertices(); i < nb; ++i)
        mAr[i * 3 + 2] = 1.0 - mAr[i * 3 + 2];

      this.updateAndRenderMask();
    },
    remapAndMirrorIndices: function (fAr, nbFaces, iVerts) {
      var nbVertices = this.getMesh().getNbVertices();
      var iTag = new Uint32Array(Utils.getMemory(nbVertices * 4), 0, nbVertices);
      var i = 0;
      var j = 0;
      var nbVerts = iVerts.length;
      for (i = 0; i < nbVerts; ++i)
        iTag[iVerts[i]] = i;

      var endFaces = nbFaces * 2;
      for (i = 0; i < endFaces; ++i) {
        j = i * 4;
        var offset = i < nbFaces ? 0 : nbVerts;
        fAr[j] = iTag[fAr[j]] + offset;
        fAr[j + 1] = iTag[fAr[j + 1]] + offset;
        fAr[j + 2] = iTag[fAr[j + 2]] + offset;
        var id4 = fAr[j + 3];
        if (id4 >= 0) fAr[j + 3] = iTag[id4] + offset;
      }
      var end = fAr.length / 4;
      for (i = endFaces; i < end; ++i) {
        j = i * 4;
        fAr[j] = iTag[fAr[j]];
        fAr[j + 1] = iTag[fAr[j + 1]];
        fAr[j + 2] = iTag[fAr[j + 2]] + nbVerts;
        fAr[j + 3] = iTag[fAr[j + 3]] + nbVerts;
      }
    },
    invertFaces: function (fAr) {
      for (var i = 0, nb = fAr.length; i < nb; ++i) {
        var id = i * 4;
        var temp = fAr[id];
        fAr[id] = fAr[id + 2];
        fAr[id + 2] = temp;
      }
    },
    extractFaces: function (iFaces, iVerts, maskClamp) {
      var mesh = this.getMesh();
      var fAr = mesh.getFaces();
      var mAr = mesh.getMaterials();
      var eAr = mesh.getVerticesOnEdge();

      var noThick = this._thickness === 0;

      var nbFaces = iFaces.length;
      var nbNewFaces = new Int32Array(Utils.getMemory(nbFaces * 4 * 4 * 3), 0, nbFaces * 4 * 3);
      var offsetFLink = noThick ? nbFaces : nbFaces * 2;
      for (var i = 0; i < nbFaces; ++i) {
        var idf = i * 4;
        var idOld = iFaces[i] * 4;
        var iv1 = nbNewFaces[idf] = fAr[idOld];
        var iv2 = nbNewFaces[idf + 1] = fAr[idOld + 1];
        var iv3 = nbNewFaces[idf + 2] = fAr[idOld + 2];
        var iv4 = nbNewFaces[idf + 3] = fAr[idOld + 3];
        if (noThick)
          continue;
        var isQuad = iv4 >= 0;

        var b1 = mAr[iv1 * 3 + 2] >= maskClamp || eAr[iv1] >= 1;
        var b2 = mAr[iv2 * 3 + 2] >= maskClamp || eAr[iv2] >= 1;
        var b3 = mAr[iv3 * 3 + 2] >= maskClamp || eAr[iv3] >= 1;
        var b4 = isQuad ? mAr[iv4 * 3 + 2] >= maskClamp || eAr[iv4] >= 1 : false;

        // create opposite face (layer), invert clockwise
        // quad =>
        // 1 2    3 2
        // 4 3    4 1
        // tri => 
        // 1 2    3 2
        //  3      1

        idf += nbFaces * 4;
        nbNewFaces[idf] = iv3;
        nbNewFaces[idf + 1] = iv2;
        nbNewFaces[idf + 2] = iv1;
        nbNewFaces[idf + 3] = iv4;

        // create bridges faces
        if (b2) {
          if (b1) {
            idf = 4 * (offsetFLink++);
            nbNewFaces[idf] = nbNewFaces[idf + 3] = iv2;
            nbNewFaces[idf + 1] = nbNewFaces[idf + 2] = iv1;
          }
          if (b3) {
            idf = 4 * (offsetFLink++);
            nbNewFaces[idf] = nbNewFaces[idf + 3] = iv3;
            nbNewFaces[idf + 1] = nbNewFaces[idf + 2] = iv2;
          }
        }
        if (isQuad) {
          if (b4) {
            if (b1) {
              idf = 4 * (offsetFLink++);
              nbNewFaces[idf] = nbNewFaces[idf + 3] = iv1;
              nbNewFaces[idf + 1] = nbNewFaces[idf + 2] = iv4;
            }
            if (b3) {
              idf = 4 * (offsetFLink++);
              nbNewFaces[idf] = nbNewFaces[idf + 3] = iv4;
              nbNewFaces[idf + 1] = nbNewFaces[idf + 2] = iv3;
            }
          }
        } else {
          if (b1 && b3) {
            idf = 4 * (offsetFLink++);
            nbNewFaces[idf] = nbNewFaces[idf + 3] = iv1;
            nbNewFaces[idf + 1] = nbNewFaces[idf + 2] = iv3;
          }
        }
      }

      var fArNew = new Int32Array(nbNewFaces.subarray(0, offsetFLink * 4));
      this.remapAndMirrorIndices(fArNew, nbFaces, iVerts);
      if (this._thickness > 0)
        this.invertFaces(fArNew);
      return fArNew;
    },
    extractVertices: function (iVerts) {
      var mesh = this.getMesh();

      var vAr = mesh.getVertices();
      var nAr = mesh.getNormals();
      var mat = mesh.getMatrix();
      var nMat = mat3.normalFromMat4(mat3.create(), mat);
      var nbVerts = iVerts.length;
      var vArNew = new Float32Array(nbVerts * 2 * 3);
      var vTemp = [0.0, 0.0, 0.0];
      var nTemp = [0.0, 0.0, 0.0];
      var vOffset = nbVerts * 3;
      var thick = this._thickness;
      var eps = 0.01;
      if (thick < 0) eps = -eps;
      for (var i = 0; i < nbVerts; ++i) {
        var idv = i * 3;
        var idvOld = iVerts[i] * 3;
        vTemp[0] = vAr[idvOld];
        vTemp[1] = vAr[idvOld + 1];
        vTemp[2] = vAr[idvOld + 2];
        nTemp[0] = nAr[idvOld];
        nTemp[1] = nAr[idvOld + 1];
        nTemp[2] = nAr[idvOld + 2];
        vec3.transformMat3(nTemp, nTemp, nMat);
        vec3.normalize(nTemp, nTemp);

        vec3.transformMat4(vTemp, vTemp, mat);
        vec3.scaleAndAdd(vTemp, vTemp, nTemp, eps);
        vArNew[idv] = vTemp[0];
        vArNew[idv + 1] = vTemp[1];
        vArNew[idv + 2] = vTemp[2];

        vec3.scaleAndAdd(vTemp, vTemp, nTemp, thick);
        idv += vOffset;
        vArNew[idv] = vTemp[0];
        vArNew[idv + 1] = vTemp[1];
        vArNew[idv + 2] = vTemp[2];
      }
      return vArNew;
    },
    smoothBorder: function (mesh, iFaces) {
      var startBridge = iFaces.length * 2;
      var fBridge = new Uint32Array(mesh.getNbFaces() - startBridge);
      for (var i = 0, nbBridge = fBridge.length; i < nbBridge; ++i)
        fBridge[i] = startBridge + i;
      var vBridge = mesh.expandsVertices(mesh.getVerticesFromFaces(fBridge), 1);
      var smo = new Smooth();
      smo.setToolMesh(mesh);
      smo.smooth(vBridge, 1.0);
      smo.smooth(vBridge, 1.0);
      smo.smooth(vBridge, 1.0);
    },
    extract: function () {
      var mesh = this.getMesh();
      var maskClamp = 0.5;

      var iVerts = this.filterMaskedVertices(-Infinity, maskClamp);
      if (iVerts.length === 0)
        return;
      var iFaces = mesh.getFacesFromVertices(iVerts);
      iVerts = mesh.getVerticesFromFaces(iFaces);

      var fArNew = this.extractFaces(iFaces, iVerts, maskClamp);
      var vArNew = this.extractVertices(iVerts);

      var newMesh = new Mesh(mesh.getGL());
      newMesh.setVertices(vArNew);
      newMesh.setFaces(fArNew);

      // we don't use newMesh.init because we want to smooth
      // the border (we want to avoid an update octree/normal/etc...)
      newMesh.initColorsAndMaterials();
      newMesh.allocateArrays();
      newMesh.initTopology();
      if (this._thickness !== 0.0)
        this.smoothBorder(newMesh, iFaces);
      newMesh.updateGeometry();
      newMesh.updateDuplicateColorsAndMaterials();

      newMesh.copyRenderConfig(mesh);
      newMesh.initRender();

      var main = this._main;
      main.addNewMesh(newMesh);
      main.setMesh(mesh);
    }
  };

  Utils.makeProxy(SculptBase, Masking);

  module.exports = Masking;
});
define('editing/tools/LocalScale',['require','exports','module','misc/Utils','editing/tools/SculptBase'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var SculptBase = require('editing/tools/SculptBase');

  var LocalScale = function (main) {
    SculptBase.call(this, main);
    this._radius = 50;
    this._culling = false;
    this._idAlpha = 0;
  };

  LocalScale.prototype = {
    /** Start a sculpt sculpt stroke */
    startSculpt: function () {
      var main = this._main;
      if (main.getSculpt().getSymmetry()) {
        var pickingSym = main.getPickingSymmetry();
        pickingSym.intersectionMouseMesh();
        pickingSym.setLocalRadius2(main.getPicking().getLocalRadius2());
      }
    },
    /** Make a brush scale stroke */
    sculptStroke: function () {
      var main = this._main;
      var delta = main._mouseX - main._lastMouseX;
      var picking = main.getPicking();
      var rLocal2 = picking.getLocalRadius2();
      picking.pickVerticesInSphere(rLocal2);
      this.stroke(picking, delta);

      if (main.getSculpt().getSymmetry()) {
        var pickingSym = main.getPickingSymmetry();
        if (pickingSym.getMesh()) {
          pickingSym.pickVerticesInSphere(rLocal2);
          this.stroke(pickingSym, delta);
        }
      }
      this.updateRender();
    },
    /** On stroke */
    stroke: function (picking, delta) {
      var iVertsInRadius = picking.getPickedVertices();

      // undo-redo
      this._states.pushVertices(iVertsInRadius);
      iVertsInRadius = this.dynamicTopology(picking);

      if (this._culling)
        iVertsInRadius = this.getFrontVertices(iVertsInRadius, picking.getEyeDirection());

      picking.updateAlpha(false);
      picking.setIdAlpha(this._idAlpha);
      this.scale(iVertsInRadius, picking.getIntersectionPoint(), picking.getLocalRadius2(), delta, picking);

      var mesh = this.getMesh();
      mesh.updateGeometry(mesh.getFacesFromVertices(iVertsInRadius), iVertsInRadius);
    },
    /** Scale the vertices around the mouse point intersection */
    scale: function (iVerts, center, radiusSquared, intensity, picking) {
      var mesh = this.getMesh();
      var vAr = mesh.getVertices();
      var mAr = mesh.getMaterials();
      var deltaScale = intensity * 0.01;
      var radius = Math.sqrt(radiusSquared);
      var cx = center[0];
      var cy = center[1];
      var cz = center[2];
      for (var i = 0, l = iVerts.length; i < l; ++i) {
        var ind = iVerts[i] * 3;
        var vx = vAr[ind];
        var vy = vAr[ind + 1];
        var vz = vAr[ind + 2];
        var dx = vx - cx;
        var dy = vy - cy;
        var dz = vz - cz;
        var dist = Math.sqrt(dx * dx + dy * dy + dz * dz) / radius;
        var fallOff = dist * dist;
        fallOff = 3.0 * fallOff * fallOff - 4.0 * fallOff * dist + 1.0;
        fallOff *= deltaScale * mAr[ind + 2] * picking.getAlpha(vx, vy, vz);
        vAr[ind] = vx + dx * fallOff;
        vAr[ind + 1] = vy + dy * fallOff;
        vAr[ind + 2] = vz + dz * fallOff;
      }
    }
  };

  Utils.makeProxy(SculptBase, LocalScale);

  module.exports = LocalScale;
});
define('editing/HoleFilling',['require','exports','module','mesh/Mesh'],function (require, exports, module) {

  'use strict';

  var Mesh = require('mesh/Mesh');

  var Edge = function (v1, v2) {
    this.previous = null;
    this.next = null;
    this.v1 = v1;
    this.v2 = v2;
  };

  var detectHole = function (borderEdges) {
    if (borderEdges.length <= 2)
      return;
    var nbEdges = borderEdges.length;
    var iEnd = borderEdges[0].v1;
    var iLast = borderEdges[0].v2;
    var first = borderEdges[0];
    var last = first;

    borderEdges[0] = borderEdges[--nbEdges];
    var i = 0;
    while (i < nbEdges) {
      var testEdge = borderEdges[i];
      if (testEdge.v1 === iLast) {
        testEdge.previous = last;
        last.next = last = testEdge;
        iLast = borderEdges[i].v2;
        borderEdges[i] = borderEdges[--nbEdges];
        if (iLast === iEnd)
          break;
        i = 0;
      } else
        i++;
    }
    borderEdges.length = nbEdges;
    if (iLast !== iEnd)
      return;
    first.previous = last;
    last.next = first;
    return first;
  };

  var detectHoles = function (mesh) {
    var eAr = mesh.getEdges();
    var fAr = mesh.getFaces();
    var feAr = mesh.getFaceEdges();
    var borderEdges = [];
    for (var i = 0, len = mesh.getNbFaces(); i < len; ++i) {
      var id = i * 4;
      var iv4 = feAr[id + 3];
      if (eAr[feAr[id]] === 1) borderEdges.push(new Edge(fAr[id], fAr[id + 1]));
      if (eAr[feAr[id + 1]] === 1) borderEdges.push(new Edge(fAr[id + 1], fAr[id + 2]));
      if (eAr[feAr[id + 2]] === 1) borderEdges.push(new Edge(fAr[id + 2], fAr[iv4 < 0 ? id : id + 3]));
      if (iv4 >= 0 && eAr[iv4] === 1) borderEdges.push(new Edge(fAr[id + 3], fAr[id]));
    }

    var holes = [];
    while (true) {
      var firstEdge = detectHole(borderEdges);
      if (!firstEdge) break;
      holes.push(firstEdge);
    }
    return holes;
  };

  var advancingFrontMesh = function (mesh, firstEdge, newTris, newVerts, newColors, newMaterials) {
    var vAr = mesh.getVertices();
    var cAr = mesh.getColors();
    var mAr = mesh.getMaterials();
    // var current = firstEdge;
    // var count = 1;
    // while (current.next !== firstEdge) {
    //   current = current.next;
    //   count++;
    // }
    // console.log(count)

    // TODO : stupid naive hole filling for now
    var last = mesh.getNbVertices() + newVerts.length / 3;
    var current = firstEdge;
    var avx = 0.0;
    var avy = 0.0;
    var avz = 0.0;

    var colr = 0.0;
    var colg = 0.0;
    var colb = 0.0;

    var mat1 = 0.0;
    var mat2 = 0.0;
    var mat3 = 0.0;
    var count = 0;
    do {
      var next = current.next;
      var iv1 = current.v1;
      var iv2 = current.v2;
      var iv3 = next.v2;

      newTris.push(iv1, iv2, last, -1);
      iv1 *= 3;
      iv2 *= 3;
      iv3 *= 3;
      count++;
      avx += vAr[iv1];
      avy += vAr[iv1 + 1];
      avz += vAr[iv1 + 2];

      colr += cAr[iv1];
      colg += cAr[iv1 + 1];
      colb += cAr[iv1 + 2];

      mat1 += mAr[iv1];
      mat2 += mAr[iv1 + 1];
      mat3 += mAr[iv1 + 2];

      var v2x = vAr[iv2];
      var v2y = vAr[iv2 + 1];
      var v2z = vAr[iv2 + 2];
      // compute normals
      var ax = vAr[iv1] - v2x;
      var ay = vAr[iv1 + 1] - v2y;
      var az = vAr[iv1 + 2] - v2z;
      var bx = vAr[iv3] - v2x;
      var by = vAr[iv3 + 1] - v2y;
      var bz = vAr[iv3 + 2] - v2z;
      var alen = ax * ax + ay * ay + az * az;
      var blen = bx * bx + by * by + bz * bz;
      current.angle = Math.acos((ax * bx + ay * by + az * bz) / Math.sqrt(alen * blen));
      current = next;
    } while (current !== firstEdge);

    newVerts.push(avx / count, avy / count, avz / count);
    newColors.push(colr / count, colg / count, colb / count);
    newMaterials.push(mat1 / count, mat2 / count, mat3 / count);
  };

  var HoleFilling = {};

  HoleFilling.createMesh = function (mesh, vertices, faces, colors, materials) {
    var newMesh = new Mesh();
    newMesh.setID(mesh.getID());
    newMesh.setVertices(vertices);
    if (colors) newMesh.setColors(colors);
    if (materials) newMesh.setMaterials(materials);
    newMesh.setFaces(faces);

    // small hack
    newMesh.setTransformData(mesh.getTransformData());
    newMesh.setRender(mesh.getRender());

    newMesh.init();
    return newMesh;
  };

  HoleFilling.closeHoles = function (mesh) {
    var holes = detectHoles(mesh);
    if (holes.length === 0)
      return mesh;

    var newFaces = [];
    var newVerts = [];
    var newColors = [];
    var newMaterials = [];
    // console.time('closeHoles');
    for (var i = 0, nbHoles = holes.length; i < nbHoles; ++i)
      advancingFrontMesh(mesh, holes[i], newFaces, newVerts, newColors, newMaterials);
    // console.timeEnd('closeHoles');

    var oldVertsLen = mesh.getNbVertices() * 3;
    var newVertsLen = oldVertsLen + newVerts.length;

    // set vertices
    var vertices = new Float32Array(newVertsLen);
    vertices.set(mesh.getVertices());
    // set colors
    var colors = new Float32Array(newVertsLen);
    colors.set(mesh.getColors());
    // set materials
    var materials = new Float32Array(newVertsLen);
    materials.set(mesh.getMaterials());

    if (newVertsLen > oldVertsLen) {
      vertices.set(newVerts, oldVertsLen);
      colors.set(newColors, oldVertsLen);
      materials.set(newMaterials, oldVertsLen);
    }

    // set faces
    var faces = new Int32Array(mesh.getNbFaces() * 4 + newFaces.length);
    faces.set(mesh.getFaces());
    if (newFaces.length > 0)
      faces.set(newFaces, mesh.getNbFaces() * 4);

    return HoleFilling.createMesh(mesh, vertices, faces, colors, materials);
  };

  HoleFilling.createClosedMesh = function (mesh) {
    var closed = HoleFilling.closeHoles(mesh);
    if (closed === mesh)
      closed = HoleFilling.createMesh(mesh, mesh.getVertices().slice(), mesh.getFaces().slice(), mesh.getColors().slice(), mesh.getMaterials().slice());
    return closed;
  };

  module.exports = HoleFilling;
});
define('editing/SurfaceNets',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var SurfaceNets = {};
  SurfaceNets.BLOCK = false;

  /**
   * Based on Mikola Lysenko SurfaceNets
   * https://github.com/mikolalysenko/isosurface
   *
   * Based on: S.F. Gibson, "Constrained Elastic Surface Nets". (1998) MERL Tech Report.
   */

  // This is just the vertex number of each cube
  var computeCubeEdges = function () {
    var cubeEdges = new Int32Array(24);
    var k = 0;
    for (var i = 0; i < 8; ++i) {
      for (var j = 1; j <= 4; j <<= 1) {
        var p = i ^ j;
        if (i <= p) {
          cubeEdges[k++] = i;
          cubeEdges[k++] = p;
        }
      }
    }
    return cubeEdges;
  };

  var computeEdgeTable = function (cubeEdges) {
    //Initialize the intersection table.
    //  This is a 2^(cube configuration) ->  2^(edge configuration) map
    //  There is one entry for each possible cube configuration, and the output is a 12-bit vector enumerating all edges crossing the 0-level.
    var edgeTable = new Int32Array(256);
    for (var i = 0; i < 256; ++i) {
      var em = 0;
      for (var j = 0; j < 24; j += 2) {
        var a = !!(i & (1 << cubeEdges[j]));
        var b = !!(i & (1 << cubeEdges[j + 1]));
        em |= a !== b ? (1 << (j >> 1)) : 0;
      }
      edgeTable[i] = em;
    }
    return edgeTable;
  };

  //Precompute edge table, like Paul Bourke does.
  var cubeEdges = computeCubeEdges();
  var edgeTable = computeEdgeTable(cubeEdges);

  var readScalarValues = function (data, grid, dims, n, colors, materials, cols, mats) {
    //Read in 8 field values around this vertex and store them in an array
    //Also calculate 8-bit mask, like in marching cubes, so we can speed up sign checks later
    var c1 = 0;
    var c2 = 0;
    var c3 = 0;
    var m1 = 0;
    var m2 = 0;
    var m3 = 0;
    var invSum = 0;

    var mask = 0;
    var g = 0;
    var rx = dims[0];
    var rxy = dims[0] * dims[1];
    for (var k = 0; k < 2; ++k) {
      for (var j = 0; j < 2; ++j) {
        for (var i = 0; i < 2; ++i) {
          var id = n + i + j * rx + k * rxy;
          var id3 = id * 3;
          var p = data[id];
          grid[g] = p;
          mask |= (p < 0.0) ? (1 << g) : 0;
          g++;
          if (p !== Infinity) {
            p = Math.min(1 / Math.abs(p), 1e15);
            invSum += p;
            c1 += colors[id3] * p;
            c2 += colors[id3 + 1] * p;
            c3 += colors[id3 + 2] * p;
            m1 += materials[id3] * p;
            m2 += materials[id3 + 1] * p;
            m3 += materials[id3 + 2] * p;
          }
        }
      }
    }
    if (invSum > 0 && mask !== 0 && mask !== 0xff) {
      invSum = 1 / invSum;
      cols.push(c1 * invSum, c2 * invSum, c3 * invSum);
      mats.push(m1 * invSum, m2 * invSum, m3 * invSum);
    }
    return mask;
  };

  var vTemp = [0.0, 0.0, 0.0];
  var interpolateVertices = function (edgeMask, cubeEdges, grid, x, scale, shift, vertices) {
    vTemp[0] = vTemp[1] = vTemp[2] = 0.0;
    var edgeCount = 0;
    //For every edge of the cube...
    for (var i = 0; i < 12; ++i) {
      //Use edge mask to check if it is crossed
      if (!(edgeMask & (1 << i)))
        continue;
      ++edgeCount; //If it did, increment number of edge crossings
      if (SurfaceNets.BLOCK)
        continue;
      //Now find the point of intersection
      var e0 = cubeEdges[i << 1]; //Unpack vertices
      var e1 = cubeEdges[(i << 1) + 1];
      var g0 = grid[e0]; //Unpack grid values
      var t = g0 - grid[e1]; //Compute point of intersection
      if (Math.abs(t) < 1e-7)
        continue;
      t = g0 / t;

      //Interpolate vertices and add up intersections (this can be done without multiplying)
      for (var j = 0, k = 1; j < 3; ++j, k <<= 1) {
        var a = e0 & k;
        if (a !== (e1 & k))
          vTemp[j] += a ? 1.0 - t : t;
        else
          vTemp[j] += a ? 1.0 : 0.0;
      }
    }
    //Now we just average the edge intersections and add them to coordinate
    var s = 1.0 / edgeCount;
    for (var l = 0; l < 3; ++l)
      vTemp[l] = scale[l] * (x[l] + s * vTemp[l]) + shift[l];
    vertices.push(vTemp[0], vTemp[1], vTemp[2]);
  };

  var createFace = function (edgeMask, mask, buffer, R, m, x, faces) {
    //Now we need to add faces together, to do this we just loop over 3 basis components
    for (var i = 0; i < 3; ++i) {
      //The first three entries of the edgeMask count the crossings along the edge
      if (!(edgeMask & (1 << i)))
        continue;

      // i = axes we are point along.  iu, iv = orthogonal axes
      var iu = (i + 1) % 3;
      var iv = (i + 2) % 3;

      //If we are on a boundary, skip it
      if (x[iu] === 0 || x[iv] === 0)
        continue;

      //Otherwise, look up adjacent edges in buffer
      var du = R[iu];
      var dv = R[iv];

      //Remember to flip orientation depending on the sign of the corner.
      if (mask & 1)
        faces.push(buffer[m], buffer[m - du], buffer[m - du - dv], buffer[m - dv]);
      else
        faces.push(buffer[m], buffer[m - dv], buffer[m - du - dv], buffer[m - du]);
    }
  };

  SurfaceNets.computeSurface = function (voxels, bounds) {
    var dims = voxels.dims;
    var colors = voxels.colors;
    var materials = voxels.materials;
    var data = voxels.distanceField;
    if (!bounds) {
      bounds = [
        [0.0, 0.0, 0.0], dims
      ];
    }

    var scale = [0.0, 0.0, 0.0];
    var shift = [0.0, 0.0, 0.0];
    for (var i = 0; i < 3; ++i) {
      scale[i] = (bounds[1][i] - bounds[0][i]) / dims[i];
      shift[i] = bounds[0][i];
    }

    var vertices = [];
    var cols = [];
    var mats = [];
    var faces = [];
    var n = 0;
    var x = new Int32Array(3);
    var R = new Int32Array([1, (dims[0] + 1), (dims[0] + 1) * (dims[1] + 1)]);
    var grid = new Float32Array(8);
    var nbBuf = 1;
    var buffer = new Int32Array(R[2] * 2);

    //March over the voxel grid
    for (x[2] = 0; x[2] < dims[2] - 1; ++x[2], n += dims[0], nbBuf ^= 1, R[2] = -R[2]) {

      //m is the pointer into the buffer we are going to use.  
      //This is slightly obtuse because javascript does not have good support for packed data structures, so we must use typed arrays :(
      //The contents of the buffer will be the indices of the vertices on the previous x/y slice of the volume
      var m = 1 + (dims[0] + 1) * (1 + nbBuf * (dims[1] + 1));

      for (x[1] = 0; x[1] < dims[1] - 1; ++x[1], ++n, m += 2) {
        for (x[0] = 0; x[0] < dims[0] - 1; ++x[0], ++n, ++m) {

          var mask = readScalarValues(data, grid, dims, n, colors, materials, cols, mats);
          //Check for early termination if cell does not intersect boundary
          if (mask === 0 || mask === 0xff)
            continue;
          //Sum up edge intersections
          var edgeMask = edgeTable[mask];
          buffer[m] = vertices.length / 3;
          interpolateVertices(edgeMask, cubeEdges, grid, x, scale, shift, vertices);
          createFace(edgeMask, mask, buffer, R, m, x, faces);
        }
      }
    }

    //All done!  Return the result
    return {
      colors: new Float32Array(cols),
      materials: new Float32Array(mats),
      vertices: new Float32Array(vertices),
      faces: new Int32Array(faces)
    };
  };

  module.exports = SurfaceNets;
});
define('editing/Remesh',['require','exports','module','lib/glMatrix','editing/HoleFilling','editing/SurfaceNets','math3d/Geometry','mesh/Mesh','misc/Utils'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var HoleFilling = require('editing/HoleFilling');
  var SurfaceNets = require('editing/SurfaceNets');
  var Geometry = require('math3d/Geometry');
  var Mesh = require('mesh/Mesh');
  var Utils = require('misc/Utils');

  var vec3 = glm.vec3;

  var Remesh = {};
  Remesh.RESOLUTION = 150;
  Remesh.BLOCK = false;

  var floodFill = function (voxels, step) {
    var res = voxels.dims;
    var rx = res[0];
    var ry = res[1];
    var rxy = rx * ry;

    var crossedEdges = voxels.crossedEdges;
    var distField = voxels.distanceField;
    var datalen = distField.length;
    var tagCell = new Uint8Array(datalen); // 0 interior, 1 exterior
    var stack = new Int32Array(datalen);

    stack[0] = 0;
    var curStack = 1;

    var dirs = [-1, 1, -rx, rx, -rxy, rxy];
    var dirsEdge = [0, 0, 1, 1, 2, 2];
    var nbDir = dirs.length;
    var i = 0;
    var idNext = 0;

    while (curStack > 0) {
      var cell = stack[--curStack];
      var cellDist = distField[cell];
      if (cellDist < step) // border hit
      {
        for (i = 0; i < nbDir; ++i) {
          var off = dirs[i];
          idNext = cell + off;
          if (idNext >= datalen || idNext < 0) continue; // range check
          if (tagCell[idNext] === 1) continue; // check if already tagged as exterior
          if (distField[idNext] === Infinity) continue; // check if we are in the far exterior zone
          if (crossedEdges[(off >= 0 ? cell : idNext) * 3 + dirsEdge[i]] === 0) {
            tagCell[idNext] = 1;
            stack[curStack++] = idNext;
          }
        }
      } else { // exterior
        for (i = 0; i < nbDir; ++i) {
          idNext = cell + dirs[i];
          if (idNext >= datalen || idNext < 0) continue; // range check
          if (tagCell[idNext] === 1) continue; // check if already tagged as exterior
          tagCell[idNext] = 1;
          stack[curStack++] = idNext;
        }
      }
    }
    for (var id = 0; id < datalen; ++id) {
      if (tagCell[id] === 0)
        distField[id] = -distField[id];
    }
  };

  var voxelize = function (mesh, voxels, dims, step) {
    var invStep = 1.0 / step;

    var vminx = dims[0][0];
    var vminy = dims[1][0];
    var vminz = dims[2][0];

    var rx = voxels.dims[0];
    var ry = voxels.dims[1];
    var distField = voxels.distanceField;
    var crossedEdges = voxels.crossedEdges;
    var colors = voxels.colors;
    var materials = voxels.materials;

    var iAr = mesh.getTriangles();
    var vAr = mesh.getVertices();
    var cAr = mesh.getColors();
    var mAr = mesh.getMaterials();
    var nbTriangles = mesh.getNbTriangles();

    var v1 = [0.0, 0.0, 0.0];
    var v2 = [0.0, 0.0, 0.0];
    var v3 = [0.0, 0.0, 0.0];
    var triEdge1 = [0.0, 0.0, 0.0];
    var triEdge2 = [0.0, 0.0, 0.0];
    var point = [0.0, 0.0, 0.0];
    var closest = [0.0, 0.0, 0.0, 0];
    var rxy = rx * ry;
    var dirUnit = [
      [1.0, 0.0, 0.0],
      [0.0, 1.0, 0.0],
      [0.0, 0.0, 1.0]
    ];

    var inv3 = 1 / 3;
    for (var iTri = 0; iTri < nbTriangles; ++iTri) {
      var idTri = iTri * 3;

      var iv1 = iAr[idTri] * 3;
      var iv2 = iAr[idTri + 1] * 3;
      var iv3 = iAr[idTri + 2] * 3;

      var v1x = v1[0] = vAr[iv1];
      var v1y = v1[1] = vAr[iv1 + 1];
      var v1z = v1[2] = vAr[iv1 + 2];
      var v2x = v2[0] = vAr[iv2];
      var v2y = v2[1] = vAr[iv2 + 1];
      var v2z = v2[2] = vAr[iv2 + 2];
      var v3x = v3[0] = vAr[iv3];
      var v3y = v3[1] = vAr[iv3 + 1];
      var v3z = v3[2] = vAr[iv3 + 2];

      var c1x = (cAr[iv1] + cAr[iv2] + cAr[iv3]) * inv3;
      var c1y = (cAr[iv1 + 1] + cAr[iv2 + 1] + cAr[iv3 + 1]) * inv3;
      var c1z = (cAr[iv1 + 2] + cAr[iv2 + 2] + cAr[iv3 + 2]) * inv3;
      var m1x = (mAr[iv1] + mAr[iv2] + mAr[iv3]) * inv3;
      var m1y = (mAr[iv1 + 1] + mAr[iv2 + 1] + mAr[iv3 + 1]) * inv3;
      var m1z = (mAr[iv1 + 2] + mAr[iv2 + 2] + mAr[iv3 + 2]) * inv3;

      // bounding box recomputation (we already have the bbox of the quad but
      // not of the triangles...)
      var xmin = v1x < v2x ? v1x < v3x ? v1x : v3x : v2x < v3x ? v2x : v3x;
      var xmax = v1x > v2x ? v1x > v3x ? v1x : v3x : v2x > v3x ? v2x : v3x;
      var ymin = v1y < v2y ? v1y < v3y ? v1y : v3y : v2y < v3y ? v2y : v3y;
      var ymax = v1y > v2y ? v1y > v3y ? v1y : v3y : v2y > v3y ? v2y : v3y;
      var zmin = v1z < v2z ? v1z < v3z ? v1z : v3z : v2z < v3z ? v2z : v3z;
      var zmax = v1z > v2z ? v1z > v3z ? v1z : v3z : v2z > v3z ? v2z : v3z;

      // cache what can be cached for faster ray-tri and point-tri tests
      // basically edge stuffs
      var e1x = triEdge1[0] = v2x - v1x;
      var e1y = triEdge1[1] = v2y - v1y;
      var e1z = triEdge1[2] = v2z - v1z;
      var e2x = triEdge2[0] = v3x - v1x;
      var e2y = triEdge2[1] = v3y - v1y;
      var e2z = triEdge2[2] = v3z - v1z;
      var a00 = e1x * e1x + e1y * e1y + e1z * e1z;
      var a01 = e1x * e2x + e1y * e2y + e1z * e2z;
      var a11 = e2x * e2x + e2y * e2y + e2z * e2z;

      var snapMinx = Math.floor((xmin - vminx) * invStep);
      var snapMiny = Math.floor((ymin - vminy) * invStep);
      var snapMinz = Math.floor((zmin - vminz) * invStep);

      var snapMaxx = Math.ceil((xmax - vminx) * invStep);
      var snapMaxy = Math.ceil((ymax - vminy) * invStep);
      var snapMaxz = Math.ceil((zmax - vminz) * invStep);

      for (var k = snapMinz; k <= snapMaxz; ++k) {
        for (var j = snapMiny; j <= snapMaxy; ++j) {
          for (var i = snapMinx; i <= snapMaxx; ++i) {
            var x = vminx + i * step;
            var y = vminy + j * step;
            var z = vminz + k * step;
            var n = i + j * rx + k * rxy;

            point[0] = x;
            point[1] = y;
            point[2] = z;
            var newDist = Geometry.distance2PointTriangleEdges(point, triEdge1, triEdge2, v1, a00, a01, a11, closest);
            newDist = Math.sqrt(newDist);
            if (newDist < distField[n]) {
              distField[n] = newDist;
              var n3 = n * 3;
              colors[n3] = c1x;
              colors[n3 + 1] = c1y;
              colors[n3 + 2] = c1z;
              materials[n3] = m1x;
              materials[n3 + 1] = m1y;
              materials[n3 + 2] = m1z;
            }
            if (newDist > step)
              continue;

            for (var it = 0; it < 3; ++it) {
              var val = closest[it] - point[it];
              if (val < 0.0 || val > step) continue;
              var idEdge = n * 3 + it;
              if (crossedEdges[idEdge] === 1) continue;
              var dist = Geometry.intersectionRayTriangleEdges(point, dirUnit[it], triEdge1, triEdge2, v1);
              if (dist < 0.0 || dist > step) continue;
              crossedEdges[idEdge] = 1;
            }

          }
        }
      }
    }
  };

  // grid structure
  var createVoxelData = function (dims, step) {
    var rx = 1 + Math.ceil((dims[0][1] - dims[0][0]) / step);
    var ry = 1 + Math.ceil((dims[1][1] - dims[1][0]) / step);
    var rz = 1 + Math.ceil((dims[2][1] - dims[2][0]) / step);
    var datalen = rx * ry * rz;
    var buffer = Utils.getMemory((4 * (1 + 3 + 3) + 3) * datalen);
    var distField = new Float32Array(buffer, 0, datalen);
    var colors = new Float32Array(buffer, 4 * datalen, datalen * 3);
    var materials = new Float32Array(buffer, 16 * datalen, datalen * 3);
    var crossedEdges = new Uint8Array(buffer, 28 * datalen, datalen * 3);
    // Initialize data
    for (var idf = 0; idf < datalen; ++idf)
      distField[idf] = Infinity;
    for (var ide = 0, datalene = datalen * 3; ide < datalene; ++ide)
      crossedEdges[ide] = 0;
    for (var idc = 0, datalenc = datalen * 3; idc < datalenc; ++idc)
      colors[idc] = materials[idc] = -1;
    var voxels = {};
    voxels.dims = [rx, ry, rz];
    voxels.crossedEdges = crossedEdges;
    voxels.distanceField = distField;
    voxels.colors = colors;
    voxels.materials = materials;
    return voxels;
  };

  var createMesh = function (mesh, vertices, faces, colors, materials) {
    var newMesh = new Mesh(mesh.getGL());
    newMesh.setID(mesh.getID());
    newMesh.setVertices(vertices);
    if (colors) newMesh.setColors(colors);
    if (materials) newMesh.setMaterials(materials);
    newMesh.setFaces(faces);
    newMesh.init();
    newMesh.setRender(mesh.getRender());
    mesh.getRender()._mesh = newMesh;
    newMesh.initRender();
    return newMesh;
  };

  // hole filling + transform to world + ComputeBox
  var prepareMeshes = function (meshes) {
    var box = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity];
    var tmp = [0.0, 0.0, 0.0];
    for (var i = 0, nbm = meshes.length; i < nbm; ++i) {
      var mesh = meshes[i];
      if (mesh.isUsingTexCoords())
        mesh.setShaderName('MATCAP');
      var matrix = mesh.getMatrix();

      mesh = meshes[i] = HoleFilling.createClosedMesh(mesh);
      var vAr = mesh.getVertices();
      for (var j = 0, nbv = mesh.getNbVertices(); j < nbv; ++j) {
        var id = j * 3;
        tmp[0] = vAr[id];
        tmp[1] = vAr[id + 1];
        tmp[2] = vAr[id + 2];
        vec3.transformMat4(tmp, tmp, matrix);
        var x = vAr[id] = tmp[0];
        var y = vAr[id + 1] = tmp[1];
        var z = vAr[id + 2] = tmp[2];
        if (x < box[0]) box[0] = x;
        if (y < box[1]) box[1] = y;
        if (z < box[2]) box[2] = z;
        if (x > box[3]) box[3] = x;
        if (y > box[4]) box[4] = y;
        if (z > box[5]) box[5] = z;
      }
    }
    return box;
  };

  Remesh.remesh = function (meshes, baseMesh) {
    console.time('remesh total');

    console.time('1. initMeshes');

    meshes = meshes.slice();
    var box = prepareMeshes(meshes);
    console.timeEnd('1. initMeshes');

    console.time('2. voxelization');
    var step = Math.max((box[3] - box[0]), (box[4] - box[1]), (box[5] - box[2])) / Remesh.RESOLUTION;
    var stepMin = step * 2.5;
    var stepMax = step * 1.5;
    var dims = [
      [box[0] - stepMin, box[3] + stepMax],
      [box[1] - stepMin, box[4] + stepMax],
      [box[2] - stepMin, box[5] + stepMax]
    ];
    var voxels = createVoxelData(dims, step);
    for (var i = 0, l = meshes.length; i < l; ++i)
      voxelize(meshes[i], voxels, dims, step);
    console.timeEnd('2. voxelization');

    console.time('3. flood');
    floodFill(voxels, step);
    console.timeEnd('3. flood');

    console.time('4. surfaceNet');
    var min = [dims[0][0], dims[1][0], dims[2][0]];
    var max = [dims[0][1] + stepMax, dims[1][1] + stepMax, dims[2][1] + stepMax];
    SurfaceNets.BLOCK = Remesh.BLOCK;
    var res = SurfaceNets.computeSurface(voxels, [min, max]);
    console.timeEnd('4. surfaceNet');

    console.time('5. createMesh');
    var nmesh = createMesh(baseMesh, res.vertices, res.faces, res.colors, res.materials);
    console.time('5. createMesh');

    console.timeEnd('remesh total');
    console.log('\n');
    return nmesh;
  };

  Remesh.mergeArrays = function (meshes, arr) {
    var nbVertices = 0;
    var nbFaces = 0;
    var nbQuads = 0;
    var nbTriangles = 0;

    var nbMeshes = meshes.length;
    var i = 0;
    var k = 0;
    for (i = 0; i < nbMeshes; ++i) {
      nbVertices += meshes[i].getNbVertices();
      nbFaces += meshes[i].getNbFaces();
      nbQuads += meshes[i].getNbQuads();
      nbTriangles += meshes[i].getNbTriangles();
    }

    var vAr = arr.vertices = arr.vertices !== undefined ? new Float32Array(nbVertices * 3) : null;
    var cAr = arr.colors = arr.colors !== undefined ? new Float32Array(nbVertices * 3) : null;
    var mAr = arr.materials = arr.materials !== undefined ? new Int32Array(nbFaces * 4) : null;
    var fAr = arr.faces = arr.faces !== undefined ? new Int32Array(nbFaces * 4) : null;

    var ver = [0.0, 0.0, 0.0];
    var offsetVerts = 0;
    var offsetFaces = 0;
    var offsetIndex = 0;
    for (i = 0; i < nbMeshes; ++i) {
      var mesh = meshes[i];
      var mVerts = mesh.getVertices();
      var mCols = mesh.getColors();
      var mMats = mesh.getMaterials();
      var mFaces = mesh.getFaces();
      var mNbVertices = mesh.getNbVertices();
      var mNbFaces = mesh.getNbFaces();
      var matrix = mesh.getMatrix();
      for (var j = 0; j < mNbVertices; ++j) {
        k = j * 3;
        ver[0] = mVerts[k];
        ver[1] = mVerts[k + 1];
        ver[2] = mVerts[k + 2];
        vec3.transformMat4(ver, ver, matrix);
        vAr[offsetVerts + k] = ver[0];
        vAr[offsetVerts + k + 1] = ver[1];
        vAr[offsetVerts + k + 2] = ver[2];
        if (cAr) {
          cAr[offsetVerts + k] = mCols[k];
          cAr[offsetVerts + k + 1] = mCols[k + 1];
          cAr[offsetVerts + k + 2] = mCols[k + 2];
        }
        if (mAr) {
          mAr[offsetVerts + k] = mMats[k];
          mAr[offsetVerts + k + 1] = mMats[k + 1];
          mAr[offsetVerts + k + 2] = mMats[k + 2];
        }
      }
      offsetVerts += mNbVertices * 3;
      for (j = 0; j < mNbFaces; ++j) {
        k = j * 4;
        fAr[offsetFaces + k] = mFaces[k] + offsetIndex;
        fAr[offsetFaces + k + 1] = mFaces[k + 1] + offsetIndex;
        fAr[offsetFaces + k + 2] = mFaces[k + 2] + offsetIndex;
        fAr[offsetFaces + k + 3] = mFaces[k + 3] >= 0 ? mFaces[k + 3] + offsetIndex : -1;
      }
      offsetIndex += mNbVertices;
      offsetFaces = mNbFaces * 4;
    }
  };

  Remesh.mergeMeshes = function (meshes, baseMesh) {
    var arr = {
      vertices: null,
      colors: null,
      materials: null,
      faces: null
    };
    Remesh.mergeArrays(meshes, arr);
    return createMesh(baseMesh, arr.vertices, arr.faces, arr.colors, arr.materials);
  };

  module.exports = Remesh;
});
define('drawables/Primitives',['require','exports','module','lib/glMatrix','mesh/Mesh','editing/Remesh'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Mesh = require('mesh/Mesh');
  var Remesh = require('editing/Remesh');

  var mat4 = glm.mat4;

  var Primitives = {};

  var createPlaneArray = function (lx, ly, lz, wx, wy, wz, hx, hy, hz) {
    lx = lx !== undefined ? lx : -0.5;
    ly = ly !== undefined ? ly : 0.0;
    lz = lz !== undefined ? lz : -0.5;

    wx = wx !== undefined ? wx : 1.0;
    wy = wy !== undefined ? wy : 0.0;
    wz = wz !== undefined ? wz : 0.0;

    hx = hx !== undefined ? hx : 0.0;
    hy = hy !== undefined ? hy : 0.0;
    hz = hz !== undefined ? hz : 1.0;

    var faces = new Float32Array(4);
    faces[0] = 0;
    faces[1] = 1;
    faces[2] = 2;
    faces[3] = 3;

    var v = new Float32Array(12);
    v[0] = lx;
    v[1] = ly;
    v[2] = lz;

    v[3] = lx + wx;
    v[4] = ly + wy;
    v[5] = lz + wz;

    v[6] = lx + wx + hx;
    v[7] = ly + wy + hy;
    v[8] = lz + wz + hz;

    v[9] = lx + hx;
    v[10] = ly + hy;
    v[11] = lz + hz;

    return {
      faces: faces,
      vertices: v
    };
  };

  var createCubeArray = function (side) {
    side = side || 1.0;

    var v = new Float32Array(24);
    v[1] = v[2] = v[4] = v[6] = v[7] = v[9] = v[10] = v[11] = v[14] = v[18] = v[21] = v[23] = -side * 0.5;
    v[0] = v[3] = v[5] = v[8] = v[12] = v[13] = v[15] = v[16] = v[17] = v[19] = v[20] = v[22] = side * 0.5;

    var uv = new Float32Array(28);
    uv[0] = uv[6] = uv[8] = uv[10] = uv[11] = uv[13] = uv[16] = uv[23] = uv[25] = 0.5;
    uv[1] = uv[3] = 1.0;
    uv[2] = uv[4] = uv[9] = uv[12] = uv[14] = uv[15] = uv[18] = 0.25;
    uv[5] = uv[7] = uv[21] = uv[24] = uv[26] = uv[27] = 0.75;
    uv[17] = uv[19] = uv[20] = uv[22] = 0.0;

    var f = new Int32Array(24);
    var ft = new Int32Array(24);
    f[0] = f[8] = f[21] = ft[0] = 0;
    f[1] = f[11] = f[12] = ft[1] = 1;
    f[2] = f[15] = f[16] = ft[2] = ft[15] = ft[16] = 2;
    f[3] = f[19] = f[22] = ft[3] = ft[19] = ft[22] = 3;
    f[4] = f[9] = f[20] = ft[4] = ft[9] = 4;
    f[7] = f[10] = f[13] = ft[5] = ft[18] = ft[23] = 5;
    f[6] = f[14] = f[17] = ft[6] = ft[14] = ft[17] = 6;
    f[5] = f[18] = f[23] = ft[7] = ft[10] = 7;
    ft[8] = 8;
    ft[11] = 9;
    ft[12] = 10;
    ft[13] = 11;
    ft[20] = 12;
    ft[21] = 13;

    return {
      vertices: v,
      uv: uv,
      faces: f,
      facesUV: ft
    };
  };

  var createCylinderArray = function (radiusTop, radiusBottom, height, radSegments, heightSegments, topCap, lowCap) {
    radiusTop = radiusTop !== undefined ? radiusTop : 0.5;
    radiusBottom = radiusBottom !== undefined ? radiusBottom : 0.5;
    height = height || 2.0;
    radSegments = radSegments || 64;
    heightSegments = heightSegments || 64;
    topCap = topCap !== undefined ? topCap : true;
    lowCap = lowCap !== undefined ? lowCap : true;

    topCap = topCap;
    lowCap = lowCap;
    var isSingularTop = topCap && radiusTop === 0.0;
    var isSingularBottom = lowCap && radiusBottom === 0.0;
    var heightHalf = height * 0.5;

    var nbVertices = (heightSegments + 1) * radSegments;
    var nbFaces = heightSegments * radSegments;
    if (topCap) {
      nbVertices += 1;
      nbFaces += radSegments;
    }
    if (lowCap) {
      nbVertices += 1;
      nbFaces += radSegments;
    }
    if (isSingularTop || isSingularBottom) {
      nbVertices -= radSegments;
      nbFaces -= radSegments;
    }
    var vAr = new Float32Array(nbVertices * 3);
    var fAr = new Int32Array(nbFaces * 4);

    var id = 0;
    var k = 0;
    var i = 0;
    var j = 0;
    var startHeight = isSingularTop ? 1 : 0;
    var endHeight = isSingularBottom ? heightSegments - 1 : heightSegments;
    for (i = startHeight; i <= endHeight; i++) {
      var v = i / heightSegments;
      var radius = v * (radiusBottom - radiusTop) + radiusTop;
      for (j = 0; j < radSegments; j++) {
        var u = Math.PI * 2 * j / radSegments;
        k = 3 * id++;
        vAr[k] = radius * Math.sin(u);
        vAr[k + 1] = -v * height + heightHalf;
        vAr[k + 2] = radius * Math.cos(u);
      }
    }

    id = 0;
    for (j = 0; j < radSegments; j++) {
      var off = j === radSegments - 1 ? 0 : j + 1;
      for (i = startHeight; i < endHeight; i++) {
        k = 4 * id++;
        fAr[k] = radSegments * i + j;
        fAr[k + 1] = radSegments * (i + 1) + j;
        fAr[k + 2] = radSegments * (i + 1) + off;
        fAr[k + 3] = radSegments * i + off;
      }
    }

    var last;
    if (topCap) {
      last = (lowCap ? vAr.length - 6 : vAr.length - 3) / 3;
      vAr[last * 3 + 1] = heightHalf;
      for (j = 0; j < radSegments; j++) {
        k = 4 * id++;
        fAr[k] = j;
        fAr[k + 1] = j === radSegments - 1 ? 0 : j + 1;
        fAr[k + 2] = last;
        fAr[k + 3] = -1;
      }
    }

    if (lowCap) {
      last = (vAr.length - 3) / 3;
      vAr[last * 3 + 1] = -heightHalf;
      if (isSingularTop) --i;
      var end = radSegments * i;
      for (j = 0; j < radSegments; j++) {
        k = 4 * id++;
        fAr[k] = j === radSegments - 1 ? end : end + j + 1;
        fAr[k + 1] = end + j;
        fAr[k + 2] = last;
        fAr[k + 3] = -1;
      }
    }

    return {
      vertices: vAr,
      faces: fAr
    };
  };

  var createTorusArray = function (radiusOut, radiusWidth, arc, nbRadial, nbTubular) {
    radiusOut = radiusOut || 0.5;
    radiusWidth = radiusWidth || 0.1;
    nbRadial = nbRadial || 32;
    nbTubular = nbTubular || 128;
    arc = arc || Math.PI * 2;
    var isFull = Math.PI * 2 - arc < 1e-2;

    var nbVertices = nbRadial * nbTubular;
    var nbFaces = nbVertices;
    if (!isFull) {
      nbVertices += 2;
      nbFaces += nbRadial;
    }
    var endTubular = isFull ? nbTubular : nbTubular - 1;

    var vAr = new Float32Array(nbVertices * 3);
    var fAr = new Int32Array(nbFaces * 4);
    var id = 0;
    var k = 0;
    var i = 0;
    var j = 0;
    for (i = 0; i < nbTubular; ++i) {
      for (j = 0; j < nbRadial; ++j) {
        var u = i / endTubular * arc;
        var v = j / nbRadial * Math.PI * 2;
        k = 3 * id++;
        vAr[k] = (radiusOut + radiusWidth * Math.cos(v)) * Math.cos(u);
        vAr[k + 1] = radiusWidth * Math.sin(v);
        vAr[k + 2] = (radiusOut + radiusWidth * Math.cos(v)) * Math.sin(u);
      }
    }

    id = 0;
    for (i = 0; i < endTubular; ++i) {
      var offi = i === nbTubular - 1 ? 0 : i + 1;
      for (j = 0; j < nbRadial; ++j) {
        k = 4 * id++;
        fAr[k] = nbRadial * i + j;
        var offj = j === nbRadial - 1 ? 0 : j + 1;
        fAr[k + 1] = nbRadial * i + offj;
        fAr[k + 2] = nbRadial * offi + offj;
        fAr[k + 3] = nbRadial * offi + j;
      }
    }

    if (!isFull) {
      var last = (vAr.length - 6) / 3;
      vAr[last * 3] = radiusOut;
      for (j = 0; j < nbRadial; j++) {
        k = 4 * id++;
        fAr[k] = last;
        fAr[k + 1] = j === nbRadial - 1 ? 0 : j + 1;
        fAr[k + 2] = j;
        fAr[k + 3] = -1;
      }

      ++last;
      vAr[last * 3] = radiusOut * Math.cos(arc);
      vAr[last * 3 + 2] = radiusOut * Math.sin(arc);
      var end = nbRadial * i;
      for (j = 0; j < nbRadial; j++) {
        k = 4 * id++;
        fAr[k] = last;
        fAr[k + 1] = end + j;
        fAr[k + 2] = j === nbRadial - 1 ? end : end + j + 1;
        fAr[k + 3] = -1;
      }
    }

    return {
      vertices: vAr,
      faces: fAr
    };
  };

  var createGridArray = function (cx, cy, cz, wx, wy, wz, hx, hy, hz, res1, res2) {
    cx = cx !== undefined ? cx : -0.5;
    cy = cy !== undefined ? cy : 0.0;
    cz = cz !== undefined ? cz : -0.5;

    wx = wx !== undefined ? wx : 1.0;
    wy = wy !== undefined ? wy : 0.0;
    wz = wz !== undefined ? wz : 0.0;

    hx = hx !== undefined ? hx : 0.0;
    hy = hy !== undefined ? hy : 0.0;
    hz = hz !== undefined ? hz : 1.0;

    res1 = res1 !== undefined ? res1 : 20;
    res2 = res2 !== undefined ? res2 : res1;
    res1 += 2;
    res2 += 2;

    var vAr = new Float32Array((res1 + res2) * 2 * 3);
    var i = 0;
    var j = 0;
    var sx = wx / (res1 - 1);
    var sy = wy / (res1 - 1);
    var sz = wz / (res1 - 1);
    var ux = cx + wx + hx;
    var uy = cy + wy + hy;
    var uz = cz + wz + hz;
    for (i = 0; i < res1; ++i) {
      j = i * 6;
      vAr[j] = cx + sx * i;
      vAr[j + 1] = cy + sy * i;
      vAr[j + 2] = cz + sz * i;
      vAr[j + 3] = ux - sx * (res1 - i - 1);
      vAr[j + 4] = uy - sy * (res1 - i - 1);
      vAr[j + 5] = uz - sz * (res1 - i - 1);
    }
    sx = hx / (res2 - 1);
    sy = hy / (res2 - 1);
    sz = hz / (res2 - 1);
    for (i = 0; i < res2; ++i) {
      j = (res1 + i) * 6;
      vAr[j] = cx + sx * i;
      vAr[j + 1] = cy + sy * i;
      vAr[j + 2] = cz + sz * i;
      vAr[j + 3] = ux - sx * (res2 - i - 1);
      vAr[j + 4] = uy - sy * (res2 - i - 1);
      vAr[j + 5] = uz - sz * (res2 - i - 1);
    }

    return {
      vertices: vAr
    };
  };

  var createMesh = function (gl, arr) {
    var mesh = new Mesh(gl);
    mesh.setVertices(arr.vertices);
    if (arr.faces) mesh.setFaces(arr.faces);
    if (arr.uv && arr.facesUV) mesh.initTexCoordsDataFromOBJData(arr.uv, arr.facesUV);

    mesh.init();
    if (gl) mesh.initRender();
    return mesh;
  };

  var slice = Array.prototype.slice;

  Primitives.createGrid = function (gl) {
    var mesh = createMesh(gl, createGridArray.apply(this, slice.call(arguments, 1)));
    if (gl) {
      mesh.setMode(gl.LINES);
      mesh.setUseDrawArrays(true);
      mesh.setAlreadyDrawArrays();
    }
    return mesh;
  };

  Primitives.createCube = function (gl) {
    return createMesh(gl, createCubeArray.apply(this, slice.call(arguments, 1)));
  };

  Primitives.createCylinder = function (gl) {
    return createMesh(gl, createCylinderArray.apply(this, slice.call(arguments, 1)));
  };

  Primitives.createTorus = function (gl) {
    return createMesh(gl, createTorusArray.apply(this, slice.call(arguments, 1)));
  };

  Primitives.createPlane = function (gl) {
    return createMesh(gl, createPlaneArray.apply(this, slice.call(arguments, 1)));
  };

  Primitives.createArrow = function (gl, thick, height, rConeT, rConeH, radSegments, heightSegments) {
    thick = thick || 0.5;
    height = height || 2.0;
    radSegments = radSegments || 4;
    heightSegments = heightSegments || 1;
    rConeT = rConeT || 5.0;
    rConeH = rConeH || 0.2;

    var base = createMesh(gl, createCylinderArray(thick, thick, height, radSegments, heightSegments));
    var cone = createMesh(gl, createCylinderArray(0.0, thick * rConeT, height * rConeH, radSegments, heightSegments));
    mat4.translate(cone.getMatrix(), cone.getMatrix(), [0.0, height * 0.5, 0.0]);

    var arrow = {
      vertices: null,
      faces: null
    };
    Remesh.mergeArrays([base, cone], arrow);
    return createMesh(gl, arrow);
  };

  Primitives.createLine2D = function (gl, lx, ly, ux, uy) {
    var mesh = createMesh(gl, {
      vertices: new Float32Array([lx || 0.0, ly || 0.0, 0.0, ux || 0.0, uy || 0.0, 0.0])
    });
    if (gl) {
      mesh.setMode(gl.LINES);
      mesh.setUseDrawArrays(true);
      mesh.setAlreadyDrawArrays();
    }
    return mesh;
  };

  module.exports = Primitives;
});
define('editing/Gizmo',['require','exports','module','lib/glMatrix','drawables/Primitives'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Primitives = require('drawables/Primitives');

  var vec2 = glm.vec2;
  var vec3 = glm.vec3;
  var mat4 = glm.mat4;
  var quat = glm.quat;

  // configs colors
  var COLOR_X = vec3.fromValues(0.7, 0.2, 0.2);
  var COLOR_Y = vec3.fromValues(0.2, 0.7, 0.2);
  var COLOR_Z = vec3.fromValues(0.2, 0.2, 0.7);
  var COLOR_GREY = vec3.fromValues(0.4, 0.4, 0.4);
  var COLOR_SW = vec3.fromValues(0.8, 0.4, 0.2);

  // overall scale of the gizmo
  var GIZMO_SIZE = 0.08;
  // arrow
  var ARROW_LENGTH = 2.5;
  var ARROW_CONE_THICK = 6.0;
  var ARROW_CONE_LENGTH = 0.25;
  // thickness of tori and arrows
  var THICKNESS = 0.020;
  var THICKNESS_PICK = THICKNESS * 5.0;
  // radius of tori
  var ROT_RADIUS = 1.5;
  var SCALE_RADIUS = ROT_RADIUS * 1.3;
  // size of cubes
  var CUBE_SIDE = 0.35;
  var CUBE_SIDE_PICK = CUBE_SIDE * 1.2;

  var createGizmo = function (type, nbAxis) {
    return {
      _finalMatrix: mat4.create(),
      _baseMatrix: mat4.create(),
      _color: vec3.create(),
      _colorSelect: vec3.fromValues(1.0, 1.0, 0.0),
      _drawGeo: null,
      _pickGeo: null,
      _isSelected: false,
      _type: type !== undefined ? type : -1,
      _nbAxis: nbAxis !== undefined ? nbAxis : -1,
      _lastInter: [0.0, 0.0, 0.0],
      updateMatrix: function () {
        mat4.copy(this._drawGeo.getMatrix(), this._finalMatrix);
        mat4.copy(this._pickGeo.getMatrix(), this._finalMatrix);
      },
      updateFinalMatrix: function (mat) {
        mat4.mul(this._finalMatrix, mat, this._baseMatrix);
      }
    };
  };

  var Gizmo = function (main) {
    this._main = main;
    this._gl = main._gl;

    // activated gizmos
    this._activatedType = Gizmo.TRANS_XYZ | Gizmo.ROT_XYZ | Gizmo.PLANE_XYZ | Gizmo.SCALE_XYZW | Gizmo.ROT_W;

    // trans arrow 1 dim
    this._transX = createGizmo(Gizmo.TRANS_X, 0);
    this._transY = createGizmo(Gizmo.TRANS_Y, 1);
    this._transZ = createGizmo(Gizmo.TRANS_Z, 2);

    // trans plane 2 dim
    this._planeX = createGizmo(Gizmo.PLANE_X, 0);
    this._planeY = createGizmo(Gizmo.PLANE_Y, 1);
    this._planeZ = createGizmo(Gizmo.PLANE_Z, 2);

    // scale cube 1 dim
    this._scaleX = createGizmo(Gizmo.SCALE_X, 0);
    this._scaleY = createGizmo(Gizmo.SCALE_Y, 1);
    this._scaleZ = createGizmo(Gizmo.SCALE_Z, 2);
    // scale cube 3 dim
    this._scaleW = createGizmo(Gizmo.SCALE_W);

    // rot arc 1 dim
    this._rotX = createGizmo(Gizmo.ROT_X, 0);
    this._rotY = createGizmo(Gizmo.ROT_Y, 1);
    this._rotZ = createGizmo(Gizmo.ROT_Z, 2);
    // full arc display
    this._rotW = createGizmo(Gizmo.ROT_W);

    // line helper
    this._lineHelper = Primitives.createLine2D(this._gl);
    this._lineHelper.setShaderName('FLAT');

    this._lastDistToEye = 0.0;
    this._isEditing = false;

    this._selected = null;
    this._pickables = [];

    // editing lines stuffs
    this._editLineOrigin = [0.0, 0.0, 0.0];
    this._editLineDirection = [0.0, 0.0, 0.0];
    this._editOffset = [0.0, 0.0, 0.0];

    // cached matrices when starting the editing operations
    this._editLocal = mat4.create();
    this._editTrans = mat4.create();
    this._editScaleRot = mat4.create();
    // same for inv
    this._editLocalInv = mat4.create();
    this._editTransInv = mat4.create();
    this._editScaleRotInv = mat4.create();

    this._initTranslate();
    this._initRotate();
    this._initScale();
    this._initPickables();
  };

  // edit masks
  var TRANS_X = Gizmo.TRANS_X = 1 << 0;
  var TRANS_Y = Gizmo.TRANS_Y = 1 << 1;
  var TRANS_Z = Gizmo.TRANS_Z = 1 << 2;
  var ROT_X = Gizmo.ROT_X = 1 << 3;
  var ROT_Y = Gizmo.ROT_Y = 1 << 4;
  var ROT_Z = Gizmo.ROT_Z = 1 << 5;
  var ROT_W = Gizmo.ROT_W = 1 << 6;
  var PLANE_X = Gizmo.PLANE_X = 1 << 7;
  var PLANE_Y = Gizmo.PLANE_Y = 1 << 8;
  var PLANE_Z = Gizmo.PLANE_Z = 1 << 9;
  var SCALE_X = Gizmo.SCALE_X = 1 << 10;
  var SCALE_Y = Gizmo.SCALE_Y = 1 << 11;
  var SCALE_Z = Gizmo.SCALE_Z = 1 << 12;
  var SCALE_W = Gizmo.SCALE_W = 1 << 13;

  var TRANS_XYZ = Gizmo.TRANS_XYZ = TRANS_X | TRANS_Y | TRANS_Z;
  var ROT_XYZ = Gizmo.ROT_XYZ = ROT_X | ROT_Y | ROT_Z;
  var PLANE_XYZ = Gizmo.PLANE_XYZ = PLANE_X | PLANE_Y | PLANE_Z;
  var SCALE_XYZW = Gizmo.SCALE_XYZW = SCALE_X | SCALE_Y | SCALE_Z | SCALE_W;

  Gizmo.prototype = {
    setActivatedType: function (type) {
      this._activatedType = type;
      this._initPickables();
    },
    _initPickables: function () {
      var pickables = this._pickables;
      pickables.length = 0;
      var type = this._activatedType;

      if (type & TRANS_X) pickables.push(this._transX._pickGeo);
      if (type & TRANS_Y) pickables.push(this._transY._pickGeo);
      if (type & TRANS_Z) pickables.push(this._transZ._pickGeo);

      if (type & PLANE_X) pickables.push(this._planeX._pickGeo);
      if (type & PLANE_Y) pickables.push(this._planeY._pickGeo);
      if (type & PLANE_Z) pickables.push(this._planeZ._pickGeo);

      if (type & ROT_X) pickables.push(this._rotX._pickGeo);
      if (type & ROT_Y) pickables.push(this._rotY._pickGeo);
      if (type & ROT_Z) pickables.push(this._rotZ._pickGeo);

      if (type & SCALE_X) pickables.push(this._scaleX._pickGeo);
      if (type & SCALE_Y) pickables.push(this._scaleY._pickGeo);
      if (type & SCALE_Z) pickables.push(this._scaleZ._pickGeo);
      if (type & SCALE_W) pickables.push(this._scaleW._pickGeo);
    },
    _createArrow: function (tra, axis, color) {
      var mat = tra._baseMatrix;
      mat4.rotate(mat, mat, Math.PI * 0.5, axis);
      mat4.translate(mat, mat, [0.0, ARROW_LENGTH * 0.5, 0.0]);
      vec3.copy(tra._color, color);

      tra._pickGeo = Primitives.createArrow(this._gl, THICKNESS_PICK, ARROW_LENGTH, ARROW_CONE_THICK * 0.4);
      tra._pickGeo._gizmo = tra;
      tra._drawGeo = Primitives.createArrow(this._gl, THICKNESS, ARROW_LENGTH, ARROW_CONE_THICK, ARROW_CONE_LENGTH);
      tra._drawGeo.setShaderName('FLAT');
    },
    _createPlane: function (pla, color, wx, wy, wz, hx, hy, hz) {
      vec3.copy(pla._color, color);

      pla._pickGeo = Primitives.createPlane(this._gl, 0.0, 0.0, 0.0, wx, wy, wz, hx, hy, hz);
      pla._pickGeo._gizmo = pla;
      pla._drawGeo = Primitives.createPlane(this._gl, 0.0, 0.0, 0.0, wx, wy, wz, hx, hy, hz);
      pla._drawGeo.setShaderName('FLAT');
    },
    _initTranslate: function () {
      var axis = [0.0, 0.0, 0.0];
      this._createArrow(this._transX, vec3.set(axis, 0.0, 0.0, -1.0), COLOR_X);
      this._createArrow(this._transY, vec3.set(axis, 0.0, 1.0, 0.0), COLOR_Y);
      this._createArrow(this._transZ, vec3.set(axis, 1.0, 0.0, 0.0), COLOR_Z);

      var s = ARROW_LENGTH * 0.2;
      this._createPlane(this._planeX, COLOR_X, 0.0, s, 0.0, 0.0, 0.0, s);
      this._createPlane(this._planeY, COLOR_Y, s, 0.0, 0.0, 0.0, 0.0, s);
      this._createPlane(this._planeZ, COLOR_Z, s, 0.0, 0.0, 0.0, s, 0.0);
    },
    _createCircle: function (rot, rad, color, radius, mthick) {
      radius = radius || ROT_RADIUS;
      mthick = mthick || 1.0;
      vec3.copy(rot._color, color);
      rot._pickGeo = Primitives.createTorus(this._gl, radius, THICKNESS_PICK * mthick, rad, 6, 64);
      rot._pickGeo._gizmo = rot;
      rot._drawGeo = Primitives.createTorus(this._gl, radius, THICKNESS * mthick, rad, 6, 64);
      rot._drawGeo.setShaderName('FLAT');
    },
    _initRotate: function () {
      this._createCircle(this._rotX, Math.PI, COLOR_X);
      this._createCircle(this._rotY, Math.PI, COLOR_Y);
      this._createCircle(this._rotZ, Math.PI, COLOR_Z);
      this._createCircle(this._rotW, Math.PI * 2, COLOR_GREY);
    },
    _createCube: function (sca, axis, color) {
      var mat = sca._baseMatrix;
      mat4.rotate(mat, mat, Math.PI * 0.5, axis);
      mat4.translate(mat, mat, [0.0, ROT_RADIUS, 0.0]);
      vec3.copy(sca._color, color);
      sca._pickGeo = Primitives.createCube(this._gl, CUBE_SIDE_PICK);
      sca._pickGeo._gizmo = sca;
      sca._drawGeo = Primitives.createCube(this._gl, CUBE_SIDE);
      sca._drawGeo.setShaderName('FLAT');
    },
    _initScale: function () {
      var axis = [0.0, 0.0, 0.0];
      this._createCube(this._scaleX, vec3.set(axis, 0.0, 0.0, -1.0), COLOR_X);
      this._createCube(this._scaleY, vec3.set(axis, 0.0, 1.0, 0.0), COLOR_Y);
      this._createCube(this._scaleZ, vec3.set(axis, 1.0, 0.0, 0.0), COLOR_Z);
      this._createCircle(this._scaleW, Math.PI * 2, COLOR_SW, SCALE_RADIUS, 2.0);
    },
    _updateArcRotation: (function () {
      var qTmp = quat.create();
      return function (eye) {
        // xyz arc
        qTmp[0] = eye[2];
        qTmp[1] = 0.0;
        qTmp[2] = -eye[0];
        qTmp[3] = 1.0 + eye[1];
        quat.normalize(qTmp, qTmp);
        mat4.fromQuat(this._rotW._baseMatrix, qTmp);
        mat4.fromQuat(this._scaleW._baseMatrix, qTmp);

        // x arc
        quat.rotateZ(qTmp, quat.identity(qTmp), Math.PI * 0.5);
        quat.rotateY(qTmp, qTmp, Math.atan2(-eye[1], -eye[2]));
        mat4.fromQuat(this._rotX._baseMatrix, qTmp);

        // y arc
        quat.rotateY(qTmp, quat.identity(qTmp), Math.atan2(-eye[0], -eye[2]));
        mat4.fromQuat(this._rotY._baseMatrix, qTmp);

        // z arc
        quat.rotateX(qTmp, quat.identity(qTmp), Math.PI * 0.5);
        quat.rotateY(qTmp, qTmp, Math.atan2(-eye[0], eye[1]));
        mat4.fromQuat(this._rotZ._baseMatrix, qTmp);
      };
    })(),
    _computeCenterGizmo: function (center) {
      var mesh = this._main.getMesh();
      center = center || [0.0, 0.0, 0.0];
      if (mesh) {
        vec3.copy(center, mesh.getCenter());
        vec3.transformMat4(center, center, mesh.getEditMatrix());
        vec3.transformMat4(center, center, mesh.getMatrix());
      }
      return center;
    },
    _updateMatrices: function () {
      var camera = this._main.getCamera();
      var trMesh = this._computeCenterGizmo();
      var eye = camera.computePosition();

      this._lastDistToEye = this._isEditing ? this._lastDistToEye : vec3.dist(eye, trMesh);
      var scaleFactor = this._lastDistToEye * GIZMO_SIZE / camera.getConstantScreen();

      var traScale = mat4.create();
      mat4.translate(traScale, traScale, trMesh);
      mat4.scale(traScale, traScale, [scaleFactor, scaleFactor, scaleFactor]);

      // manage arc stuffs
      this._updateArcRotation(vec3.normalize(eye, vec3.sub(eye, trMesh, eye)));

      this._transX.updateFinalMatrix(traScale);
      this._transY.updateFinalMatrix(traScale);
      this._transZ.updateFinalMatrix(traScale);

      this._planeX.updateFinalMatrix(traScale);
      this._planeY.updateFinalMatrix(traScale);
      this._planeZ.updateFinalMatrix(traScale);

      this._rotX.updateFinalMatrix(traScale);
      this._rotY.updateFinalMatrix(traScale);
      this._rotZ.updateFinalMatrix(traScale);
      this._rotW.updateFinalMatrix(traScale);

      this._scaleX.updateFinalMatrix(traScale);
      this._scaleY.updateFinalMatrix(traScale);
      this._scaleZ.updateFinalMatrix(traScale);
      this._scaleW.updateFinalMatrix(traScale);
    },
    _drawGizmo: function (elt) {
      elt.updateMatrix();
      var drawGeo = elt._drawGeo;
      drawGeo.setFlatColor(elt._isSelected ? elt._colorSelect : elt._color);
      drawGeo.updateMatrices(this._main.getCamera());
      drawGeo.render(this._main);
    },
    _updateLineHelper: function (x1, y1, x2, y2) {
      var vAr = this._lineHelper.getVertices();
      var main = this._main;
      var width = main.getCanvasWidth();
      var height = main.getCanvasHeight();
      vAr[0] = ((x1 / width) * 2.0) - 1.0;
      vAr[1] = (((height - y1) / height)) * 2.0 - 1.0;
      vAr[3] = ((x2 / width) * 2.0) - 1.0;
      vAr[4] = (((height - y2) / height)) * 2.0 - 1.0;
      this._lineHelper.updateVertexBuffer();
    },
    _saveEditMatrices: function () {
      // mesh local matrix
      mat4.copy(this._editLocal, this._main.getMesh().getMatrix());

      // translation part
      var center = this._computeCenterGizmo();
      mat4.translate(this._editTrans, mat4.identity(this._editTrans), center);

      // rotation + scale part
      mat4.copy(this._editScaleRot, this._editLocal);
      this._editScaleRot[12] = this._editScaleRot[13] = this._editScaleRot[14] = 0.0;

      // precomputes the invert
      mat4.invert(this._editLocalInv, this._editLocal);
      mat4.invert(this._editTransInv, this._editTrans);
      mat4.invert(this._editScaleRotInv, this._editScaleRot);
    },
    _startRotateEdit: function () {
      var main = this._main;
      var camera = main.getCamera();

      // 3d origin (center of gizmo)
      var projCenter = [0.0, 0.0, 0.0];
      this._computeCenterGizmo(projCenter);
      vec3.copy(projCenter, camera.project(projCenter));

      // compute tangent direction and project it on screen
      var dir = this._editLineDirection;
      var sign = this._selected._nbAxis === 0 ? -1.0 : 1.0;
      var lastInter = this._selected._lastInter;
      vec3.set(dir, -sign * lastInter[2], -sign * lastInter[1], sign * lastInter[0]);
      vec3.transformMat4(dir, dir, this._selected._finalMatrix);
      vec3.copy(dir, camera.project(dir));

      vec2.normalize(dir, vec2.sub(dir, dir, projCenter));

      vec2.set(this._editLineOrigin, main._mouseX, main._mouseY);
    },
    _startTranslateEdit: function () {
      var main = this._main;
      var camera = main.getCamera();

      var origin = this._editLineOrigin;
      var dir = this._editLineDirection;

      // 3d origin (center of gizmo)
      this._computeCenterGizmo(origin);

      // 3d direction
      var nbAxis = this._selected._nbAxis;
      if (nbAxis !== -1) // if -1, we don't care about dir vector
        vec3.set(dir, 0.0, 0.0, 0.0)[nbAxis] = 1.0;
      vec3.add(dir, origin, dir);

      // project on screen and get a 2D line
      vec3.copy(origin, camera.project(origin));
      vec3.copy(dir, camera.project(dir));

      vec2.normalize(dir, vec2.sub(dir, dir, origin));

      var offset = this._editOffset;
      offset[0] = main._mouseX - origin[0];
      offset[1] = main._mouseY - origin[1];
    },
    _startPlaneEdit: function () {
      var main = this._main;
      var camera = main.getCamera();

      var origin = this._editLineOrigin;

      // 3d origin (center of gizmo)
      this._computeCenterGizmo(origin);

      vec3.copy(origin, camera.project(origin));

      var offset = this._editOffset;
      offset[0] = main._mouseX - origin[0];
      offset[1] = main._mouseY - origin[1];
      vec2.set(this._editLineOrigin, main._mouseX, main._mouseY);
    },
    _startScaleEdit: function () {
      this._startTranslateEdit();
    },
    _updateRotateEdit: function () {
      var main = this._main;
      var mesh = main.getMesh();

      var origin = this._editLineOrigin;
      var dir = this._editLineDirection;

      var vec = [main._mouseX, main._mouseY, 0.0];
      vec2.sub(vec, vec, origin);
      var dist = vec2.dot(vec, dir);

      // helper line
      this._updateLineHelper(origin[0], origin[1], origin[0] + dir[0] * dist, origin[1] + dir[1] * dist);

      var angle = 7 * dist / Math.min(main.getCanvasWidth(), main.getCanvasHeight());
      angle %= (Math.PI * 2);
      var nbAxis = this._selected._nbAxis;

      var mrot = mesh.getEditMatrix();
      mat4.identity(mrot);
      if (nbAxis === 0) mat4.rotateX(mrot, mrot, -angle);
      else if (nbAxis === 1) mat4.rotateY(mrot, mrot, -angle);
      else if (nbAxis === 2) mat4.rotateZ(mrot, mrot, -angle);

      this._scaleRotateEditMatrix(mrot);

      main.render();
    },
    _updateTranslateEdit: function () {
      var main = this._main;
      var camera = main.getCamera();
      var mesh = main.getMesh();

      var origin = this._editLineOrigin;
      var dir = this._editLineDirection;

      var vec = [main._mouseX, main._mouseY, 0.0];
      vec2.sub(vec, vec, origin);
      vec2.sub(vec, vec, this._editOffset);
      vec2.scaleAndAdd(vec, origin, dir, vec2.dot(vec, dir));

      // helper line
      this._updateLineHelper(origin[0], origin[1], vec[0], vec[1]);

      var near = camera.unproject(vec[0], vec[1], 0.0);
      var far = camera.unproject(vec[0], vec[1], 0.1);

      vec3.transformMat4(near, near, this._editTransInv);
      vec3.transformMat4(far, far, this._editTransInv);

      // intersection line line
      vec3.normalize(vec, vec3.sub(vec, far, near));

      var inter = [0.0, 0.0, 0.0];
      inter[this._selected._nbAxis] = 1.0;

      var a01 = -vec3.dot(vec, inter);
      var b0 = vec3.dot(near, vec);
      var det = Math.abs(1.0 - a01 * a01);

      var b1 = -vec3.dot(near, inter);
      inter[this._selected._nbAxis] = (a01 * b0 - b1) / det;

      vec3.transformMat4(inter, inter, this._editScaleRotInv);
      var edim = mesh.getEditMatrix();
      mat4.identity(edim);
      mat4.translate(edim, edim, inter);

      main.render();
    },
    _updatePlaneEdit: function () {
      var main = this._main;
      var camera = main.getCamera();
      var mesh = main.getMesh();

      var vec = [main._mouseX, main._mouseY, 0.0];
      vec2.sub(vec, vec, this._editOffset);

      // helper line
      this._updateLineHelper(this._editLineOrigin[0], this._editLineOrigin[1], main._mouseX, main._mouseY);

      var near = camera.unproject(vec[0], vec[1], 0.0);
      var far = camera.unproject(vec[0], vec[1], 0.1);

      vec3.transformMat4(near, near, this._editTransInv);
      vec3.transformMat4(far, far, this._editTransInv);

      // intersection line plane
      var inter = [0.0, 0.0, 0.0];
      inter[this._selected._nbAxis] = 1.0;

      var dist1 = vec3.dot(near, inter);
      var dist2 = vec3.dot(far, inter);
      // ray copplanar to triangle
      if (dist1 === dist2)
        return false;

      // intersection between ray and triangle
      var val = -dist1 / (dist2 - dist1);
      inter[0] = near[0] + (far[0] - near[0]) * val;
      inter[1] = near[1] + (far[1] - near[1]) * val;
      inter[2] = near[2] + (far[2] - near[2]) * val;

      vec3.transformMat4(inter, inter, this._editScaleRotInv);
      var edim = mesh.getEditMatrix();
      mat4.identity(edim);
      mat4.translate(edim, edim, inter);

      main.render();
    },
    _updateScaleEdit: function () {
      var main = this._main;
      var mesh = main.getMesh();

      var origin = this._editLineOrigin;
      var dir = this._editLineDirection;
      var nbAxis = this._selected._nbAxis;

      var vec = [main._mouseX, main._mouseY, 0.0];
      if (nbAxis !== -1) {
        vec2.sub(vec, vec, origin);
        vec2.scaleAndAdd(vec, origin, dir, vec2.dot(vec, dir));
      }

      // helper line
      this._updateLineHelper(origin[0], origin[1], vec[0], vec[1]);

      var distOffset = vec3.len(this._editOffset);
      var inter = [1.0, 1.0, 1.0];
      var scaleMult = Math.max(-0.99, (vec3.dist(origin, vec) - distOffset) / distOffset);
      if (nbAxis === -1) {
        inter[0] += scaleMult;
        inter[1] += scaleMult;
        inter[2] += scaleMult;
      } else {
        inter[nbAxis] += scaleMult;
      }

      var edim = mesh.getEditMatrix();
      mat4.identity(edim);
      mat4.scale(edim, edim, inter);

      this._scaleRotateEditMatrix(edim);

      main.render();
    },
    _scaleRotateEditMatrix: function (edit) {
      mat4.mul(edit, this._editTrans, edit);
      mat4.mul(edit, edit, this._editTransInv);

      mat4.mul(edit, this._editLocalInv, edit);
      mat4.mul(edit, edit, this._editLocal);
    },
    addGizmoToScene: function (scene) {
      scene.push(this._transX._drawGeo);
      scene.push(this._transY._drawGeo);
      scene.push(this._transZ._drawGeo);

      scene.push(this._planeX._drawGeo);
      scene.push(this._planeY._drawGeo);
      scene.push(this._planeZ._drawGeo);

      scene.push(this._rotX._drawGeo);
      scene.push(this._rotY._drawGeo);
      scene.push(this._rotZ._drawGeo);
      scene.push(this._rotW._drawGeo);

      scene.push(this._scaleX._drawGeo);
      scene.push(this._scaleY._drawGeo);
      scene.push(this._scaleZ._drawGeo);
      scene.push(this._scaleW._drawGeo);

      return scene;
    },
    render: function () {
      this._updateMatrices();

      var type = this._isEditing && this._selected ? this._selected._type : this._activatedType;

      if (type & ROT_W) this._drawGizmo(this._rotW);

      if (type & TRANS_X) this._drawGizmo(this._transX);
      if (type & TRANS_Y) this._drawGizmo(this._transY);
      if (type & TRANS_Z) this._drawGizmo(this._transZ);

      if (type & PLANE_X) this._drawGizmo(this._planeX);
      if (type & PLANE_Y) this._drawGizmo(this._planeY);
      if (type & PLANE_Z) this._drawGizmo(this._planeZ);

      if (type & ROT_X) this._drawGizmo(this._rotX);
      if (type & ROT_Y) this._drawGizmo(this._rotY);
      if (type & ROT_Z) this._drawGizmo(this._rotZ);

      if (type & SCALE_X) this._drawGizmo(this._scaleX);
      if (type & SCALE_Y) this._drawGizmo(this._scaleY);
      if (type & SCALE_Z) this._drawGizmo(this._scaleZ);
      if (type & SCALE_W) this._drawGizmo(this._scaleW);

      if (this._isEditing) this._lineHelper.render(this._main);
    },
    onMouseOver: function () {
      if (this._isEditing) {
        var type = this._selected._type;
        if (type & ROT_XYZ) this._updateRotateEdit();
        else if (type & TRANS_XYZ) this._updateTranslateEdit();
        else if (type & PLANE_XYZ) this._updatePlaneEdit();
        else if (type & SCALE_XYZW) this._updateScaleEdit();

        return true;
      }

      var main = this._main;
      var picking = main.getPicking();
      var mx = main._mouseX;
      var my = main._mouseY;
      var pickables = this._pickables;
      picking.intersectionMouseMeshes(pickables, mx, my);

      if (this._selected)
        this._selected._isSelected = false;
      var geo = picking.getMesh();
      if (!geo) {
        this._selected = null;
        return false;
      }

      this._selected = geo._gizmo;
      this._selected._isSelected = true;
      vec3.copy(this._selected._lastInter, picking.getIntersectionPoint());
      return true;
    },
    onMouseDown: function () {
      var sel = this._selected;
      if (!sel)
        return false;

      this._isEditing = true;
      var type = sel._type;
      this._saveEditMatrices();

      if (type & ROT_XYZ) this._startRotateEdit();
      else if (type & TRANS_XYZ) this._startTranslateEdit();
      else if (type & PLANE_XYZ) this._startPlaneEdit();
      else if (type & SCALE_XYZW) this._startScaleEdit();

      return true;
    },
    onMouseUp: function () {
      this._isEditing = false;
    }
  };

  module.exports = Gizmo;
});
define('editing/tools/Transform',['require','exports','module','lib/glMatrix','misc/Utils','editing/Gizmo','editing/tools/SculptBase'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Utils = require('misc/Utils');
  var Gizmo = require('editing/Gizmo');
  var SculptBase = require('editing/tools/SculptBase');

  var vec3 = glm.vec3;
  var mat4 = glm.mat4;

  var Transform = function (main) {
    SculptBase.call(this, main);
    this._gizmo = new Gizmo(main);
  };

  Transform.prototype = {
    isIdentity: function (m) {
      if (m[0] !== 1.0 || m[5] !== 1.0 || m[10] !== 1.0 || m[15] !== 1.0) return false;
      if (m[1] !== 0.0 || m[2] !== 0.0 || m[3] !== 0.0 || m[4] !== 0.0) return false;
      if (m[6] !== 0.0 || m[7] !== 0.0 || m[8] !== 0.0 || m[9] !== 0.0) return false;
      if (m[11] !== 0.0 || m[12] !== 0.0 || m[13] !== 0.0 || m[14] !== 0.0) return false;
      return true;
    },
    preUpdate: function () {
      var picking = this._main.getPicking();

      var mesh = picking.getMesh();
      this._gizmo.onMouseOver();
      picking._mesh = mesh;

      this._main.setCanvasCursor('default');
    },
    start: function (ctrl) {
      var main = this._main;
      var mesh = this.getMesh();
      var picking = main.getPicking();

      if (mesh && this._gizmo.onMouseDown()) {
        this.pushState();
        picking._mesh = mesh;
        return true;
      }

      if (!picking.intersectionMouseMeshes(main.getMeshes(), main._mouseX, main._mouseY))
        return false;

      if (!main.setOrUnsetMesh(picking.getMesh(), ctrl))
        return false;

      this._lastMouseX = main._mouseX;
      this._lastMouseY = main._mouseY;
      return false;
    },
    end: function () {
      this._gizmo.onMouseUp();

      var mesh = this.getMesh();
      if (!mesh)
        return;

      if (this.isIdentity(mesh.getEditMatrix()))
        return;

      var iVerts = this.getUnmaskedVertices();
      this._states.pushVertices(iVerts);

      this.applyEditMatrix(iVerts);
      if (iVerts.length === 0) return;
      this.updateMeshBuffers();
    },
    applyEditMatrix: function (iVerts) {
      var mesh = this.getMesh();
      var em = mesh.getEditMatrix();
      var mAr = mesh.getMaterials();
      var vAr = mesh.getVertices();
      var vTemp = [0.0, 0.0, 0.0];
      for (var i = 0, nb = iVerts.length; i < nb; ++i) {
        var j = iVerts[i] * 3;
        var mask = mAr[j + 2];
        var x = vTemp[0] = vAr[j];
        var y = vTemp[1] = vAr[j + 1];
        var z = vTemp[2] = vAr[j + 2];
        vec3.transformMat4(vTemp, vTemp, em);
        var iMask = 1.0 - mask;
        vAr[j] = x * iMask + vTemp[0] * mask;
        vAr[j + 1] = y * iMask + vTemp[1] * mask;
        vAr[j + 2] = z * iMask + vTemp[2] * mask;
      }
      vec3.transformMat4(mesh.getCenter(), mesh.getCenter(), em);
      mat4.identity(em);
      if (iVerts.length === mesh.getNbVertices()) mesh.updateGeometry();
      else mesh.updateGeometry(mesh.getFacesFromVertices(iVerts), iVerts);
    },
    update: function () {},
    postRender: function () {
      if (this.getMesh())
        this._gizmo.render();
    },
    addSculptToScene: function (scene) {
      if (this.getMesh())
        this._gizmo.addGizmoToScene(scene);
    }
  };

  Utils.makeProxy(SculptBase, Transform);

  module.exports = Transform;
});
define('editing/tools/Tools',['require','exports','module','editing/tools/Brush','editing/tools/Inflate','editing/tools/Twist','editing/tools/Smooth','editing/tools/Flatten','editing/tools/Pinch','editing/tools/Crease','editing/tools/Drag','editing/tools/Paint','editing/tools/Move','editing/tools/Masking','editing/tools/LocalScale','editing/tools/Transform'],function (require, exports, module) {

  'use strict';

  var Brush = require('editing/tools/Brush');
  var Inflate = require('editing/tools/Inflate');
  var Twist = require('editing/tools/Twist');
  var Smooth = require('editing/tools/Smooth');
  var Flatten = require('editing/tools/Flatten');
  var Pinch = require('editing/tools/Pinch');
  var Crease = require('editing/tools/Crease');
  var Drag = require('editing/tools/Drag');
  var Paint = require('editing/tools/Paint');
  var Move = require('editing/tools/Move');
  var Masking = require('editing/tools/Masking');
  var LocalScale = require('editing/tools/LocalScale');
  var Transform = require('editing/tools/Transform');

  var Tools = {};

  Tools.BRUSH = Brush;
  Tools.INFLATE = Inflate;
  Tools.TWIST = Twist;
  Tools.SMOOTH = Smooth;
  Tools.FLATTEN = Flatten;
  Tools.PINCH = Pinch;
  Tools.CREASE = Crease;
  Tools.DRAG = Drag;
  Tools.PAINT = Paint;
  Tools.MOVE = Move;
  Tools.MASKING = Masking;
  Tools.LOCALSCALE = LocalScale;
  Tools.TRANSFORM = Transform;

  Tools.BRUSH.uiName = 'sculptBrush';
  Tools.INFLATE.uiName = 'sculptInflate';
  Tools.TWIST.uiName = 'sculptTwist';
  Tools.SMOOTH.uiName = 'sculptSmooth';
  Tools.FLATTEN.uiName = 'sculptFlatten';
  Tools.PINCH.uiName = 'sculptPinch';
  Tools.CREASE.uiName = 'sculptCrease';
  Tools.DRAG.uiName = 'sculptDrag';
  Tools.PAINT.uiName = 'sculptPaint';
  Tools.MOVE.uiName = 'sculptMove';
  Tools.MASKING.uiName = 'sculptMasking';
  Tools.LOCALSCALE.uiName = 'sculptLocalScale';
  Tools.TRANSFORM.uiName = 'sculptTransform';

  Tools.keys = Object.keys(Tools);

  module.exports = Tools;
});
define('editing/Sculpt',['require','exports','module','editing/tools/Tools'],function (require, exports, module) {

  'use strict';

  var Tools = require('editing/tools/Tools');

  var Sculpt = function (main) {
    this._main = main;

    this._tool = 'BRUSH'; // sculpting mode
    this._tools = []; // the sculpting tools

    // symmetry stuffs
    this._symmetry = true; // if symmetric sculpting is enabled  

    // continuous stuffs
    this._continuous = false; // continuous sculpting
    this._sculptTimer = -1; // continuous interval timer

    this.init();
  };

  Sculpt.prototype = {
    getToolName: function () {
      return this._tool;
    },
    getCurrentTool: function () {
      return this._tools[this._tool];
    },
    getSymmetry: function () {
      return this._symmetry;
    },
    getTool: function (key) {
      return this._tools[key];
    },
    init: function () {
      var main = this._main;
      var tools = this._tools;
      var tnames = Tools.keys;
      for (var i = 0, nb = tnames.length; i < nb; ++i) {
        var tn = tnames[i];
        tools[tn] = new Tools[tn](main);
      }
    },
    canBeContinuous: function () {
      switch (this._tool) {
      case 'TWIST':
      case 'MOVE':
      case 'DRAG':
      case 'LOCALSCALE':
      case 'TRANSFORM':
        return false;
      default:
        return true;
      }
    },
    isUsingContinuous: function () {
      return this._continuous && this.canBeContinuous();
    },
    start: function (ctrl) {
      var tool = this.getCurrentTool();
      var canEdit = tool.start(ctrl);
      if (this._main.getPicking().getMesh() && this.isUsingContinuous())
        this._sculptTimer = window.setInterval(tool._cbContinuous, 16.6);
      return canEdit;
    },
    end: function () {
      this.getCurrentTool().end();
      if (this._sculptTimer !== -1) {
        clearInterval(this._sculptTimer);
        this._sculptTimer = -1;
      }
    },
    preUpdate: function () {
      this.getCurrentTool().preUpdate(this.canBeContinuous());
    },
    update: function () {
      if (this.isUsingContinuous())
        return;
      this.getCurrentTool().update();
    },
    postRender: function () {
      this.getCurrentTool().postRender();
    },
    addSculptToScene: function (scene) {
      return this.getCurrentTool().addSculptToScene(scene);
    }
  };

  module.exports = Sculpt;
});
define('editing/Subdivision',['require','exports','module','misc/Utils'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');

  var Subdivision = {};
  Subdivision.LINEAR = false;

  //       v3
  //       /\
  //      /3T\ 
  //   m3/____\m2
  //    /\ 0T /\
  //   /1T\  /2T\
  //  /____\/____\ 
  // v1    m1    v2

  // v4____m3____v3
  // |     |     |
  // |     |     |
  // |m4___|c____|m2
  // |     |     |
  // |     |     |
  // |_____|_____|
  // v1   m1     v2

  // Helper class
  var OddVertexComputer = function (mesh, vArOut, cArOut, mArOut) {
    this._vArOut = vArOut;
    this._cArOut = cArOut;
    this._mArOut = mArOut;
    this._vAr = mesh.getVertices();
    this._cAr = mesh.getColors();
    this._mAr = mesh.getMaterials();
    this._eAr = mesh.getEdges();
    this._nbVertices = mesh.getNbVertices();
    this._tagEdges = new Int32Array(mesh.getNbEdges());
  };

  OddVertexComputer.prototype = {
    computeTriangleEdgeVertex: function (iv1, iv2, iv3, ide) {
      var vAr = this._vAr;
      var cAr = this._cAr;
      var mAr = this._mAr;
      var eAr = this._eAr;
      var vArOut = this._vArOut;
      var cArOut = this._cArOut;
      var mArOut = this._mArOut;
      var tagEdges = this._tagEdges;
      var id1 = iv1 * 3;
      var id2 = iv2 * 3;
      var idOpp = iv3 * 3;
      var testEdge = tagEdges[ide] - 1;
      var ivMid = testEdge === -1 ? this._nbVertices++ : testEdge;
      var idMid = ivMid * 3;
      var edgeValue = eAr[ide];
      if (edgeValue === 1 || edgeValue >= 3 || Subdivision.LINEAR) { // mid edge vertex or non manifold shit
        if (testEdge !== -1) // no need to recompute weird non manifold stuffs
          return ivMid;
        tagEdges[ide] = ivMid + 1;
        vArOut[idMid] = 0.5 * (vAr[id1] + vAr[id2]);
        vArOut[idMid + 1] = 0.5 * (vAr[id1 + 1] + vAr[id2 + 1]);
        vArOut[idMid + 2] = 0.5 * (vAr[id1 + 2] + vAr[id2 + 2]);

        cArOut[idMid] = 0.5 * (cAr[id1] + cAr[id2]);
        cArOut[idMid + 1] = 0.5 * (cAr[id1 + 1] + cAr[id2 + 1]);
        cArOut[idMid + 2] = 0.5 * (cAr[id1 + 2] + cAr[id2 + 2]);

        mArOut[idMid] = 0.5 * (mAr[id1] + mAr[id2]);
        mArOut[idMid + 1] = 0.5 * (mAr[id1 + 1] + mAr[id2 + 1]);
        mArOut[idMid + 2] = 0.5 * (mAr[id1 + 2] + mAr[id2 + 2]);
      } else if (testEdge === -1) { // new mid vertex
        tagEdges[ide] = ivMid + 1;
        vArOut[idMid] = 0.125 * vAr[idOpp] + 0.375 * (vAr[id1] + vAr[id2]);
        vArOut[idMid + 1] = 0.125 * vAr[idOpp + 1] + 0.375 * (vAr[id1 + 1] + vAr[id2 + 1]);
        vArOut[idMid + 2] = 0.125 * vAr[idOpp + 2] + 0.375 * (vAr[id1 + 2] + vAr[id2 + 2]);

        cArOut[idMid] = 0.125 * cAr[idOpp] + 0.375 * (cAr[id1] + cAr[id2]);
        cArOut[idMid + 1] = 0.125 * cAr[idOpp + 1] + 0.375 * (cAr[id1 + 1] + cAr[id2 + 1]);
        cArOut[idMid + 2] = 0.125 * cAr[idOpp + 2] + 0.375 * (cAr[id1 + 2] + cAr[id2 + 2]);

        mArOut[idMid] = 0.125 * mAr[idOpp] + 0.375 * (mAr[id1] + mAr[id2]);
        mArOut[idMid + 1] = 0.125 * mAr[idOpp + 1] + 0.375 * (mAr[id1 + 1] + mAr[id2 + 1]);
        mArOut[idMid + 2] = 0.125 * mAr[idOpp + 2] + 0.375 * (mAr[id1 + 2] + mAr[id2 + 2]);
      } else { // mid vertex already exists
        vArOut[idMid] += 0.125 * vAr[idOpp];
        vArOut[idMid + 1] += 0.125 * vAr[idOpp + 1];
        vArOut[idMid + 2] += 0.125 * vAr[idOpp + 2];

        cArOut[idMid] += 0.125 * cAr[idOpp];
        cArOut[idMid + 1] += 0.125 * cAr[idOpp + 1];
        cArOut[idMid + 2] += 0.125 * cAr[idOpp + 2];

        mArOut[idMid] += 0.125 * mAr[idOpp];
        mArOut[idMid + 1] += 0.125 * mAr[idOpp + 1];
        mArOut[idMid + 2] += 0.125 * mAr[idOpp + 2];
      }
      return ivMid;
    },
    computeQuadEdgeVertex: function (iv1, iv2, iv3, iv4, ide) {
      var vAr = this._vAr;
      var cAr = this._cAr;
      var mAr = this._mAr;
      var eAr = this._eAr;
      var vArOut = this._vArOut;
      var cArOut = this._cArOut;
      var mArOut = this._mArOut;
      var tagEdges = this._tagEdges;
      var id1 = iv1 * 3;
      var id2 = iv2 * 3;
      var idOpp = iv3 * 3;
      var idOpp2 = iv4 * 3;
      var testEdge = tagEdges[ide] - 1;
      var ivMid = testEdge === -1 ? this._nbVertices++ : testEdge;
      var idMid = ivMid * 3;
      var edgeValue = eAr[ide];
      if (edgeValue === 1 || edgeValue >= 3 || Subdivision.LINEAR) { // mid edge vertex or non manifold shit
        if (testEdge !== -1) // no need to recompute weird non manifold stuffs
          return ivMid;
        tagEdges[ide] = ivMid + 1;
        vArOut[idMid] = 0.5 * (vAr[id1] + vAr[id2]);
        vArOut[idMid + 1] = 0.5 * (vAr[id1 + 1] + vAr[id2 + 1]);
        vArOut[idMid + 2] = 0.5 * (vAr[id1 + 2] + vAr[id2 + 2]);

        cArOut[idMid] = 0.5 * (cAr[id1] + cAr[id2]);
        cArOut[idMid + 1] = 0.5 * (cAr[id1 + 1] + cAr[id2 + 1]);
        cArOut[idMid + 2] = 0.5 * (cAr[id1 + 2] + cAr[id2 + 2]);

        mArOut[idMid] = 0.5 * (mAr[id1] + mAr[id2]);
        mArOut[idMid + 1] = 0.5 * (mAr[id1 + 1] + mAr[id2 + 1]);
        mArOut[idMid + 2] = 0.5 * (mAr[id1 + 2] + mAr[id2 + 2]);
      } else if (testEdge === -1) { // new mid vertex
        tagEdges[ide] = ivMid + 1;
        vArOut[idMid] = 0.0625 * (vAr[idOpp] + vAr[idOpp2]) + 0.375 * (vAr[id1] + vAr[id2]);
        vArOut[idMid + 1] = 0.0625 * (vAr[idOpp + 1] + vAr[idOpp2 + 1]) + 0.375 * (vAr[id1 + 1] + vAr[id2 + 1]);
        vArOut[idMid + 2] = 0.0625 * (vAr[idOpp + 2] + vAr[idOpp2 + 2]) + 0.375 * (vAr[id1 + 2] + vAr[id2 + 2]);

        cArOut[idMid] = 0.0625 * (cAr[idOpp] + cAr[idOpp2]) + 0.375 * (cAr[id1] + cAr[id2]);
        cArOut[idMid + 1] = 0.0625 * (cAr[idOpp + 1] + cAr[idOpp2 + 1]) + 0.375 * (cAr[id1 + 1] + cAr[id2 + 1]);
        cArOut[idMid + 2] = 0.0625 * (cAr[idOpp + 2] + cAr[idOpp2 + 2]) + 0.375 * (cAr[id1 + 2] + cAr[id2 + 2]);

        mArOut[idMid] = 0.0625 * (mAr[idOpp] + mAr[idOpp2]) + 0.375 * (mAr[id1] + mAr[id2]);
        mArOut[idMid + 1] = 0.0625 * (mAr[idOpp + 1] + mAr[idOpp2 + 1]) + 0.375 * (mAr[id1 + 1] + mAr[id2 + 1]);
        mArOut[idMid + 2] = 0.0625 * (mAr[idOpp + 2] + mAr[idOpp2 + 2]) + 0.375 * (mAr[id1 + 2] + mAr[id2 + 2]);
      } else { // mid vertex already exists
        vArOut[idMid] += 0.0625 * (vAr[idOpp] + vAr[idOpp2]);
        vArOut[idMid + 1] += 0.0625 * (vAr[idOpp + 1] + vAr[idOpp2 + 1]);
        vArOut[idMid + 2] += 0.0625 * (vAr[idOpp + 2] + vAr[idOpp2 + 2]);

        cArOut[idMid] += 0.0625 * (cAr[idOpp] + cAr[idOpp2]);
        cArOut[idMid + 1] += 0.0625 * (cAr[idOpp + 1] + cAr[idOpp2 + 1]);
        cArOut[idMid + 2] += 0.0625 * (cAr[idOpp + 2] + cAr[idOpp2 + 2]);

        mArOut[idMid] += 0.0625 * (mAr[idOpp] + mAr[idOpp2]);
        mArOut[idMid + 1] += 0.0625 * (mAr[idOpp + 1] + mAr[idOpp2 + 1]);
        mArOut[idMid + 2] += 0.0625 * (mAr[idOpp + 2] + mAr[idOpp2 + 2]);
      }
      return ivMid;
    },
    computeFaceVertex: function (iv1, iv2, iv3, iv4) {
      var id1 = iv1 * 3;
      var id2 = iv2 * 3;
      var id3 = iv3 * 3;
      var id4 = iv4 * 3;
      var vAr = this._vAr;
      var cAr = this._cAr;
      var mAr = this._mAr;
      var vArOut = this._vArOut;
      var cArOut = this._cArOut;
      var mArOut = this._mArOut;
      var ivCen = this._nbVertices++;
      var idCen = ivCen * 3;
      vArOut[idCen] = 0.25 * (vAr[id1] + vAr[id2] + vAr[id3] + vAr[id4]);
      vArOut[idCen + 1] = 0.25 * (vAr[id1 + 1] + vAr[id2 + 1] + vAr[id3 + 1] + vAr[id4 + 1]);
      vArOut[idCen + 2] = 0.25 * (vAr[id1 + 2] + vAr[id2 + 2] + vAr[id3 + 2] + vAr[id4 + 2]);

      cArOut[idCen] = 0.25 * (cAr[id1] + cAr[id2] + cAr[id3] + cAr[id4]);
      cArOut[idCen + 1] = 0.25 * (cAr[id1 + 1] + cAr[id2 + 1] + cAr[id3 + 1] + cAr[id4 + 1]);
      cArOut[idCen + 2] = 0.25 * (cAr[id1 + 2] + cAr[id2 + 2] + cAr[id3 + 2] + cAr[id4 + 2]);

      mArOut[idCen] = 0.25 * (mAr[id1] + mAr[id2] + mAr[id3] + mAr[id4]);
      mArOut[idCen + 1] = 0.25 * (mAr[id1 + 1] + mAr[id2 + 1] + mAr[id3 + 1] + mAr[id4 + 1]);
      mArOut[idCen + 2] = 0.25 * (mAr[id1 + 2] + mAr[id2 + 2] + mAr[id3 + 2] + mAr[id4 + 2]);
      return ivCen;
    }
  };

  /** Even vertices smoothing */
  var applyEvenSmooth = function (baseMesh, even, colorOut, materialOut) {
    colorOut.set(baseMesh.getColors());
    materialOut.set(baseMesh.getMaterials());
    var vArOld = baseMesh.getVertices();
    var fArOld = baseMesh.getFaces();
    var eArOld = baseMesh.getEdges();
    var feArOld = baseMesh.getFaceEdges();
    var vertOnEdgeOld = baseMesh.getVerticesOnEdge();
    var vrvStartCount = baseMesh.getVerticesRingVertStartCount();
    var vertRingVert = baseMesh.getVerticesRingVert();
    var vrfStartCount = baseMesh.getVerticesRingFaceStartCount();
    var vertRingFace = baseMesh.getVerticesRingFace();
    var onlyTri = baseMesh.hasOnlyTriangles();
    var nbVerts = baseMesh.getNbVertices();

    for (var i = 0; i < nbVerts; ++i) {
      var j = i * 3;
      var avx = 0.0;
      var avy = 0.0;
      var avz = 0.0;
      var beta = 0.0;
      var alpha = 0.0;
      var k = 0;
      var id = 0;
      // edge vertex
      if (vertOnEdgeOld[i] || Subdivision.LINEAR) {
        var startF = vrfStartCount[i * 2];
        var endF = startF + vrfStartCount[i * 2 + 1];
        for (k = startF; k < endF; ++k) {
          var idFace = vertRingFace[k] * 4;
          var i1 = fArOld[idFace];
          var i2 = fArOld[idFace + 1];
          var i3 = fArOld[idFace + 2];
          var i4 = fArOld[idFace + 3];
          id = -1;
          if (i1 === i) {
            if (eArOld[feArOld[idFace]] === 1) id = i2;
            else if (eArOld[feArOld[i4 < 0 ? idFace + 2 : idFace + 3]] === 1) id = i4 < 0 ? i3 : i4;
          } else if (i2 === i) {
            if (eArOld[feArOld[idFace]] === 1) id = i1;
            else if (eArOld[feArOld[idFace + 1]] === 1) id = i3;
          } else if (i3 === i) {
            if (eArOld[feArOld[idFace + 1]] === 1) id = i2;
            else if (eArOld[feArOld[idFace + 2]] === 1) id = i4 < 0 ? i1 : i4;
          } else if (i4 === i) {
            if (eArOld[feArOld[idFace + 2]] === 1) id = i3;
            else if (eArOld[feArOld[idFace + 3]] === 1) id = i1;
          }
          if (id < 0) continue;
          id *= 3;
          avx += vArOld[id];
          avy += vArOld[id + 1];
          avz += vArOld[id + 2];
          beta++;
        }
        if (beta < 2) { // non manifold boring stuffs
          even[j] = vArOld[j];
          even[j + 1] = vArOld[j + 1];
          even[j + 2] = vArOld[j + 2];
        } else {
          beta = 0.25 / beta;
          alpha = 0.75;
          even[j] = vArOld[j] * alpha + avx * beta;
          even[j + 1] = vArOld[j + 1] * alpha + avy * beta;
          even[j + 2] = vArOld[j + 2] * alpha + avz * beta;
        }
        continue;
      }
      var start = vrvStartCount[i * 2];
      var count = vrvStartCount[i * 2 + 1];
      var end = start + count;
      // interior vertex
      for (k = start; k < end; ++k) {
        id = vertRingVert[k] * 3;
        avx += vArOld[id];
        avy += vArOld[id + 1];
        avz += vArOld[id + 2];
      }
      // only vertex tri
      if (onlyTri) {
        if (count === 6) {
          beta = 0.0625;
          alpha = 0.625;
        } else if (count === 3) { // warren weights
          beta = 0.1875;
          alpha = 0.4375;
        } else {
          beta = 0.375 / count;
          alpha = 0.625;
        }
        even[j] = vArOld[j] * alpha + avx * beta;
        even[j + 1] = vArOld[j + 1] * alpha + avy * beta;
        even[j + 2] = vArOld[j + 2] * alpha + avz * beta;
        continue;
      }
      var oppx = 0.0;
      var oppy = 0.0;
      var oppz = 0.0;
      var gamma = 0.0;

      var startFace = vrfStartCount[i * 2];
      var endFace = startFace + vrfStartCount[i * 2 + 1];
      var nbQuad = 0;
      for (k = startFace; k < endFace; ++k) {
        id = vertRingFace[k] * 4;
        var iv4 = fArOld[id + 3];
        if (iv4 < 0) continue;
        nbQuad++;
        var iv1 = fArOld[id];
        var iv2 = fArOld[id + 1];
        var iv3 = fArOld[id + 2];
        var ivOpp = 0;
        if (iv1 === i) ivOpp = iv3 * 3;
        else if (iv2 === i) ivOpp = iv4 * 3;
        else if (iv3 === i) ivOpp = iv1 * 3;
        else ivOpp = iv2 * 3;
        oppx += vArOld[ivOpp];
        oppy += vArOld[ivOpp + 1];
        oppz += vArOld[ivOpp + 2];
      }
      // interior vertex quad
      if (nbQuad === (endFace - startFace)) {
        if (count === 4) {
          alpha = 0.5625;
          beta = 0.09375;
          gamma = 0.015625;
        } else {
          beta = 1.5 / (count * count);
          gamma = 0.25 / (count * count);
          alpha = 1.0 - (beta + gamma) * count;
        }
        even[j] = vArOld[j] * alpha + avx * beta + oppx * gamma;
        even[j + 1] = vArOld[j + 1] * alpha + avy * beta + oppy * gamma;
        even[j + 2] = vArOld[j + 2] * alpha + avz * beta + oppz * gamma;
        continue;
      }
      // interior vertex tri
      if (nbQuad === 0) {
        if (count === 6) {
          beta = 0.0625;
          alpha = 0.625;
        } else if (count === 3) { // warren weights
          beta = 0.1875;
          alpha = 0.4375;
        } else {
          beta = 0.375 / count;
          alpha = 0.625;
        }
        even[j] = vArOld[j] * alpha + avx * beta;
        even[j + 1] = vArOld[j + 1] * alpha + avy * beta;
        even[j + 2] = vArOld[j + 2] * alpha + avz * beta;
        continue;
      }
      // interior tri-quad
      alpha = 1.0 / (1.0 + count * 0.5 + nbQuad * 0.25);
      beta = alpha * 0.5;
      gamma = alpha * 0.25;
      even[j] = vArOld[j] * alpha + avx * beta + oppx * gamma;
      even[j + 1] = vArOld[j + 1] * alpha + avy * beta + oppy * gamma;
      even[j + 2] = vArOld[j + 2] * alpha + avz * beta + oppz * gamma;
    }
  };

  /** Odd vertices smoothing */
  var applyOddSmooth = function (mesh, odds, colorOut, materialOut, fArOut) {
    var fAr = mesh.getFaces();
    var feAr = mesh.getFaceEdges();
    var oddComputer = new OddVertexComputer(mesh, odds, colorOut, materialOut);
    for (var i = 0, len = mesh.getNbFaces(); i < len; ++i) {
      var id = i * 4;
      var iv1 = fAr[id];
      var iv2 = fAr[id + 1];
      var iv3 = fAr[id + 2];
      var iv4 = fAr[id + 3];
      var ivMid1, ivMid2, ivMid3, ivMid4, ivCen;
      if (iv4 >= 0) {
        ivMid1 = oddComputer.computeQuadEdgeVertex(iv1, iv2, iv3, iv4, feAr[id]);
        ivMid2 = oddComputer.computeQuadEdgeVertex(iv2, iv3, iv4, iv1, feAr[id + 1]);
        ivMid3 = oddComputer.computeQuadEdgeVertex(iv3, iv4, iv1, iv2, feAr[id + 2]);
        ivMid4 = oddComputer.computeQuadEdgeVertex(iv4, iv1, iv2, iv3, feAr[id + 3]);
        ivCen = oddComputer.computeFaceVertex(iv1, iv2, iv3, iv4);
      } else {
        ivMid1 = oddComputer.computeTriangleEdgeVertex(iv1, iv2, iv3, feAr[id]);
        ivMid2 = oddComputer.computeTriangleEdgeVertex(iv2, iv3, iv1, feAr[id + 1]);
        ivMid3 = oddComputer.computeTriangleEdgeVertex(iv3, iv1, iv2, feAr[id + 2]);
      }
      if (!fArOut)
        continue;

      id *= 4;
      if (iv4 >= 0) {
        fArOut[id + 1] = fArOut[id + 4] = ivMid1;
        fArOut[id + 6] = fArOut[id + 9] = ivMid2;
        fArOut[id + 11] = fArOut[id + 14] = ivMid3;
        fArOut[id + 3] = fArOut[id + 12] = ivMid4;
        fArOut[id + 2] = fArOut[id + 7] = fArOut[id + 8] = fArOut[id + 13] = ivCen;
        fArOut[id] = iv1;
        fArOut[id + 5] = iv2;
        fArOut[id + 10] = iv3;
        fArOut[id + 15] = iv4;
      } else {
        fArOut[id] = fArOut[id + 5] = fArOut[id + 8] = ivMid1;
        fArOut[id + 1] = fArOut[id + 10] = fArOut[id + 12] = ivMid2;
        fArOut[id + 2] = fArOut[id + 6] = fArOut[id + 14] = ivMid3;
        fArOut[id + 3] = fArOut[id + 7] = fArOut[id + 11] = fArOut[id + 15] = -1;
        fArOut[id + 4] = iv1;
        fArOut[id + 9] = iv2;
        fArOut[id + 13] = iv3;
      }
    }
    return oddComputer._tagEdges;
  };

  /** Subdivide tex coords mesh */
  var computeTexCoords = function (mesh, newMesh, tagEdges) {
    var newNbVertices = newMesh.getNbVertices();
    var startCount = new Uint32Array(newNbVertices * 2);
    startCount.set(mesh.getVerticesDuplicateStartCount());

    var fArOld = mesh.getFaces();
    var fArUVOld = mesh.getFacesTexCoord();

    var bound = newMesh.getNbFaces() * 3;
    var uvArOld = mesh.getTexCoords();
    var uvAr = new Float32Array(Utils.getMemory(bound * 4 * 2), 0, bound * 2);

    var i = 0;
    var len = mesh.getNbVertices();
    var offset = newNbVertices - len;
    // reorder even duplicates vertex indices
    for (i = 0; i < len; ++i) {
      var start = startCount[i * 2];
      if (start > 0)
        startCount[i * 2] = start + offset;
    }
    uvAr.set(uvArOld);
    uvAr.set(uvArOld.subarray(len * 2), (len + offset) * 2);
    var nbTexCoords = mesh.getNbTexCoords();

    var acc = offset + nbTexCoords;
    var feAr = mesh.getFaceEdges();

    // compute uv for new odd vertices
    var tagUVMin = new Uint32Array(tagEdges.length);
    var tagUVMax = new Uint32Array(tagEdges.length);
    len = fArOld.length;
    for (i = 0; i < len; ++i) {
      var ide = feAr[i];
      if (ide === -1)
        continue;
      var iNext = (i + 1) % 4 === 0 ? i - 3 : i + 1;
      var iuv1 = fArUVOld[i];
      var iuv2 = fArUVOld[iNext];
      if (iuv2 < 0)
        iuv2 = fArUVOld[i - 2];
      var tg = tagEdges[ide] - 1;

      // test if we already processed this edge
      var tgMax = tagUVMax[ide];
      var iuvMax = iuv1 > iuv2 ? iuv1 : iuv2;
      var iuvMin = iuv1 < iuv2 ? iuv1 : iuv2;
      if (tgMax !== 0) {
        // test if we already processed this UV edge or if it's a duplicate
        if (tgMax !== iuvMax || tagUVMin[ide] !== iuvMin) {
          uvAr[acc * 2] = (uvArOld[iuv1 * 2] + uvArOld[iuv2 * 2]) * 0.5;
          uvAr[acc * 2 + 1] = (uvArOld[iuv1 * 2 + 1] + uvArOld[iuv2 * 2 + 1]) * 0.5;
          startCount[tg * 2] = acc++;
          startCount[tg * 2 + 1] = 1;
        }
      } else {
        // first time we process this edge
        uvAr[tg * 2] = (uvArOld[iuv1 * 2] + uvArOld[iuv2 * 2]) * 0.5;
        uvAr[tg * 2 + 1] = (uvArOld[iuv1 * 2 + 1] + uvArOld[iuv2 * 2 + 1]) * 0.5;
        tagUVMin[ide] = iuvMin;
        tagUVMax[ide] = iuvMax;
      }
    }
    var texCoords = new Float32Array(acc * 2);
    texCoords.set(uvAr.subarray(0, acc * 2));

    newMesh.setTexCoords(texCoords);
    newMesh.setVerticesDuplicateStartCount(startCount);

    computeFaceTexCoords(mesh, newMesh, tagEdges);
  };

  /** Computes uv faces and uv coordinates for center vertices */
  var computeFaceTexCoords = function (mesh, newMesh, tagEdges) {
    var fArUVOld = mesh.getFacesTexCoord();
    var fAr = newMesh.getFaces();
    var fArUV = new Int32Array(fAr.length);
    var feAr = mesh.getFaceEdges();

    var nbVertices = mesh.getNbVertices();
    var offset = newMesh.getNbVertices() - nbVertices;

    var startCount = newMesh.getVerticesDuplicateStartCount();
    var uvAr = newMesh.getTexCoords();
    for (var i = 0, len = mesh.getNbFaces(); i < len; ++i) {
      var id = i * 4;
      var iuv1 = fArUVOld[id];
      var iuv2 = fArUVOld[id + 1];
      var iuv3 = fArUVOld[id + 2];
      var iuv4 = fArUVOld[id + 3];
      if (iuv1 >= nbVertices) iuv1 += offset;
      if (iuv2 >= nbVertices) iuv2 += offset;
      if (iuv3 >= nbVertices) iuv3 += offset;
      if (iuv4 >= nbVertices) iuv4 += offset;

      var ide = feAr[id];
      var tg1 = tagEdges[ide] - 1;
      if (tg1 < 0)
        tg1 = startCount[(-tg1 - 1) * 2];
      else if (startCount[tg1 * 2] > 0)
        tagEdges[ide] = -tg1;

      ide = feAr[id + 1];
      var tg2 = tagEdges[ide] - 1;
      if (tg2 < 0)
        tg2 = startCount[(-tg2 - 1) * 2];
      else if (startCount[tg2 * 2] > 0)
        tagEdges[ide] = -tg2;

      ide = feAr[id + 2];
      var tg3 = tagEdges[ide] - 1;
      if (tg3 < 0)
        tg3 = startCount[(-tg3 - 1) * 2];
      else if (startCount[tg3 * 2] > 0)
        tagEdges[ide] = -tg3;

      id *= 4;
      if (iuv4 >= 0) {
        ide = feAr[i * 4 + 3];
        var tg4 = tagEdges[ide] - 1;
        if (tg4 < 0)
          tg4 = startCount[(-tg4 - 1) * 2];
        else if (startCount[tg4 * 2] > 0)
          tagEdges[ide] = -tg4;

        fArUV[id + 1] = fArUV[id + 4] = tg1;
        fArUV[id + 6] = fArUV[id + 9] = tg2;
        fArUV[id + 11] = fArUV[id + 14] = tg3;
        fArUV[id + 3] = fArUV[id + 12] = tg4;
        fArUV[id + 2] = fArUV[id + 7] = fArUV[id + 8] = fArUV[id + 13] = fAr[id + 2];
        fArUV[id] = iuv1;
        fArUV[id + 5] = iuv2;
        fArUV[id + 10] = iuv3;
        fArUV[id + 15] = iuv4;

        // even averaging for center quad
        var im = fAr[id + 2] * 2;
        uvAr[im] = (uvAr[iuv1 * 2] + uvAr[iuv2 * 2] + uvAr[iuv3 * 2] + uvAr[iuv4 * 2]) * 0.25;
        uvAr[im + 1] = (uvAr[iuv1 * 2 + 1] + uvAr[iuv2 * 2 + 1] + uvAr[iuv3 * 2 + 1] + uvAr[iuv4 * 2 + 1]) * 0.25;
      } else {
        fArUV[id] = fArUV[id + 5] = fArUV[id + 8] = tg1;
        fArUV[id + 1] = fArUV[id + 10] = fArUV[id + 12] = tg2;
        fArUV[id + 2] = fArUV[id + 6] = fArUV[id + 14] = tg3;
        fArUV[id + 3] = fArUV[id + 7] = fArUV[id + 11] = fArUV[id + 15] = -1;
        fArUV[id + 4] = iuv1;
        fArUV[id + 9] = iuv2;
        fArUV[id + 13] = iuv3;
      }
    }

    newMesh.setFacesTexCoord(fArUV);
  };

  /** Apply a complete subdivision (by updating the topology) */
  Subdivision.fullSubdivision = function (baseMesh, newMesh) {
    var nbVertices = baseMesh.getNbVertices() + baseMesh.getNbEdges() + baseMesh.getNbQuads();
    newMesh.setVertices(new Float32Array(nbVertices * 3));
    newMesh.setColors(new Float32Array(nbVertices * 3));
    newMesh.setMaterials(new Float32Array(nbVertices * 3));
    newMesh.setFaces(new Int32Array(baseMesh.getNbFaces() * 4 * 4));
    applyEvenSmooth(baseMesh, newMesh.getVertices(), newMesh.getColors(), newMesh.getMaterials());
    var tags = applyOddSmooth(baseMesh, newMesh.getVertices(), newMesh.getColors(), newMesh.getMaterials(), newMesh.getFaces());
    if (baseMesh.hasUV())
      computeTexCoords(baseMesh, newMesh, tags);
    newMesh.allocateArrays();
  };

  /** Apply subdivision without topology computation */
  Subdivision.partialSubdivision = function (baseMesh, vertOut, colorOut, materialOut) {
    applyEvenSmooth(baseMesh, vertOut, colorOut, materialOut);
    applyOddSmooth(baseMesh, vertOut, colorOut, materialOut);
  };

  module.exports = Subdivision;
});
define('files/ImportOBJ',['require','exports','module','mesh/Mesh'],function (require, exports, module) {

  'use strict';

  var Mesh = require('mesh/Mesh');

  var Import = {};

  /** Import OBJ file */
  Import.importOBJ = function (data, gl) {
    var meshes = [];
    var vAr = [];
    var cAr = [];
    var cArMrgb = [];
    var mAr = [];
    var mArMat = [];
    var texAr = [];
    var fAr = [];
    var uvfAr = [];
    var offsetVertices = 0;
    var offsetTexCoords = 0;
    var nbVertices = 0;
    var nbTexCoords = 0;
    var lines = data.split('\n');
    var split = [];
    var inv255 = 1.0 / 255;
    var nbLength = lines.length;
    for (var i = 0; i < nbLength; ++i) {
      var line = lines[i].trim();
      if (line.startsWith('o ')) {
        if (meshes.length > 0) {
          Import.initMeshOBJ(meshes[meshes.length - 1], vAr, fAr, cAr, mAr, texAr, uvfAr, cArMrgb, mArMat);
          offsetVertices = nbVertices;
          offsetTexCoords = nbTexCoords;
        }
        meshes.push(new Mesh(gl));
      } else if (line.startsWith('v ')) {
        split = line.split(/\s+/);
        vAr.push(parseFloat(split[1]), parseFloat(split[2]), parseFloat(split[3]));
        if (split[4])
          cAr.push(parseFloat(split[4]), parseFloat(split[5]), parseFloat(split[6]));
        ++nbVertices;
      } else if (line.startsWith('#MRGB ')) {
        // zbrush-like vertex color
        split = line.split(/\s+/);
        var blockMRGB = split[1];
        for (var m = 2, mlen = blockMRGB.length; m < mlen; m += 8) {
          var hex = parseInt(blockMRGB.substr(m, 6), 16);
          cArMrgb.push((hex >> 16) * inv255, (hex >> 8 & 0xff) * inv255, (hex & 0xff) * inv255);
        }
      } else if (line.startsWith('#MAT ')) {
        // zbrush-like vertex material
        split = line.split(/\s+/);
        var blockMAT = split[1];
        for (var n = 0, nlen = blockMAT.length; n < nlen; n += 6) {
          var hex2 = parseInt(blockMAT.substr(n, 6), 16);
          mArMat.push((hex2 >> 16) * inv255, (hex2 >> 8 & 0xff) * inv255, (hex2 & 0xff) * inv255);
        }
      } else if (line.startsWith('vt ')) {
        split = line.split(/\s+/);
        texAr.push(parseFloat(split[1]), parseFloat(split[2]));
        ++nbTexCoords;
      } else if (line.startsWith('f ')) {
        split = line.split(/\s+/);
        var nbVerts = split.length - 1;
        if (nbVerts < 3) // at least 3 vertices
          continue;

        var nbPrim = Math.ceil(nbVerts / 2) - 1;
        // quandrangulate polygons (+ 1 tri)
        for (var j = 0; j < nbPrim; ++j) {
          var id1 = j + 1;
          var id2 = j + 2;
          var id3 = nbVerts - id1;
          var id4 = nbVerts - j;
          if (id3 === id2) {
            id3 = id4;
            id4 = -1;
          }

          var sp1 = split[id1].split('/');
          var sp2 = split[id2].split('/');
          var sp3 = split[id3].split('/');
          var isQuad = id4 >= 0;
          var sp4;
          if (isQuad) sp4 = split[id4].split('/');

          var iv1 = parseInt(sp1[0], 10);
          var iv2 = parseInt(sp2[0], 10);
          var iv3 = parseInt(sp3[0], 10);
          var iv4 = isQuad ? parseInt(sp4[0], 10) : undefined;
          if (isQuad && (iv4 === iv1 || iv4 === iv2 || iv4 === iv3))
            continue;
          if (iv1 === iv2 || iv1 === iv3 || iv2 === iv3)
            continue;
          iv1 = (iv1 < 0 ? iv1 + nbVertices : iv1 - 1) - offsetVertices;
          iv2 = (iv2 < 0 ? iv2 + nbVertices : iv2 - 1) - offsetVertices;
          iv3 = (iv3 < 0 ? iv3 + nbVertices : iv3 - 1) - offsetVertices;
          if (isQuad) iv4 = (iv4 < 0 ? iv4 + nbVertices : iv4 - 1) - offsetVertices;
          fAr.push(iv1, iv2, iv3, isQuad ? iv4 : -1);

          if (sp1[1]) {
            var uv1 = parseInt(sp1[1], 10);
            var uv2 = parseInt(sp2[1], 10);
            var uv3 = parseInt(sp3[1], 10);
            var uv4 = isQuad ? parseInt(sp4[1], 10) : undefined;
            uv1 = (uv1 < 0 ? uv1 + nbTexCoords : uv1 - 1) - offsetTexCoords;
            uv2 = (uv2 < 0 ? uv2 + nbTexCoords : uv2 - 1) - offsetTexCoords;
            uv3 = (uv3 < 0 ? uv3 + nbTexCoords : uv3 - 1) - offsetTexCoords;
            if (isQuad) uv4 = (uv4 < 0 ? uv4 + nbTexCoords : uv4 - 1) - offsetTexCoords;
            uvfAr.push(uv1, uv2, uv3, isQuad ? uv4 : -1);
          }
        }
      }
    }
    if (meshes.length === 0) meshes[0] = new Mesh(gl);
    Import.initMeshOBJ(meshes[meshes.length - 1], vAr, fAr, cAr, mAr, texAr, uvfAr, cArMrgb, mArMat);
    return meshes;
  };

  Import.initMeshOBJ = function (mesh, vAr, fAr, cAr, mAr, texAr, uvfAr, cArMrgb, mArMat) {
    mesh.setVertices(new Float32Array(vAr));
    mesh.setFaces(new Int32Array(fAr));

    if (cArMrgb.length === vAr.length) mesh.setColors(new Float32Array(cArMrgb));
    else if (cAr.length === vAr.length) mesh.setColors(new Float32Array(cAr));

    if (mArMat.length === vAr.length) mesh.setMaterials(new Float32Array(mArMat));
    else if (mAr.length === vAr.length) mesh.setMaterials(new Float32Array(mAr));

    if (texAr.length > 0 && uvfAr.length === fAr.length)
      mesh.initTexCoordsDataFromOBJData(texAr, uvfAr);

    vAr.length = fAr.length = 0;
    cArMrgb.length = cAr.length = 0;
    mArMat.length = mAr.length = 0;
    texAr.length = uvfAr.length = 0;
  };

  module.exports = Import;
});
define('files/ExportSGL',['require','exports','module','render/shaders/ShaderBase'],function (require, exports, module) {

  'use strict';

  var ShaderBase = require('render/shaders/ShaderBase');

  var invert = function (obj) {
    var keys = Object.keys(obj);
    var inv = {};
    for (var i = 0, nbkeys = keys.length; i < nbkeys; ++i)
      inv[obj[keys[i]]] = keys[i];
    return inv;
  };

  var stringToInt = {};
  var intToString = {};
  stringToInt.MODE_TO_INT = {
    ORBIT: 0,
    SPHERICAL: 1,
    PLANE: 2
  };
  intToString.INT_TO_MODE = invert(stringToInt.MODE_TO_INT);

  stringToInt.PROJECTION_TO_INT = {
    PERSPECTIVE: 0,
    ORTHOGRAPHIC: 1
  };
  intToString.INT_TO_PROJECTION = invert(stringToInt.PROJECTION_TO_INT);

  stringToInt.SHADER_TO_INT = {
    PBR: 0,
    NORMAL: 2,
    UV: 4,
    MATCAP: 5
  };
  intToString.INT_TO_SHADER = invert(stringToInt.SHADER_TO_INT);

  var Export = {};
  Export.intToString = intToString;
  Export.stringToInt = stringToInt;

  // current version 2
  //
  // Version (u32)

  // ShowGrid (u32) .v2
  // ShowMirror (u32) .v2
  // ShowContour (u32) .v2

  // CameraProj (u32) .v2
  // CameraMode (u32) .v2
  // CameraFov (f32) .v2
  // CameraPivot (u32) .v2

  // nbMeshes (u32)

  // Shader (u32) .v2
  // Matcap (u32) .v2
  // ShowWireframe (u32) .v2;
  // FlatShading (u32) .v2;
  // Alpha (f32) .v2

  // Center (f32 * 3)
  // Matrix (f32 * 16)
  // Scale (f32)

  // NbVertices (u32)
  // vertices (f32 * 3 * nbVertices)

  // nbColors (u32) => 0 or nbVertices
  // colors (f32 * 3 * nbVertices)

  // nbMaterials (u32) => 0 or nbVertices
  // materials (f32 * 3 * nbVertices)

  // NbFaces (u32)
  // faces (i32 * 4 * nbFaces)

  // NbTexCoords (u32) => 0 means no UV
  // texcoords (f32 * 2 * nbTexCoords)

  // NbFacesTexCoords (u32) => 0 or nbFaces
  // faces (i32 * 4 * nbFaces)
  //
  /** Export SGL (sculptgl) file */

  Export.exportSGLAsArrayBuffer = function (meshes, main) {
    return Export.exportSGL(meshes, main, true);
  };
  Export.exportSGL = function (meshes, main, returnArrayBuffer) {
    var nbMeshes = meshes.length;

    var bytePerMesh = 3 + 16 + 1 + 6 + 5;
    var nbBytes = 4 * (1 + 3 + 4 + 1 + nbMeshes * bytePerMesh);
    var i = 0;
    var mesh;
    for (i = 0; i < nbMeshes; ++i) {
      mesh = meshes[i];
      nbBytes += mesh.getNbVertices() * 4 * 3;
      if (mesh.getColors())
        nbBytes += mesh.getNbVertices() * 4 * 3;
      if (mesh.getMaterials())
        nbBytes += mesh.getNbVertices() * 4 * 3;
      nbBytes += mesh.getNbFaces() * 4 * 4;
      if (mesh.hasUV()) {
        nbBytes += mesh.getNbTexCoords() * 4 * 2;
        nbBytes += mesh.getNbFaces() * 4 * 4;
      }
    }

    var buffer = new ArrayBuffer(nbBytes);
    var f32a = new Float32Array(buffer);
    var u32a = new Uint32Array(buffer);
    var i32a = new Int32Array(buffer);
    var off = 0;
    u32a[off++] = 2;

    // misc stuffs
    u32a[off++] = main._showGrid;
    u32a[off++] = ShaderBase.showSymmetryLine;
    u32a[off++] = main._showContour;

    // camera stuffs
    var cam = main.getCamera();
    u32a[off++] = stringToInt.PROJECTION_TO_INT[cam.getProjectionType()];
    u32a[off++] = stringToInt.MODE_TO_INT[cam.getMode()];
    f32a[off++] = cam.getFov();
    u32a[off++] = cam.getUsePivot();

    // save meshes
    u32a[off++] = nbMeshes;
    for (i = 0; i < nbMeshes; ++i) {
      mesh = meshes[i];

      // shader + matcap + wire + alpha + flat 
      u32a[off++] = stringToInt.SHADER_TO_INT[mesh.getShaderName()];
      u32a[off++] = mesh.getMatcap();
      u32a[off++] = mesh.getShowWireframe();
      u32a[off++] = mesh.getFlatShading();
      f32a[off++] = mesh.getOpacity();

      // center + matrix + scale
      f32a.set(mesh.getCenter(), off);
      off += 3;
      f32a.set(mesh.getMatrix(), off);
      off += 16;
      f32a[off++] = mesh.getScale();

      // vertices
      var nbVertices = mesh.getNbVertices();
      u32a[off++] = nbVertices;
      f32a.set(mesh.getVertices(), off);
      off += nbVertices * 3;

      // colors
      var nbColors = mesh.getColors() ? nbVertices : 0;
      u32a[off++] = nbColors;
      if (nbColors > 0)
        f32a.set(mesh.getColors().subarray(0, nbVertices * 3), off);
      off += nbColors * 3;

      // materials
      var nbMaterials = mesh.getMaterials() ? nbVertices : 0;
      u32a[off++] = nbMaterials;
      if (nbMaterials > 0)
        f32a.set(mesh.getMaterials().subarray(0, nbVertices * 3), off);
      off += nbMaterials * 3;

      // faces
      var nbFaces = mesh.getNbFaces();
      u32a[off++] = nbFaces;
      i32a.set(mesh.getFaces().subarray(0, nbFaces * 4), off);
      off += nbFaces * 4;

      var hasUV = mesh.hasUV();
      // uvs
      var nbTexCoords = mesh.getNbTexCoords();
      u32a[off++] = hasUV ? nbTexCoords : 0;
      if (hasUV) {
        f32a.set(mesh.getTexCoords().subarray(0, nbTexCoords * 2), off);
        off += nbTexCoords * 2;
      }

      // face uvs
      u32a[off++] = hasUV ? nbFaces : 0;
      if (hasUV) {
        i32a.set(mesh.getFacesTexCoord().subarray(0, nbFaces * 4), off);
        off += nbFaces * 4;
      }
    }

    if (returnArrayBuffer)
      return buffer;

    var data = new DataView(buffer, 0, off * 4);
    return new Blob([data]);
  };

  module.exports = Export;
});
define('files/ImportSGL',['require','exports','module','mesh/Mesh','files/ExportSGL','render/shaders/ShaderBase'],function (require, exports, module) {

  'use strict';

  var Mesh = require('mesh/Mesh');
  var ExportSGL = require('files/ExportSGL');
  var ShaderBase = require('render/shaders/ShaderBase');

  var intToString = ExportSGL.intToString;

  var Import = {};

  // see ExportSGL for file description
  //
  /** Import SGL file */
  Import.importSGL = function (buffer, gl, main) {
    var f32a = new Float32Array(buffer);
    var u32a = new Uint32Array(buffer);
    var i32a = new Int32Array(buffer);

    var off = 0;
    var version = u32a[off++];
    if (version > 2)
      return [];

    // camera stuffs
    if (version >= 2) {
      main._showGrid = u32a[off++];
      ShaderBase.showSymmetryLine = u32a[off++];
      main._showContour = u32a[off++];

      var cam = main.getCamera();
      cam.setProjectionType(intToString.INT_TO_PROJECTION[u32a[off++]]);
      cam.setMode(intToString.INT_TO_MODE[u32a[off++]]);
      cam.setFov(f32a[off++]);
      cam.setUsePivot(u32a[off++]);
    }

    var nbMeshes = u32a[off++];
    var meshes = new Array(nbMeshes);
    for (var i = 0; i < nbMeshes; ++i) {
      var mesh = meshes[i] = new Mesh(gl);

      // shader + matcap + wire + alpha + flat 
      if (version >= 2) {
        var render = mesh.getRender();
        // we don't have the geometry buffer and data yet so
        // we don't want to call updateBuffers (so no call to )
        render._shaderName = intToString.INT_TO_SHADER[u32a[off++]];
        render.setMatcap(u32a[off++]);
        render._showWireframe = u32a[off++];
        render._flatShading = u32a[off++];
        render.setOpacity(f32a[off++]);
      }

      // center matrix and scale
      mesh.getCenter().set(f32a.subarray(off, off + 3));
      off += 3;
      mesh.getMatrix().set(f32a.subarray(off, off + 16));
      off += 16;
      off++; // scale

      // vertices
      var nbElts = u32a[off++];
      mesh.setVertices(f32a.subarray(off, off + nbElts * 3));
      off += nbElts * 3;

      // colors
      nbElts = u32a[off++];
      if (nbElts > 0)
        mesh.setColors(f32a.subarray(off, off + nbElts * 3));
      off += nbElts * 3;

      // materials
      nbElts = u32a[off++];
      if (nbElts > 0)
        mesh.setMaterials(f32a.subarray(off, off + nbElts * 3));
      off += nbElts * 3;

      // faces
      nbElts = u32a[off++];
      mesh.setFaces(i32a.subarray(off, off + nbElts * 4));
      off += nbElts * 4;

      // uvs
      nbElts = u32a[off++];
      var uv = null;
      if (nbElts)
        uv = f32a.subarray(off, off + nbElts * 2);
      off += nbElts * 2;

      // face uvs
      nbElts = u32a[off++];
      var fuv = null;
      if (nbElts)
        fuv = i32a.subarray(off, off + nbElts * 4);
      off += nbElts * 4;

      if (uv && fuv)
        mesh.initTexCoordsDataFromOBJData(uv, fuv);
    }

    return meshes;
  };

  module.exports = Import;
});
define('files/ImportPLY',['require','exports','module','mesh/Mesh','misc/Utils'],function (require, exports, module) {

  'use strict';

  var Mesh = require('mesh/Mesh');
  var Utils = require('misc/Utils');

  var Import = {};

  var typeToOctet = function (type) {
    switch (type) {
    case 'uchar':
    case 'char':
    case 'int8':
    case 'uint8':
      return 1;
    case 'ushort':
    case 'short':
    case 'int16':
    case 'uint16':
      return 2;
    case 'uint':
    case 'int':
    case 'float':
    case 'int32':
    case 'uint32':
    case 'float32':
      return 4;
    case 'double':
    case 'float64':
      return 8;
    default:
      return 0;
    }
  };

  var getParseFunc = function (type, isFloat) {
    var fac = isFloat ? 1.0 / 255.0 : 1;
    switch (type) {
    case 'char':
    case 'uchar':
    case 'short':
    case 'ushort':
    case 'int':
    case 'uint':
    case 'int8':
    case 'uint8':
    case 'int16':
    case 'uint16':
    case 'int32':
    case 'uint32':
      return function (n) {
        return parseInt(n, 10) * fac;
      };
    case 'float':
    case 'double':
    case 'float32':
    case 'float64':
      return parseFloat;
    default:
      return function (n) {
        return n;
      };
    }
  };

  var getBinaryRead = function (dview, prop, isFloat) {
    var fac = isFloat ? 1.0 / 255.0 : 1;
    var offset = prop.offsetOctet;
    switch (prop.type) {
    case 'int8':
    case 'char':
      return function (off) {
        return dview.getInt8(off + offset) * fac;
      };
    case 'uint8':
    case 'uchar':
      return function (off) {
        return dview.getUint8(off + offset) * fac;
      };
    case 'int16':
    case 'short':
      return function (off) {
        return dview.getInt16(off + offset, true) * fac;
      };
    case 'uint16':
    case 'ushort':
      return function (off) {
        return dview.getUint16(off + offset, true) * fac;
      };
    case 'int32':
    case 'int':
      return function (off) {
        return dview.getInt32(off + offset, true) * fac;
      };
    case 'uint32':
    case 'uint':
      return function (off) {
        return dview.getUint32(off + offset, true) * fac;
      };
    case 'float32':
    case 'float':
      return function (off) {
        return dview.getFloat32(off + offset, true);
      };
    case 'float64':
    case 'double':
      return function (off) {
        return dview.getFloat64(off + offset, true);
      };
    }
  };

  var readHeader = function (buffer) {
    var data = Utils.ab2str(buffer);
    var lines = data.split('\n');

    var infos = {
      isBinary: false,
      start: 0,
      elements: [],
      lines: lines,
      buffer: buffer,
      vertices: null,
      faces: null,
      colors: null,
      offsetLine: 0,
      offsetOctet: 0
    };

    var i = 0;
    var split;

    while (true) {
      var line = lines[i++];
      infos.offsetOctet += line.length + 1;
      infos.offsetLine = i;

      line = line.trim();

      if (line.startsWith('format binary')) {
        infos.isBinary = true;

      } else if (line.startsWith('element')) {

        split = line.split(/\s+/);
        infos.elements.push({
          name: split[1],
          count: parseInt(split[2], 10),
          properties: []
        });

      } else if (line.startsWith('property')) {

        split = line.split(/\s+/);
        var isList = split[1] === 'list';
        infos.elements[infos.elements.length - 1].properties.push({
          type: split[isList ? 2 : 1],
          type2: isList ? split[3] : undefined,
          name: split[isList ? 4 : 2]
        });

      } else if (line.startsWith('end_header')) {

        break;
      }
    }

    return infos;
  };

  ///////////////
  // READ VERTEX
  ///////////////
  var cleanVertexElement = function (element, infos) {
    var props = element.properties;
    var objProperties = element.objProperties = {};
    element.offsetOctet = 0;

    for (var i = 0, nbProps = props.length; i < nbProps; ++i) {
      var prop = props[i];
      var objProp = objProperties[prop.name] = {};
      objProp.type = prop.type;
      if (infos.isBinary) {
        objProp.offsetOctet = element.offsetOctet;
        element.offsetOctet += typeToOctet(prop.type);
      } else {
        objProp.id = i;
      }
    }
  };

  var readAsciiVertex = function (element, infos, vAr, cAr) {

    var count = element.count;
    var lines = infos.lines;
    var props = element.objProperties;
    var offsetLine = infos.offsetLine;

    var parseX = getParseFunc(props.x.type, true);
    var parseY = getParseFunc(props.y.type, true);
    var parseZ = getParseFunc(props.z.type, true);

    var parseR, parseG, parseB;
    if (props.red) parseR = getParseFunc(props.red.type, true);
    if (props.green) parseG = getParseFunc(props.green.type, true);
    if (props.blue) parseB = getParseFunc(props.blue.type, true);

    for (var i = 0; i < count; ++i) {
      var id = i * 3;
      var split = lines[offsetLine + i].trim().split(/\s+/);
      vAr[id] = parseX(split[props.x.id]);
      vAr[id + 1] = parseY(split[props.y.id]);
      vAr[id + 2] = parseZ(split[props.z.id]);
      if (parseR) cAr[id] = parseR(split[props.red.id]);
      if (parseG) cAr[id + 1] = parseG(split[props.green.id]);
      if (parseB) cAr[id + 2] = parseB(split[props.blue.id]);
    }

    infos.offsetLine += count;
  };

  var readBinaryVertex = function (element, infos, vAr, cAr) {
    var count = element.count;
    var props = element.objProperties;
    var offsetOctet = element.offsetOctet;
    var lenOctet = offsetOctet * count;

    var dview = new DataView(infos.buffer, infos.offsetOctet, lenOctet);
    var readX = getBinaryRead(dview, props.x, true);
    var readY = getBinaryRead(dview, props.y, true);
    var readZ = getBinaryRead(dview, props.z, true);

    var readR, readG, readB;
    if (props.red) readR = getBinaryRead(dview, props.red, true);
    if (props.green) readG = getBinaryRead(dview, props.green, true);
    if (props.blue) readB = getBinaryRead(dview, props.blue, true);

    for (var i = 0; i < count; ++i) {
      var id = i * 3;
      var offset = i * offsetOctet;

      vAr[id] = readX(offset);
      vAr[id + 1] = readY(offset);
      vAr[id + 2] = readZ(offset);
      if (readR) cAr[id] = readR(offset);
      if (readG) cAr[id + 1] = readG(offset);
      if (readB) cAr[id + 2] = readB(offset);
    }

    infos.offsetOctet += lenOctet;
  };

  var readElementVertex = function (element, infos) {

    cleanVertexElement(element, infos);

    var vAr = infos.vertices = new Float32Array(element.count * 3);
    var cAr;
    var props = element.objProperties;
    if (props.red || props.green || props.blue)
      cAr = infos.colors = new Float32Array(element.count * 3);

    if (!infos.isBinary)
      readAsciiVertex(element, infos, vAr, cAr);
    else
      readBinaryVertex(element, infos, vAr, cAr);
  };

  /////////////
  // READ INDEX
  /////////////
  var readAsciiIndex = function (element, infos, fAr) {

    var count = element.count;
    var lines = infos.lines;
    var offsetLine = infos.offsetLine;
    var obj = element.properties[0];

    var parseCount = getParseFunc(obj.type);
    var parseIndex = getParseFunc(obj.type2);

    var idFace = 0;
    for (var i = 0; i < count; ++i) {
      var split = lines[offsetLine + i].trim().split(/\s+/);
      var nbVert = parseCount(split[0]);
      if (nbVert !== 3 && nbVert !== 4)
        continue;

      fAr[idFace] = parseIndex(split[1]);
      fAr[idFace + 1] = parseIndex(split[2]);
      fAr[idFace + 2] = parseIndex(split[3]);
      fAr[idFace + 3] = nbVert === 4 ? parseIndex(split[4]) : -1;
      idFace += 4;
    }

    infos.offsetLine += count;
  };

  var readBinaryIndex = function (element, infos, fAr) {
    var count = element.count;
    var obj = element.properties[0];

    var dview = new DataView(infos.buffer, infos.offsetOctet);
    var readCount = getBinaryRead(dview, {
      type: obj.type,
      offsetOctet: 0
    });

    var readIndex = getBinaryRead(dview, {
      type: obj.type2,
      offsetOctet: 0
    });

    var offsetCurrent = 0;

    var nbOctetCount = typeToOctet(obj.type);
    var nbOctetIndex = typeToOctet(obj.type2);
    var idf = 0;
    for (var i = 0; i < count; ++i) {
      var nbVert = readCount(offsetCurrent);
      offsetCurrent += nbOctetCount;
      if (nbVert !== 3 && nbVert !== 4) {
        offsetCurrent += nbVert * nbOctetIndex;
        continue;
      }

      fAr[idf++] = readIndex(offsetCurrent);
      offsetCurrent += nbOctetIndex;

      fAr[idf++] = readIndex(offsetCurrent);
      offsetCurrent += nbOctetIndex;

      fAr[idf++] = readIndex(offsetCurrent);
      offsetCurrent += nbOctetIndex;

      if (nbVert === 4) {
        fAr[idf++] = readIndex(offsetCurrent);
        offsetCurrent += nbOctetIndex;
      } else {
        fAr[idf++] = -1;
      }
    }

    infos.faces = fAr.subarray(0, idf);
    infos.offsetOctet += offsetCurrent;
  };

  var readElementIndex = function (element, infos) {

    var fAr = infos.faces = new Int32Array(element.count * 4);
    if (!infos.isBinary)
      readAsciiIndex(element, infos, fAr);
    else
      readBinaryIndex(element, infos, fAr);
  };

  var skipElement = function (element, infos) {

    var count = element.count;

    if (!infos.isBinary) {

      infos.offsetLine += count;

    } else {

      var obj = element.properties[0];

      var dview = new DataView(infos.buffer, infos.offsetOctet);
      var readCount = getBinaryRead(dview, {
        type: obj.type,
        offsetOctet: 0
      });

      var offsetCurrent = 0;
      var nbOctetCount = typeToOctet(obj.type);
      var nbOctetIndex = typeToOctet(obj.type2);
      for (var i = 0; i < count; ++i) {
        offsetCurrent += nbOctetCount + readCount(offsetCurrent) * nbOctetIndex;
      }

      infos.offsetOctet += offsetCurrent;
    }

  };

  Import.importPLY = function (buffer, gl) {

    var infos = readHeader(buffer);
    var elements = infos.elements;

    for (var i = 0, nbElts = elements.length; i < nbElts; ++i) {

      var element = elements[i];

      if (element.name === 'vertex') {
        readElementVertex(element, infos);
      } else if (element.name === 'face') {
        readElementIndex(element, infos);
      } else {
        skipElement(element, infos);
      }
    }

    var mesh = new Mesh(gl);
    mesh.setVertices(infos.vertices);
    mesh.setFaces(infos.faces);
    mesh.setColors(infos.colors);
    return [mesh];
  };

  module.exports = Import;
});
define('files/ImportSTL',['require','exports','module','mesh/Mesh','misc/Utils'],function (require, exports, module) {

  'use strict';

  var Mesh = require('mesh/Mesh');
  var Utils = require('misc/Utils');

  var Import = {};

  /** Import STL file */
  Import.importSTL = function (buffer, gl) {
    var nbTriangles = new Uint32Array(buffer, 80, 1)[0] || 0;
    var isBinary = 84 + (nbTriangles * 50) === buffer.byteLength;
    var vb = isBinary ? Import.importBinarySTL(buffer, nbTriangles) : Import.importAsciiSTL(Utils.ab2str(buffer));
    var vbc;
    if (isBinary) {
      vbc = vb[1];
      vb = vb[0];
    }
    nbTriangles = vb.length / 9;
    var mapVertices = new Map();
    var nbVertices = [0];
    var iAr = new Int32Array(nbTriangles * 4);
    for (var i = 0; i < nbTriangles; ++i) {
      var idt = i * 4;
      var idv = i * 9;
      iAr[idt] = Import.detectNewVertex(mapVertices, vb, vbc, idv, nbVertices);
      iAr[idt + 1] = Import.detectNewVertex(mapVertices, vb, vbc, idv + 3, nbVertices);
      iAr[idt + 2] = Import.detectNewVertex(mapVertices, vb, vbc, idv + 6, nbVertices);
      iAr[idt + 3] = -1;
    }
    var mesh = new Mesh(gl);
    mesh.setVertices(vb.subarray(0, nbVertices[0] * 3));
    if (vbc)
      mesh.setColors(vbc.subarray(0, nbVertices[0] * 3));
    mesh.setFaces(iAr);
    return [mesh];
  };

  /** Check if the vertex already exists */
  Import.detectNewVertex = function (mapVertices, vb, vbc, start, nbVertices) {
    var x = vb[start];
    var y = vb[start + 1];
    var z = vb[start + 2];
    var hash = x + '+' + y + '+' + z;
    var idVertex = mapVertices.get(hash);
    if (idVertex === undefined) {
      idVertex = nbVertices[0];
      mapVertices.set(hash, idVertex);
      var id = idVertex * 3;
      vb[id] = x;
      vb[id + 1] = y;
      vb[id + 2] = z;
      if (vbc) {
        vbc[id] = vbc[start];
        vbc[id + 1] = vbc[start + 1];
        vbc[id + 2] = vbc[start + 2];
      }
      nbVertices[0]++;
    }
    return idVertex;
  };

  /** Import Ascii STL file */
  Import.importAsciiSTL = function (data) {
    var lines = data.split('\n');
    var nbLength = lines.length;
    var vb = new Float32Array(Math.ceil(nbLength * 9 / 7));
    var acc = 0;
    for (var i = 0; i < nbLength; ++i) {
      var line = lines[i].trim();
      if (line.startsWith('facet')) {
        var split = lines[i + 2].trim().split(/\s+/);
        vb[acc++] = parseFloat(split[1]);
        vb[acc++] = parseFloat(split[2]);
        vb[acc++] = parseFloat(split[3]);
        split = lines[i + 3].trim().split(/\s+/);
        vb[acc++] = parseFloat(split[1]);
        vb[acc++] = parseFloat(split[2]);
        vb[acc++] = parseFloat(split[3]);
        split = lines[i + 4].trim().split(/\s+/);
        vb[acc++] = parseFloat(split[1]);
        vb[acc++] = parseFloat(split[2]);
        vb[acc++] = parseFloat(split[3]);
      }
    }
    return vb.subarray(0, acc);
  };

  /** Import binary STL file */
  Import.importBinarySTL = function (buffer, nbTriangles) {
    var data = new Uint8Array(buffer);
    var i = 0;
    var vb = new Uint8Array(nbTriangles * 36);
    var vbc = new Uint8Array(nbTriangles * 2);
    var offset = 96;
    var j = 0;
    var jc = 0;
    for (i = 0; i < nbTriangles; i++) {
      for (var inc = 0; inc < 36; ++inc) {
        vb[j++] = data[offset++];
      }
      vbc[jc++] = data[offset++];
      vbc[jc++] = data[offset++];
      offset += 12;
    }
    var uc = new Uint16Array(vbc.buffer);
    vbc = new Float32Array(nbTriangles * 9);
    var inv = 1.0 / 31;
    for (i = 0; i < nbTriangles; ++i) {
      j = i * 9;
      var u = uc[i];
      var validColor = u & 32768;
      vbc[j] = vbc[j + 3] = vbc[j + 6] = validColor ? ((u >> 10) & 31) * inv : 1.0;
      vbc[j + 1] = vbc[j + 4] = vbc[j + 7] = validColor ? ((u >> 5) & 31) * inv : 1.0;
      vbc[j + 2] = vbc[j + 5] = vbc[j + 8] = validColor ? (u & 31) * inv : 1.0;
    }
    return [new Float32Array(vb.buffer), vbc];
  };

  module.exports = Import;
});
define('files/Import',['require','exports','module','files/ImportOBJ','files/ImportSGL','files/ImportPLY','files/ImportSTL'],function (require, exports, module) {

  'use strict';

  var ImportOBJ = require('files/ImportOBJ');
  var ImportSGL = require('files/ImportSGL');
  var ImportPLY = require('files/ImportPLY');
  var ImportSTL = require('files/ImportSTL');

  var Import = {
    importOBJ: ImportOBJ.importOBJ,
    importSGL: ImportSGL.importSGL,
    importPLY: ImportPLY.importPLY,
    importSTL: ImportSTL.importSTL
  };

  module.exports = Import;
});
define('lib/yagui',['require','exports','module'],function (require, exports, module) {

  'use strict';

  module.exports = window.yagui;
});
define('gui/GuiBackground',['require','exports','module','gui/GuiTR'],function (require, exports, module) {

  'use strict';

  var TR = require('gui/GuiTR');

  var GuiBackground = function (guiParent, ctrlGui) {
    this._main = ctrlGui._main; // main application
    this._menu = null; // ui menu
    this.init(guiParent);
  };

  GuiBackground.prototype = {
    init: function (guiParent) {
      // background fold
      var menu = this._menu = guiParent.addMenu(TR('backgroundTitle'));
      menu.addButton(TR('backgroundReset'), this, 'resetBackground');
      menu.addButton(TR('backgroundImport'), this, 'importBackground');
      menu.addCheckbox(TR('backgroundFill'), this._main.getBackground()._fill, this.updateFill.bind(this));
    },
    updateFill: function (val) {
      this._main.getBackground()._fill = val;
      this._main.onCanvasResize();
    },
    resetBackground: function () {
      this._main.getBackground().deleteTexture();
      this._main.render();
    },
    importBackground: function () {
      document.getElementById('backgroundopen').click();
    }
  };

  module.exports = GuiBackground;
});
define('gui/GuiCamera',['require','exports','module','gui/GuiTR'],function (require, exports, module) {

  'use strict';

  var TR = require('gui/GuiTR');

  var GuiCamera = function (guiParent, ctrlGui) {
    this._main = ctrlGui._main; // main application
    this._menu = null; // ui menu
    this._camera = this._main.getCamera(); // the camera
    this._cameraTimer = -1; // interval id (used for zqsd/wasd/arrow moves)
    this._cbTranslation = this.cbOnTranslation.bind(this);
    this.init(guiParent);
  };

  GuiCamera.prototype = {
    /** Initialize */
    init: function (guiParent) {
      var camera = this._camera;

      // Camera fold
      var menu = this._menu = guiParent.addMenu(TR('cameraTitle'));

      // reset camera
      menu.addTitle(TR('cameraReset'));
      menu.addDualButton(TR('cameraCenter'), TR('cameraFront'), this.resetCamera.bind(this), this.resetFront.bind(this));
      menu.addDualButton(TR('cameraLeft'), TR('cameraTop'), this.resetLeft.bind(this), this.resetTop.bind(this));

      // camera type
      var optionsType = {};
      this._ctrlProjectionTitle = menu.addTitle(TR('cameraProjection'));
      optionsType.PERSPECTIVE = TR('cameraPerspective');
      optionsType.ORTHOGRAPHIC = TR('cameraOrthographic');
      this._ctrlProjection = menu.addCombobox('', camera.getProjectionType(), this.onCameraTypeChange.bind(this), optionsType);

      // camera fov
      this._ctrlFov = menu.addSlider(TR('cameraFov'), camera.getFov(), this.onFovChange.bind(this), 10, 90, 1);
      this._ctrlFov.setVisibility(camera.getProjectionType() === 'PERSPECTIVE');

      // camera mode
      var optionsMode = {};
      menu.addTitle(TR('cameraMode'));
      optionsMode.ORBIT = TR('cameraOrbit');
      optionsMode.SPHERICAL = TR('cameraSpherical');
      optionsMode.PLANE = TR('cameraPlane');
      menu.addCombobox('', camera.getMode(), this.onCameraModeChange.bind(this), optionsMode);
      this._ctrlPivot = menu.addCheckbox(TR('cameraPivot'), camera.getUsePivot(), this.onPivotChange.bind(this));
    },
    onCameraModeChange: function (value) {
      this._camera.setMode(value);
      this._main.render();
	  setTimeout(function () {
		  window.umgl.drawonce();
	  }, 220);
    },
    onCameraTypeChange: function (value) {
      this._camera.setProjectionType(value);
      this._ctrlFov.setVisibility(value === 'PERSPECTIVE');
      this._main.render();
    },
    onFovChange: function (value) {
      this._camera.setFov(value);
      this._main.render();
    },
    onKeyDown: function (event) {
      if (event.handled === true)
        return;
      event.stopPropagation();
      if (this._main._focusGui)
        return;
      event.preventDefault();
      var key = event.which;
      var main = this._main;
      var camera = main.getCamera();
      event.handled = true;
      if (event.shiftKey && main._action === 'CAMERA_ROTATE') {
        camera.snapClosestRotation();
        main.render();
      }
      switch (key) {
      case 37: // LEFT
        camera._moveX = -1;
        break;
      case 39: // RIGHT
        camera._moveX = 1;
        break;
      case 38: // UP
        camera._moveZ = -1;
        break;
      case 40: // DOWN
        camera._moveZ = 1;
        break;
      default:
        event.handled = false;
      }
      if (event.handled === true && this._cameraTimer === -1) {
        this._cameraTimer = window.setInterval(this._cbTranslation, 16.6);
      }
    },
    cbOnTranslation: function () {
      var main = this._main;
      main.getCamera().updateTranslation();
      main.render();
    },
    /** Key released event */
    onKeyUp: function (event) {
      if (event.handled === true)
        return;
      event.stopPropagation();
      if (this._main._focusGui)
        return;
      event.preventDefault();
      event.handled = true;
      var key = event.which;
      var camera = this._camera;
      switch (key) {
      case 37: // LEFT
      case 39: // RIGHT
        camera._moveX = 0;
        break;
      case 38: // UP
      case 40: // DOWN
        camera._moveZ = 0;
        break;
      case 32: // SPACE
        this.resetCamera();
        break;
      case 70: // F
        this.resetFront();
        break;
      case 84: // T
        this.resetTop();
        break;
      case 76: // L
        this.resetLeft();
        break;
      }
      if (this._cameraTimer !== -1 && camera._moveX === 0 && camera._moveZ === 0) {
        clearInterval(this._cameraTimer);
        this._cameraTimer = -1;
      }
    },
    resetCamera: function () {
      this._camera.resetView();
      this._main.render();
	  setTimeout(function () {
		  window.umgl.drawonce();
	  }, 220);
    },
    resetFront: function () {
      this._camera.toggleViewFront();
      this._main.render();
	  setTimeout(function () {
		  window.umgl.drawonce();
	  }, 220);
    },
    resetLeft: function () {
      this._camera.toggleViewLeft();
      this._main.render();
	  setTimeout(function () {
		  window.umgl.drawonce();
	  }, 220);
    },
    resetTop: function () {
      this._camera.toggleViewTop();
      this._main.render();
	  setTimeout(function () {
		  window.umgl.drawonce();
	  }, 220);
    },
    onPivotChange: function () {
      this._camera.toggleUsePivot();
      this._main.render();
    }
  };

  module.exports = GuiCamera;
});

define('gui/GuiConfig',['require','exports','module','gui/GuiTR'],function (require, exports, module) {

  'use strict';

  var TR = require('gui/GuiTR');

  var GuiConfig = function (guiParent, ctrlGui) {
    this._ctrlGui = ctrlGui;
    this._menu = null; // ui menu
    this.init(guiParent);
  };

  GuiConfig.prototype = {
    /** Initialize */
    init: function (guiParent) {
      // config stuffs
      this._langs = Object.keys(TR.languages);
      this._menu = guiParent.addMenu('Language');
      this._menu.addCombobox('', this._langs.indexOf(TR.select), this.onLangChange.bind(this), this._langs);
    },
    onLangChange: function (value) {
      TR.select = this._langs[parseInt(value, 10)];
      this._ctrlGui.initGui();
    }
  };

  module.exports = GuiConfig;
});
define('lib/FileSaver',['require','exports','module'],function (require, exports, module) {

  'use strict';

  module.exports = window.saveAs;
});
define('files/ExportOBJ',['require','exports','module','lib/glMatrix'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');

  var vec3 = glm.vec3;

  var Export = {};

  /** Export OBJ file */
  Export.exportOBJ = function (meshes, saveColor) {
    var data = 's 0\n';
    var offsets = [1, 1];
    for (var i = 0, l = meshes.length; i < l; ++i) {
      data += 'o mesh_' + i + '\n';
      data = Export.addMesh(meshes[i], data, offsets, saveColor);
    }
    return new Blob([data]);
  };
  Export.addMesh = function (mesh, data, offsets, saveColor) {
    var vAr = mesh.getVertices();
    var cAr = mesh.getColors();
    var mAr = mesh.getMaterials();
    var fAr = mesh.getFaces();
    var nbVertices = mesh.getNbVertices();
    var nbFaces = mesh.getNbFaces();
    var matrix = mesh.getMatrix();
    var i = 0;
    var j = 0;
    var ver = [0.0, 0.0, 0.0];
    for (i = 0; i < nbVertices; ++i) {
      j = i * 3;
      ver[0] = vAr[j];
      ver[1] = vAr[j + 1];
      ver[2] = vAr[j + 2];
      vec3.transformMat4(ver, ver, matrix);
      data += 'v ' + ver[0] + ' ' + ver[1] + ' ' + ver[2];
      data += (saveColor ? ' ' + cAr[j] + ' ' + cAr[j + 1] + ' ' + cAr[j + 2] + '\n' : '\n');
    }
    if (!saveColor) {
      // zbrush-like vertex color
      var nbChunck = Math.ceil(nbVertices / 64);
      for (i = 0; i < nbChunck; ++i) {
        data += '#MRGB ';
        j = i * 64;
        var nbCol = j + (i === nbChunck - 1 ? nbVertices % 64 : 64);
        for (; j < nbCol; ++j) {
          data += 'ff';
          var cId = j * 3;
          var r = Math.round(cAr[cId] * 255).toString(16);
          var g = Math.round(cAr[cId + 1] * 255).toString(16);
          var b = Math.round(cAr[cId + 2] * 255).toString(16);
          data += r.length === 1 ? '0' + r : r;
          data += g.length === 1 ? '0' + g : g;
          data += b.length === 1 ? '0' + b : b;
        }
        data += '\n';
      }
      // zbrush-like vertex material
      nbChunck = Math.ceil(nbVertices / 46);
      for (i = 0; i < nbChunck; ++i) {
        data += '#MAT ';
        j = i * 46;
        var nbMat = j + (i === nbChunck - 1 ? nbVertices % 46 : 46);
        for (; j < nbMat; ++j) {
          var mId = j * 3;
          var ro = Math.round(mAr[mId] * 255).toString(16);
          var m = Math.round(mAr[mId + 1] * 255).toString(16);
          var a = Math.round(mAr[mId + 2] * 255).toString(16);
          data += ro.length === 1 ? '0' + ro : ro;
          data += m.length === 1 ? '0' + m : m;
          data += a.length === 1 ? '0' + a : a;
        }
        data += '\n';
      }
    }
    var nbTexCoords = mesh.getNbTexCoords();
    var fArUV = mesh.getFacesTexCoord();
    var uvAr = mesh.getTexCoords();
    var saveUV = mesh.hasUV();
    for (i = 0; i < nbTexCoords; ++i) {
      j = i * 2;
      data += 'vt ' + uvAr[j] + ' ' + uvAr[j + 1] + '\n';
    }
    var offV = offsets[0];
    var offTex = offsets[1];
    offsets[0] += nbVertices;
    offsets[1] += nbTexCoords;
    for (i = 0; i < nbFaces; ++i) {
      j = i * 4;
      var id = fAr[j + 3];
      if (saveUV) {
        data += 'f ' + (offV + fAr[j]) + '/' + (offTex + fArUV[j]);
        data += ' ' + (offV + fAr[j + 1]) + '/' + (offTex + fArUV[j + 1]);
        data += ' ' + (offV + fAr[j + 2]) + '/' + (offTex + fArUV[j + 2]);
        data += (id >= 0 ? ' ' + (offV + id) + '/' + (offTex + fArUV[j + 3]) + '\n' : '\n');
      } else {
        data += 'f ' + (offV + fAr[j]);
        data += ' ' + (offV + fAr[j + 1]);
        data += ' ' + (offV + fAr[j + 2]);
        data += (id >= 0 ? ' ' + (offV + id) + '\n' : '\n');
      }
    }
    return data;
  };

  module.exports = Export;
});
define('files/ExportPLY',['require','exports','module','misc/Utils','editing/Remesh'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var Remesh = require('editing/Remesh');

  var Export = {};

  /** Export Ascii PLY file */
  Export.exportAsciiPLY = function (mesh) {
    var vAr = mesh.getVertices();
    var cAr = mesh.getColors();
    var fAr = mesh.getFaces();
    var data = 'ply\nformat ascii 1.0\ncomment created by SculptGL\n';
    var nbVertices = mesh.getNbVertices();
    var nbFaces = mesh.getNbFaces();
    var i = 0;
    var j = 0;
    data += 'element vertex ' + nbVertices + '\n';
    data += 'property float x\nproperty float y\nproperty float z\n';
    data += 'property uchar red\nproperty uchar green\nproperty uchar blue\n';
    data += 'element face ' + nbFaces + '\n';
    data += 'property list uchar uint vertex_indices\nend_header\n';

    for (i = 0; i < nbVertices; ++i) {
      j = i * 3;
      data += vAr[j] + ' ' +
        vAr[j + 1] + ' ' +
        vAr[j + 2] + ' ' +
        ((cAr[j] * 0xff) | 0) + ' ' +
        ((cAr[j + 1] * 0xff) | 0) + ' ' +
        ((cAr[j + 2] * 0xff) | 0) + '\n';
    }

    for (i = 0; i < nbFaces; ++i) {
      j = i * 4;
      var id = fAr[j + 3];
      data += (id >= 0 ? '4 ' : '3 ') + fAr[j] + ' ' + fAr[j + 1] + ' ' + fAr[j + 2] + (id >= 0 ? ' ' + id + '\n' : '\n');
    }
    return new Blob([data]);
  };

  /** Export binary PLY file */
  Export.exportBinaryPLY = function (meshOrMeshes, isSketchfab) {
    var meshes = meshOrMeshes.length ? meshOrMeshes : [meshOrMeshes];
    var nbMeshes = meshes.length;
    var i = 0;
    var j = 0;
    var k = 0;

    var nbVertices = 0;
    var nbFaces = 0;
    var nbQuads = 0;
    var nbTriangles = 0;
    for (i = 0; i < nbMeshes; ++i) {
      nbVertices += meshes[i].getNbVertices();
      nbFaces += meshes[i].getNbFaces();
      nbQuads += meshes[i].getNbQuads();
      nbTriangles += meshes[i].getNbTriangles();
    }

    var vAr, cAr, fAr;
    if (isSketchfab) {
      var arr = {
        vertices: null,
        colors: null,
        faces: null
      };
      Remesh.mergeArrays(meshes, arr);
      vAr = arr.vertices;
      // sketchfab linear vertex color space
      cAr = Utils.convertArrayVec3toLinear(arr.colors);
      fAr = arr.faces;
      // swap xy
      for (i = 0; i < nbVertices; ++i) {
        k = i * 3;
        var yVal = vAr[k + 1];
        vAr[k + 1] = -vAr[k + 2];
        vAr[k + 2] = yVal;
      }
    } else {
      vAr = meshes[0].getVertices();
      cAr = meshes[0].getColors();
      fAr = meshes[0].getFaces();
    }

    var endian = Utils.littleEndian ? 'little' : 'big';
    var header = 'ply\nformat binary_' + endian + '_endian 1.0\ncomment created by SculptGL\n';
    header += 'element vertex ' + nbVertices + '\n';
    header += 'property float x\nproperty float y\nproperty float z\n';
    header += 'property uchar red\nproperty uchar green\nproperty uchar blue\n';
    header += 'element face ' + nbFaces + '\n';
    header += 'property list uchar uint vertex_indices\nend_header\n';

    var vertSize = vAr.length * 4 + cAr.length;
    var indexSize = (nbQuads * 4 + nbTriangles * 3) * 4 + nbFaces;
    var totalSize = header.length + vertSize + indexSize * 2;
    var data = new Uint8Array(totalSize);
    var dview = new DataView(data.buffer);

    j = header.length;
    var posOc = 0;
    for (posOc = 0; posOc < j; ++posOc) {
      data[posOc] = header.charCodeAt(posOc);
    }

    for (i = 0; i < nbVertices; ++i) {
      j = i * 3;
      dview.setFloat32(posOc, vAr[j], true);
      posOc += 4;
      dview.setFloat32(posOc, vAr[j + 1], true);
      posOc += 4;
      dview.setFloat32(posOc, vAr[j + 2], true);
      posOc += 4;

      dview.setUint8(posOc, Math.round(255.0 * cAr[j]));
      posOc += 1;
      dview.setUint8(posOc, Math.round(255.0 * cAr[j + 1]));
      posOc += 1;
      dview.setUint8(posOc, Math.round(255.0 * cAr[j + 2]));
      posOc += 1;
    }

    for (i = 0; i < nbFaces; ++i) {
      j = i * 4;
      var isQuad = fAr[j + 3] >= 0;

      dview.setUint8(posOc, isQuad ? 4 : 3);
      posOc += 1;

      dview.setUint32(posOc, fAr[j], true);
      posOc += 4;
      dview.setUint32(posOc, fAr[j + 1], true);
      posOc += 4;
      dview.setUint32(posOc, fAr[j + 2], true);
      posOc += 4;
      if (isQuad) {
        dview.setUint32(posOc, fAr[j + 3], true);
        posOc += 4;
      }
    }

    return new Blob([data]);
  };

  module.exports = Export;
});
define('files/ExportSTL',['require','exports','module','misc/Utils'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');

  var Export = {};

  /** Export Ascii STL file */
  Export.exportAsciiSTL = function (mesh) {
    var vAr = mesh.getVertices();
    var iAr = mesh.getTriangles();
    var origFN = mesh.getFaceNormals();
    var faceNormals = new Float32Array(Utils.getMemory(origFN.length * 4), 0, origFN.length);
    Utils.normalizeArrayVec3(origFN, faceNormals);
    var data = 'solid mesh\n';
    var nbTriangles = mesh.getNbTriangles();
    for (var i = 0; i < nbTriangles; ++i) {
      var j = i * 3;
      data += ' facet normal ' + faceNormals[j] + ' ' + faceNormals[j + 1] + ' ' + faceNormals[j + 2] + '\n';
      data += '  outer loop\n';
      var iv1 = iAr[j] * 3;
      var iv2 = iAr[j + 1] * 3;
      var iv3 = iAr[j + 2] * 3;
      data += '   vertex ' + vAr[iv1] + ' ' + vAr[iv1 + 1] + ' ' + vAr[iv1 + 2] + '\n';
      data += '   vertex ' + vAr[iv2] + ' ' + vAr[iv2 + 1] + ' ' + vAr[iv2 + 2] + '\n';
      data += '   vertex ' + vAr[iv3] + ' ' + vAr[iv3 + 1] + ' ' + vAr[iv3 + 2] + '\n';
      data += '  endloop\n';
      data += ' endfacet\n';
    }
    data += 'endsolid mesh\n';
    return new Blob([data]);
  };

  /** Export binary STL file */
  Export.exportBinarySTL = function (mesh) {
    var vAr = mesh.getVertices();
    var cAr = mesh.getColors();
    var iAr = mesh.getTriangles();

    var origFN = mesh.getFaceNormals();
    var faceNormals = new Float32Array(Utils.getMemory(origFN.length * 4), 0, origFN.length);
    Utils.normalizeArrayVec3(origFN, faceNormals);

    var nbTriangles = mesh.getNbTriangles();

    var data = new Uint8Array(84 + nbTriangles * 50);
    var nbTriBuff = new Uint8Array(new Uint32Array([nbTriangles]).buffer);
    data.set(nbTriBuff, 80);

    var verBuffer = new Uint8Array(vAr.buffer);
    var norBuffer = new Uint8Array(faceNormals.buffer);
    var offset = 84;
    var inc = 0;

    var mulc = 31 / 3;
    for (var i = 0; i < nbTriangles; ++i) {
      var k = i * 12;
      for (inc = 0; inc < 12; ++inc) {
        data[offset++] = norBuffer[k++];
      }
      k = i * 3;
      var iv1 = iAr[k] * 3;
      var iv2 = iAr[k + 1] * 3;
      var iv3 = iAr[k + 2] * 3;

      var id1 = iv1 * 4;
      for (inc = 0; inc < 12; ++inc) {
        data[offset++] = verBuffer[id1++];
      }
      var id2 = iv2 * 4;
      for (inc = 0; inc < 12; ++inc) {
        data[offset++] = verBuffer[id2++];
      }
      var id3 = iv3 * 4;
      for (inc = 0; inc < 12; ++inc) {
        data[offset++] = verBuffer[id3++];
      }
      var r = Math.round((cAr[iv1] + cAr[iv2] + cAr[iv3]) * mulc) << 10;
      var g = Math.round((cAr[iv1 + 1] + cAr[iv2 + 1] + cAr[iv3 + 1]) * mulc) << 5;
      var b = Math.round((cAr[iv1 + 2] + cAr[iv2 + 2] + cAr[iv3 + 2]) * mulc);
      var col = r + g + b + 32768;
      data[offset++] = col & 255;
      data[offset++] = col >> 8;
    }
    return new Blob([data]);
  };

  module.exports = Export;
});
define('lib/zip',['require','exports','module'],function (require, exports, module) {

  'use strict';

  module.exports = window.zip;
});
define('files/ExportSketchfab',['require','exports','module','gui/GuiTR','lib/zip','files/ExportPLY'],function (require, exports, module) {

  'use strict';

  var TR = require('gui/GuiTR');
  var zip = require('lib/zip');
  var ExportPLY = require('files/ExportPLY');

  var Export = {};

  Export.exportSketchfab = function (main, key, statusWidget) {
    var xhr = new XMLHttpRequest();
    var domStatus = statusWidget.domContainer;
    statusWidget.setVisibility(true);
    statusWidget.sketchfab = true;
    domStatus.innerHTML = 'Uploading...';
    xhr.open('POST', 'https://api.sketchfab.com/v2/models', true);

    xhr.onprogress = function (event) {
      if (event.lengthComputable)
        domStatus.innerHTML = 'Uploading : ' + Math.round(event.loaded * 100.0 / event.total) + '%';
    };
    var hideStatus = function () {
      statusWidget.setVisibility(false);
      statusWidget.sketchfab = false;
    };
    xhr.onerror = hideStatus;
    xhr.onabort = hideStatus;

    xhr.onload = function () {
      hideStatus();
      var res = JSON.parse(xhr.responseText);
      var uid = res.uid;
      if (!uid) {
        window.alert(TR('sketchfabUploadError', res.detail));
        return;
      }
      window.prompt(TR('sketchfabUploadProcessing'), 'https://sketchfab.com/models/' + uid);
      var check = function () {
        var xhrPoll = new XMLHttpRequest();
        xhrPoll.open('GET', 'https://api.sketchfab.com/v2/models/' + uid + '/status?token=' + key, true);
        xhrPoll.onload = function () {
          var resPoll = JSON.parse(xhrPoll.responseText);
          if (resPoll.processing === 'FAILED')
            window.alert(TR('sketchfabUploadError', resPoll.warning.generic.join('\n')));
          else if (resPoll.processing === 'SUCCEEDED')
            window.prompt(TR('sketchfabUploadSuccess'), 'https://sketchfab.com/models/' + uid);
          else
            window.setTimeout(check, 5000);
        };
        xhrPoll.send();
      };
      check();
    };

    zip.useWebWorkers = true;
    zip.workerScriptsPath = 'worker/';
    zip.createWriter(new zip.BlobWriter('application/zip'), function (zipWriter) {
      var data = ExportPLY.exportBinaryPLY(main.getMeshes(), true);
      zipWriter.add('yourMesh.ply', new zip.BlobReader(data), function () {
        zipWriter.close(Export.exportFileSketchfab.bind(this, main, key, xhr));
      });
    }, onerror);

    return xhr;
  };

  Export.exportFileSketchfab = function (main, key, xhr, blob) {
    var fd = new FormData();
    fd.append('token', key);
    fd.append('modelFile', blob, 'sculptglModel.zip');
    fd.append('name', 'My model');
    fd.append('tags', 'sculptgl');
    xhr.send(fd);
  };

  module.exports = Export;
});
define('files/Export',['require','exports','module','files/ExportOBJ','files/ExportSGL','files/ExportPLY','files/ExportSTL','files/ExportSketchfab'],function (require, exports, module) {

  'use strict';

  var ExportOBJ = require('files/ExportOBJ');
  var ExportSGL = require('files/ExportSGL');
  var ExportPLY = require('files/ExportPLY');
  var ExportSTL = require('files/ExportSTL');
  var ExportSketchfab = require('files/ExportSketchfab');

  var Export = {};
  Export.exportOBJ = ExportOBJ.exportOBJ;
  Export.exportSGL = ExportSGL.exportSGL;
  Export.exportAsciiPLY = ExportPLY.exportAsciiPLY;
  Export.exportBinaryPLY = ExportPLY.exportBinaryPLY;
  Export.exportAsciiSTL = ExportSTL.exportAsciiSTL;
  Export.exportBinarySTL = ExportSTL.exportBinarySTL;
  Export.exportSketchfab = ExportSketchfab.exportSketchfab;

  module.exports = Export;
});
define('gui/GuiFiles',['require','exports','module','gui/GuiTR','lib/FileSaver','files/Export'],function (require, exports, module) {

  'use strict';

  var TR = require('gui/GuiTR');
  var saveAs = require('lib/FileSaver');
  var Export = require('files/Export');

  var GuiFiles = function (guiParent, ctrlGui) {
    this._main = ctrlGui._main; // main application
    this._ctrlGui = ctrlGui;
    this._menu = null; // ui menu
    this._parent = guiParent;
    this.init(guiParent);
  };

  GuiFiles.prototype = {
    /** Initialize */
    init: function (guiParent) {
      var menu = this._menu = guiParent.addMenu(TR('fileTitle'));

      // import
      menu.addTitle(TR('fileImportTitle'));
      menu.addButton(TR('fileAdd'), this, 'addFile' /*, 'CTRL+O/I'*/ );
      menu.addCheckbox(TR('fileAutoMatrix'), this._main, '_autoMatrix');
      menu.addCheckbox(TR('fileVertexSRGB'), this._main, '_vertexSRGB');

      // export
      menu.addTitle(TR('fileExportSceneTitle'));
      menu.addButton(TR('fileExportSGL'), this, 'saveFileAsSGL');
      menu.addButton(TR('fileExportOBJ'), this, 'saveFileAsOBJ' /*, 'CTRL+(Alt)+E'*/ );
      menu.addButton(TR('sketchfabTitle'), this, 'exportSketchfab');
      menu.addTitle(TR('fileExportMeshTitle'));
      menu.addButton(TR('fileExportPLY'), this, 'saveFileAsPLY');
      menu.addButton(TR('fileExportSTL'), this, 'saveFileAsSTL');
    },
    addFile: function () {
      document.getElementById('fileopen').click();
    },
    saveFileAsSGL: function () {
      if (this._main.getMeshes().length === 0) return;
      var blob = Export.exportSGL(this._main.getMeshes(), this._main);
      saveAs(blob, 'yourMesh.sgl');
    },
    saveFileAsOBJ: function (selection) {
      var meshes = this._main.getMeshes();
      if (meshes.length === 0) return;
      if (selection) {
        meshes = this._main.getSelectedMeshes();
        if (!meshes[0]) return;
      }
      var blob = Export.exportOBJ(meshes);
      saveAs(blob, 'yourMesh.obj');
    },
    saveFileAsPLY: function () {
      var mesh = this._main.getMesh();
      if (!mesh) return;
      var blob = Export.exportBinaryPLY(mesh);
      saveAs(blob, 'yourMesh.ply');
    },
    saveFileAsSTL: function () {
      var mesh = this._main.getMesh();
      if (!mesh) return;
      var blob = Export.exportBinarySTL(mesh);
      saveAs(blob, 'yourMesh.stl');
    },
    exportSketchfab: function () {
      var mesh = this._main.getMesh();
      if (!mesh)
        return;

      var ctrlNotif = this._ctrlGui.getWidgetNotification();
      if (this._sketchfabXhr && ctrlNotif.sketchfab === true) {
        if (!window.confirm(TR('sketchfabAbort')))
          return;
        ctrlNotif.sketchfab = false;
        this._sketchfabXhr.abort();
      }

      var api = window.prompt(TR('sketchfabUploadMessage'), 'guest');
      if (!api)
        return;

      var key = api === 'guest' ? 'babc9a5cd4f343f9be0c7bd9cf93600c' : api;
      this._sketchfabXhr = Export.exportSketchfab(this._main, key, ctrlNotif);
    },
    ////////////////
    // KEY EVENTS
    //////////////// 
    onKeyDown: function (event) {
      if (event.handled === true)
        return;

      event.stopPropagation();
      if (!this._main._focusGui)
        event.preventDefault();

      var key = event.which;
      if (event.ctrlKey && event.altKey && key === 78) { // N
        this._main.clearScene();
        event.handled = true;

      } else if (event.ctrlKey && (key === 79 || key === 73)) { // O or I
        this.addFile();
        event.handled = true;

      } else if (event.ctrlKey && key === 69) { // E 
        this.saveFileAsOBJ(event.altKey);
        event.handled = true;
      }
    }
  };

  module.exports = GuiFiles;
});
define('gui/GuiMesh',['require','exports','module','gui/GuiTR'],function (require, exports, module) {

  'use strict';

  var TR = require('gui/GuiTR');

  var GuiMesh = function (guiParent, ctrlGui) {
    this._main = ctrlGui._main; // main application

    this.domVerts = null; // ctrl nb vertices
    this.domFaces = null; // ctrl nb faces
    this.domUl = null;
    this.init(guiParent);
  };

  GuiMesh.prototype = {
    /** Initialize */
    init: function (guiParent) {
      this.domVerts = document.createElement('ul');
      this.domVerts.innerHTML = TR('meshNbVertices');

      this.domFaces = document.createElement('ul');
      this.domFaces.innerHTML = TR('meshNbFaces');

      this.domUl = document.createElement('span');
      this.domUl.appendChild(this.domVerts);
      this.domUl.appendChild(this.domFaces);
      var style = this.domUl.style;
      style.cursor = 'default';
      if (style.float === undefined) style.cssFloat = 'right';
      else style.float = 'right';

      guiParent.domTopbar.appendChild(this.domUl);
    },
    /** Update number of vertices and faces */
    updateMeshInfo: function () {
      var mesh = this._main.getMesh();
      this.domVerts.innerHTML = TR('meshNbVertices') + (mesh ? mesh.getNbVertices() : 0);
      this.domFaces.innerHTML = TR('meshNbFaces') + (mesh ? mesh.getNbFaces() : 0);
    }
  };

  module.exports = GuiMesh;
});
define('mesh/multiresolution/MeshResolution',['require','exports','module','misc/Utils','editing/Subdivision','mesh/Mesh'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var Subdivision = require('editing/Subdivision');
  var Mesh = require('mesh/Mesh');

  var MeshResolution = function (transformData, render, mesh) {
    this._meshOrigin = mesh || new Mesh();
    if (mesh) this._meshOrigin.setID(mesh.getID());
    this._meshOrigin.setTransformData(transformData);
    this._meshOrigin.setRender(render);
    this._detailsXYZ = null; // details vectors (Float32Array)
    this._detailsRGB = null; // details vectors (Float32Array)
    this._detailsPBR = null; // details vectors (Float32Array)
    this._vertMapping = null; // vertex mapping to higher res (Uint32Array)
    this._evenMapping = false; // if the even vertices are not aligned with higher res
  };

  MeshResolution.prototype = {
    getMeshOrigin: function () {
      return this._meshOrigin;
    },
    getDetailsVertices: function () {
      return this._detailsXYZ;
    },
    getDetailsColors: function () {
      return this._detailsRGB;
    },
    getDetailsMaterials: function () {
      return this._detailsPBR;
    },
    getEvenMapping: function () {
      return this._evenMapping;
    },
    getVerticesMapping: function () {
      return this._vertMapping;
    },
    setDetailsVertices: function (dAr) {
      this._detailsXYZ = dAr;
    },
    setDetailsColors: function (dcAr) {
      this._detailsRGB = dcAr;
    },
    setDetailsMaterials: function (dmAr) {
      this._detailsPBR = dmAr;
    },
    setVerticesMapping: function (vmAr) {
      this._vertMapping = vmAr;
    },
    setEvenMapping: function (bool) {
      this._evenMapping = bool;
    },
    /** Go to one level above (down to up) */
    higherSynthesis: function (meshDown) {
      meshDown.computePartialSubdivision(this.getVertices(), this.getColors(), this.getMaterials());
      this.applyDetails();
    },
    /** Go to one level below (up to down) */
    lowerAnalysis: function (meshUp) {
      this.copyDataFromHigherRes(meshUp);
      var subdVerts = new Float32Array(meshUp.getNbVertices() * 3);
      var subdColors = new Float32Array(meshUp.getNbVertices() * 3);
      var subdMaterials = new Float32Array(meshUp.getNbVertices() * 3);
      this.computePartialSubdivision(subdVerts, subdColors, subdMaterials);
      meshUp.computeDetails(subdVerts, subdColors, subdMaterials);
    },
    copyDataFromHigherRes: function (meshUp) {
      var vArDown = this.getVertices();
      var cArDown = this.getColors();
      var mArDown = this.getMaterials();
      var nbVertices = this.getNbVertices();
      var vArUp = meshUp.getVertices();
      var cArUp = meshUp.getColors();
      var mArUp = meshUp.getMaterials();
      if (this.getEvenMapping() === false) {
        vArDown.set(vArUp.subarray(0, nbVertices * 3));
        cArDown.set(cArUp.subarray(0, nbVertices * 3));
        mArDown.set(mArUp.subarray(0, nbVertices * 3));
      } else {
        var vertMap = this.getVerticesMapping();
        for (var i = 0; i < nbVertices; ++i) {
          var id = i * 3;
          var idUp = vertMap[i] * 3;
          vArDown[id] = vArUp[idUp];
          vArDown[id + 1] = vArUp[idUp + 1];
          vArDown[id + 2] = vArUp[idUp + 2];
          cArDown[id] = cArUp[idUp];
          cArDown[id + 1] = cArUp[idUp + 1];
          cArDown[id + 2] = cArUp[idUp + 2];
          mArDown[id] = mArUp[idUp];
          mArDown[id + 1] = mArUp[idUp + 1];
          mArDown[id + 2] = mArUp[idUp + 2];
        }
      }
    },
    computePartialSubdivision: function (subdVerts, subdColors, subdMaterials) {
      var verts = subdVerts;
      var colors = subdColors;
      var materials = subdMaterials;
      var vertMap = this.getVerticesMapping();
      if (vertMap) {
        verts = new Float32Array(subdVerts.length);
        colors = new Float32Array(subdColors.length);
        materials = new Float32Array(subdMaterials.length);
      }
      Subdivision.partialSubdivision(this, verts, colors, materials);
      if (vertMap) {
        var startMapping = this.getEvenMapping() === true ? 0 : this.getNbVertices();
        if (startMapping > 0) {
          subdVerts.set(verts.subarray(0, startMapping * 3));
          subdColors.set(colors.subarray(0, startMapping * 3));
          subdMaterials.set(materials.subarray(0, startMapping * 3));
        }
        for (var i = startMapping, l = subdVerts.length / 3; i < l; ++i) {
          var id = i * 3;
          var idUp = vertMap[i] * 3;
          subdVerts[idUp] = verts[id];
          subdVerts[idUp + 1] = verts[id + 1];
          subdVerts[idUp + 2] = verts[id + 2];
          subdColors[idUp] = colors[id];
          subdColors[idUp + 1] = colors[id + 1];
          subdColors[idUp + 2] = colors[id + 2];
          subdMaterials[idUp] = materials[id];
          subdMaterials[idUp + 1] = materials[id + 1];
          subdMaterials[idUp + 2] = materials[id + 2];
        }
      }
    },
    /** Apply back the detail vectors */
    applyDetails: function () {
      var vrvStartCountUp = this.getVerticesRingVertStartCount();
      var vertRingVertUp = this.getVerticesRingVert();
      var vArUp = this.getVertices();
      var nArUp = this.getNormals();
      var cArUp = this.getColors();
      var mArUp = this.getMaterials();
      var nbVertsUp = this.getNbVertices();

      var vArTemp = new Float32Array(Utils.getMemory(vArUp.length * 4), 0, vArUp.length);
      vArTemp.set(vArUp);

      var dAr = this.getDetailsVertices();
      var dColorAr = this.getDetailsColors();
      var dMaterialAr = this.getDetailsMaterials();

      var min = Math.min;
      var max = Math.max;
      for (var i = 0; i < nbVertsUp; ++i) {
        var j = i * 3;

        // color delta vec
        cArUp[j] = min(1.0, max(0.0, cArUp[j] + dColorAr[j]));
        cArUp[j + 1] = min(1.0, max(0.0, cArUp[j + 1] + dColorAr[j + 1]));
        cArUp[j + 2] = min(1.0, max(0.0, cArUp[j + 2] + dColorAr[j + 2]));

        // material delta vec
        mArUp[j] = min(1.0, max(0.0, mArUp[j] + dMaterialAr[j]));
        mArUp[j + 1] = min(1.0, max(0.0, mArUp[j + 1] + dMaterialAr[j + 1]));
        mArUp[j + 2] = min(1.0, max(0.0, mArUp[j + 2] + dMaterialAr[j + 2]));

        // vertex coord
        var vx = vArTemp[j];
        var vy = vArTemp[j + 1];
        var vz = vArTemp[j + 2];

        // normal vec
        var nx = nArUp[j];
        var ny = nArUp[j + 1];
        var nz = nArUp[j + 2];
        // normalize vector
        var len = nx * nx + ny * ny + nz * nz;
        if (len === 0.0)
          continue;
        len = 1.0 / Math.sqrt(len);
        nx *= len;
        ny *= len;
        nz *= len;

        // tangent vec (vertex neighbor - vertex)
        var k = vertRingVertUp[vrvStartCountUp[i * 2]] * 3;
        var tx = vArTemp[k] - vx;
        var ty = vArTemp[k + 1] - vy;
        var tz = vArTemp[k + 2] - vz;
        // distance to normal plane
        len = tx * nx + ty * ny + tz * nz;
        // project on normal plane
        tx -= nx * len;
        ty -= ny * len;
        tz -= nz * len;
        // normalize vector
        len = tx * tx + ty * ty + tz * tz;
        if (len === 0.0)
          continue;
        len = 1.0 / Math.sqrt(len);
        tx *= len;
        ty *= len;
        tz *= len;

        // bi normal/tangent
        var bix = ny * tz - nz * ty;
        var biy = nz * tx - nx * tz;
        var biz = nx * ty - ny * tx;

        // displacement/detail vector (object space)
        var dx = dAr[j];
        var dy = dAr[j + 1];
        var dz = dAr[j + 2];

        // detail vec in the local frame
        vArUp[j] = vx + nx * dx + tx * dy + bix * dz;
        vArUp[j + 1] = vy + ny * dx + ty * dy + biy * dz;
        vArUp[j + 2] = vz + nz * dx + tz * dy + biz * dz;
      }
    },
    /** Compute the detail vectors */
    computeDetails: function (subdVerts, subdColors, subdMaterials) {
      var vrvStartCountUp = this.getVerticesRingVertStartCount();
      var vertRingVertUp = this.getVerticesRingVert();
      var vArUp = this.getVertices();
      var nArUp = this.getNormals();
      var cArUp = this.getColors();
      var mArUp = this.getMaterials();
      var nbVertices = this.getNbVertices();

      var dAr = new Float32Array(subdVerts.length);
      this.setDetailsVertices(dAr);
      var dColorAr = new Float32Array(subdVerts.length);
      this.setDetailsColors(dColorAr);
      var dMaterialAr = new Float32Array(subdVerts.length);
      this.setDetailsMaterials(dMaterialAr);

      for (var i = 0; i < nbVertices; ++i) {
        var j = i * 3;

        // color delta vec
        dColorAr[j] = cArUp[j] - subdColors[j];
        dColorAr[j + 1] = cArUp[j + 1] - subdColors[j + 1];
        dColorAr[j + 2] = cArUp[j + 2] - subdColors[j + 2];

        // material delta vec
        dMaterialAr[j] = mArUp[j] - subdMaterials[j];
        dMaterialAr[j + 1] = mArUp[j + 1] - subdMaterials[j + 1];
        dMaterialAr[j + 2] = mArUp[j + 2] - subdMaterials[j + 2];

        // normal vec
        var nx = nArUp[j];
        var ny = nArUp[j + 1];
        var nz = nArUp[j + 2];
        // normalize vector
        var len = nx * nx + ny * ny + nz * nz;
        if (len === 0.0)
          continue;
        len = 1.0 / Math.sqrt(len);
        nx *= len;
        ny *= len;
        nz *= len;

        // tangent vec (vertex neighbor - vertex)
        var k = vertRingVertUp[vrvStartCountUp[i * 2]] * 3;
        var tx = subdVerts[k] - subdVerts[j];
        var ty = subdVerts[k + 1] - subdVerts[j + 1];
        var tz = subdVerts[k + 2] - subdVerts[j + 2];
        // distance to normal plane
        len = tx * nx + ty * ny + tz * nz;
        // project on normal plane
        tx -= nx * len;
        ty -= ny * len;
        tz -= nz * len;
        // normalize vector
        len = tx * tx + ty * ty + tz * tz;
        if (len === 0.0)
          continue;
        len = 1.0 / Math.sqrt(len);
        tx *= len;
        ty *= len;
        tz *= len;

        // bi normal/tangent
        var bix = ny * tz - nz * ty;
        var biy = nz * tx - nx * tz;
        var biz = nx * ty - ny * tx;

        // displacement/detail vector (object space)
        var dx = vArUp[j] - subdVerts[j];
        var dy = vArUp[j + 1] - subdVerts[j + 1];
        var dz = vArUp[j + 2] - subdVerts[j + 2];

        // order : n/t/bi
        dAr[j] = nx * dx + ny * dy + nz * dz;
        dAr[j + 1] = tx * dx + ty * dy + tz * dz;
        dAr[j + 2] = bix * dx + biy * dy + biz * dz;
      }
    }
  };

  Utils.makeProxy(Mesh, MeshResolution, function (proto) {
    return function () {
      return proto.apply(this.getMeshOrigin(), arguments);
    };
  });

  module.exports = MeshResolution;
});
define('mesh/multiresolution/LowRender',['require','exports','module','misc/Utils','mesh/Render','render/ShaderLib','render/Buffer'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var Render = require('mesh/Render');
  var Shader = require('render/ShaderLib');
  var Buffer = require('render/Buffer');

  var LowRender = function (render) {
    this._renderOrigin = render; // the base render

    var gl = render.getGL(); // webgl context
    this._indexBuffer = new Buffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW); // index buffer
    this._wireframeBuffer = new Buffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW); // wireframe buffer
  };

  LowRender.prototype = {
    getRenderOrigin: function () {
      return this._renderOrigin;
    },
    getIndexBuffer: function () {
      return this._indexBuffer;
    },
    getWireframeBuffer: function () {
      return this._wireframeBuffer;
    },
    /** No flat shading because we can't share vertices buffer with higher resolution */
    isUsingDrawArrays: function () {
      return false;
    },
    updateBuffers: function (mesh) {
      this.getIndexBuffer().update(mesh.getTriangles());
      this.getWireframeBuffer().update(mesh.getWireframe());
    },
    render: function (main) {
      Shader[this.getShaderName()].getOrCreate(this.getGL()).draw(this, main);
    },
    renderWireframe: function (main) {
      Shader.WIREFRAME.getOrCreate(this.getGL()).draw(this, main);
    },
    release: function () {
      this.getIndexBuffer().release();
      this.getWireframeBuffer().release();
    }
  };

  Utils.makeProxy(Render, LowRender, function (proto) {
    return function () {
      return proto.apply(this.getRenderOrigin(), arguments);
    };
  });

  module.exports = LowRender;
});
define('editing/Reversion',['require','exports','module','misc/Utils'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');

  var Reversion = {};

  var detectExtraordinaryVertices = function (mesh) {
    var nbVertices = mesh.getNbVertices();
    var fAr = mesh.getFaces();
    var onEdge = mesh.getVerticesOnEdge();
    var vrvStartCount = mesh.getVerticesRingVertStartCount();
    var vrf = mesh.getVerticesRingFace();
    var vrfStartCount = mesh.getVerticesRingFaceStartCount();
    var vExtraTags = new Int8Array(nbVertices);
    for (var i = 0, l = nbVertices; i < l; ++i) {
      var id = i * 2;
      var len = vrvStartCount[id + 1];
      var startFace = vrfStartCount[id];
      var countFace = vrfStartCount[id + 1];
      var vBorder = onEdge[i];
      var nbQuad = 0;
      for (var j = startFace, endFace = startFace + countFace; j < endFace; ++j) {
        nbQuad += fAr[vrf[j] * 4 + 3] < 0 ? 0 : 1;
      }
      if (nbQuad === 0) {
        // tris
        if ((!vBorder && len !== 6) || (vBorder && len !== 4))
          vExtraTags[i] = 1;
      } else if (nbQuad === countFace) {
        // quads
        if ((!vBorder && len !== 4) || (vBorder && len !== 3))
          vExtraTags[i] = 1;
      } else {
        // quad and tri
        if (vBorder || len !== 5)
          vExtraTags[i] = 1;
      }
    }
    return vExtraTags;
  };

  /** Return the first extraordinary vertex if it exists... or a random vertex otherwise */
  var getSeed = function (mesh, vEvenTags, vExtraTags) {
    var i = 0;
    var nbVertices = mesh.getNbVertices();
    for (i = 0; i < nbVertices; ++i) {
      if (vEvenTags[i] !== 0)
        continue;
      if (vExtraTags[i] === 1)
        return i;
    }
    // no extraordinary vertices...
    var onEdge = mesh.getVerticesOnEdge();
    for (i = 0; i < nbVertices; ++i) {
      if (vEvenTags[i] !== 0) continue; // skip already processed vertex
      if (onEdge[i] !== 1) break;
    }
    // cancels reversion if there is no edge vertex
    if (i === nbVertices) return -1;
    // find the first non-already processed vertex
    for (i = 0; i < nbVertices; ++i) {
      if (vEvenTags[i] === 0) return i;
    }
    return -1;
  };

  /** Tag the even vertices */
  var tagVertices = function (mesh, vEvenTags, vExtraTags) {
    var tagFlag = ++Utils.TAG_FLAG;
    var vFlags = mesh.getVerticesTagFlags();
    var vrvSC = mesh.getVerticesRingVertStartCount();
    var vrv = mesh.getVerticesRingVert();
    var onEdge = mesh.getVerticesOnEdge();

    var vSeed = getSeed(mesh, vEvenTags, vExtraTags);
    if (vSeed < 0)
      return;
    vEvenTags[vSeed] = 1;
    var stack = new Uint32Array(Utils.getMemory(mesh.getNbVertices() * 4), 0, mesh.getNbVertices());
    stack[0] = vSeed;
    var curStack = 1;
    while (curStack > 0) {
      var idVert = stack[--curStack];
      var start = vrvSC[idVert * 2];
      var end = start + vrvSC[idVert * 2 + 1];
      var i = 0;
      var stamp = ++tagFlag;
      // tag the odd vertices
      for (i = start; i < end; ++i) {
        var oddi = vrv[i];
        vFlags[oddi] = stamp;
        // already an even vertex
        if (vEvenTags[oddi] === 1) {
          Utils.TAG_FLAG = tagFlag;
          return;
        }
        vEvenTags[oddi] = -1; //odd vertex
        vFlags[oddi] = stamp;
      }
      // stamp-1 means odd vertex, while stamp ==> locally already
      // visited candidates opposites even vertex
      stamp = ++tagFlag;
      for (i = start; i < end; ++i) {
        var oddId = vrv[i];
        // extraordinary vertex marked as odd vertex
        if (vExtraTags[oddId] !== 0 && !onEdge[oddId]) {
          Utils.TAG_FLAG = tagFlag;
          return;
        }
        var oddStart = vrvSC[oddId * 2];
        var oddEnd = oddStart + vrvSC[oddId * 2 + 1];
        // find opposite vertex
        for (var j = oddStart; j < oddEnd; ++j) {
          var evenj = vrv[j];
          if (evenj === idVert)
            continue;
          if (vFlags[evenj] >= (stamp - 1)) // see comments above
            continue;
          vFlags[evenj] = stamp;
          if (vEvenTags[evenj] !== 0) // already processed
            continue;
          var oppStart = vrvSC[evenj * 2];
          var oppEnd = oppStart + vrvSC[evenj * 2 + 1];
          var nbOdd = 0;
          for (var k = oppStart; k < oppEnd; ++k) {
            if (vFlags[vrv[k]] === (stamp - 1))
              nbOdd++;
          }
          if (nbOdd === 2) {
            vEvenTags[evenj] = -1;
          } else {
            vEvenTags[evenj] = 1;
            stack[curStack++] = evenj;
          }
        }
      }
    }
    Utils.TAG_FLAG = tagFlag;
    return vEvenTags;
  };

  /** Tag the even vertices */
  var tagEvenVertices = function (mesh) {
    var nbVertices = mesh.getNbVertices();
    // 0 not processed, -1 odd vertex, 1 even vertex
    var vEvenTags = new Int8Array(nbVertices);
    var vExtraTags = detectExtraordinaryVertices(mesh);
    var running = true;
    while (running) {
      var status = tagVertices(mesh, vEvenTags, vExtraTags);
      if (!status)
        return;
      running = false;
      for (var i = 0; i < nbVertices; ++i) {
        if (vEvenTags[i] === 0) {
          running = true;
          break;
        }
      }
    }
    return vEvenTags;
  };

  /** Creates the coarse faces from the tagged vertices */
  var createFaces = function (baseMesh, newMesh, vEvenTags) {
    var feAr = baseMesh.getFaceEdges();
    var fArUp = baseMesh.getFaces();
    var tagEdges = new Int32Array(baseMesh.getNbEdges());
    var i = 0;
    var nbFaces = baseMesh.getNbFaces();
    var acc = 0;
    var triFaceOrQuadCenter = new Int32Array(nbFaces / 4);
    var centerQuadUp = new Int32Array(baseMesh.getNbVertices());
    var fArDown = new Int32Array(nbFaces);
    for (i = 0; i < nbFaces; ++i)
      fArDown[i] = -1;
    for (i = 0; i < nbFaces; ++i) {
      var j = i * 4;
      var iv1 = fArUp[j];
      var iv2 = fArUp[j + 1];
      var iv3 = fArUp[j + 2];
      var iv4 = fArUp[j + 3];
      var tag1 = vEvenTags[iv1];
      var tag2 = vEvenTags[iv2];
      var tag3 = vEvenTags[iv3];
      if (iv4 < 0) {
        // center tri
        if (tag1 + tag2 + tag3 === -3) {
          triFaceOrQuadCenter[acc++] = i;
          continue;
        }
        // tri
        if (tag1 === 1) tagEdges[feAr[j + 1]] = iv1 + 1;
        else if (tag2 === 1) tagEdges[feAr[j + 2]] = iv2 + 1;
        else if (tag3 === 1) tagEdges[feAr[j]] = iv3 + 1;
        continue;
      }
      //quad
      var ivCorner = 0;
      var ivCenter = 0;
      var oppEdge = 0;
      if (tag1 === 1) {
        ivCorner = iv1;
        ivCenter = iv3;
        oppEdge = tagEdges[feAr[j + 1]] - 1;
        tagEdges[feAr[j + 2]] = iv1 + 1;
      } else if (tag2 === 1) {
        ivCorner = iv2;
        ivCenter = iv4;
        oppEdge = tagEdges[feAr[j + 2]] - 1;
        tagEdges[feAr[j + 3]] = iv2 + 1;
      } else if (tag3 === 1) {
        ivCorner = iv3;
        ivCenter = iv1;
        oppEdge = tagEdges[feAr[j + 3]] - 1;
        tagEdges[feAr[j]] = iv3 + 1;
      } else {
        ivCorner = iv4;
        ivCenter = iv2;
        oppEdge = tagEdges[feAr[j]] - 1;
        tagEdges[feAr[j + 1]] = iv4 + 1;
      }
      var quad = centerQuadUp[ivCenter] - 1;
      if (quad < 0) {
        triFaceOrQuadCenter[acc] = -ivCenter - 1;
        fArDown[acc * 4 + 3] = ivCorner;
        centerQuadUp[ivCenter] = ++acc;
        continue;
      }
      var idQuad = quad * 4;
      if (oppEdge < 0) {
        // no opposite edge
        if (fArDown[idQuad + 2] < 0) {
          fArDown[idQuad + 2] = ivCorner;
          fArDown[idQuad] = -2;
        } else if (fArDown[idQuad] === -1) {
          fArDown[idQuad + 1] = ivCorner;
        } else {
          fArDown[idQuad + 1] = fArDown[idQuad + 2];
          fArDown[idQuad + 2] = ivCorner;
        }
      } else {
        // insert after oppEdge
        if (fArDown[idQuad + 1] === oppEdge) {
          fArDown[idQuad] = ivCorner;
        } else {
          fArDown[idQuad] = fArDown[idQuad + 1];
          if (fArDown[idQuad + 2] === oppEdge) {
            fArDown[idQuad + 1] = ivCorner;
          } else {
            fArDown[idQuad + 1] = fArDown[idQuad + 2];
            fArDown[idQuad + 2] = ivCorner;
          }
        }
      }
    }
    nbFaces /= 4;
    for (i = 0; i < nbFaces; ++i) {
      var cen = triFaceOrQuadCenter[i];
      var idFace = i * 4;
      if (cen < 0) { // quad
        // Sometimes... the way we revert quads does not always work
        // because of non-consistency clock wise order between neighbor quads
        if (fArDown[idFace] < 0 || fArDown[idFace + 1] < 0 || fArDown[idFace + 2] < 0)
          return false;
        continue;
      }
      // tri
      var id = cen * 4;
      fArDown[idFace] = tagEdges[feAr[id]] - 1;
      fArDown[idFace + 1] = tagEdges[feAr[id + 1]] - 1;
      fArDown[idFace + 2] = tagEdges[feAr[id + 2]] - 1;
    }
    newMesh.setFaces(fArDown);
    return triFaceOrQuadCenter;
  };

  /** Creates the vertices of the mesh */
  var createVertices = function (baseMesh, newMesh, triFaceOrQuadCenter) {
    var acc = 0;
    var vertexMapUp = new Uint32Array(baseMesh.getNbVertices());
    newMesh.setVerticesMapping(vertexMapUp);
    var fArDown = newMesh.getFaces();
    var tagVert = new Float32Array(baseMesh.getNbVertices());
    var i = 0;
    var len = fArDown.length;
    for (i = 0; i < len; ++i) {
      var iv = fArDown[i];
      if (iv === -1)
        continue;
      var tag = tagVert[iv] - 1;
      if (tag === -1) {
        tag = acc++;
        tagVert[iv] = tag + 1;
        vertexMapUp[tag] = iv;
      }
      fArDown[i] = tag;
    }
    newMesh.setVertices(new Float32Array(acc * 3));
    var fArUp = baseMesh.getFaces();
    var vrf = baseMesh.getVerticesRingFace();
    var vrfStartCount = baseMesh.getVerticesRingFaceStartCount();
    var tagMid = new Uint8Array(baseMesh.getNbVertices());
    len /= 4;
    for (i = 0; i < len; ++i) {
      var iCenter = triFaceOrQuadCenter[i];
      var mid1, mid2, mid3, mid4, mid5;
      var tag1, tag2, tag3, tag4, tag5;
      if (iCenter >= 0) {
        // tri
        var id = iCenter * 4;
        mid1 = fArUp[id + 1];
        mid2 = fArUp[id + 2];
        mid3 = fArUp[id];
        mid4 = -1;
        mid5 = -1;
      } else {
        // quad
        mid5 = -iCenter - 1;
        var idQuadDown = i * 4;
        var corner1 = vertexMapUp[fArDown[idQuadDown]];
        var corner2 = vertexMapUp[fArDown[idQuadDown + 1]];
        var corner3 = vertexMapUp[fArDown[idQuadDown + 2]];
        var corner4 = vertexMapUp[fArDown[idQuadDown + 3]];
        var start = vrfStartCount[mid5 * 2];
        var end = start + 4;
        for (var j = start; j < end; ++j) {
          var idQuad = vrf[j] * 4;
          var id1 = fArUp[idQuad];
          var id2 = fArUp[idQuad + 1];
          var id3 = fArUp[idQuad + 2];
          var id4 = fArUp[idQuad + 3];
          if (id1 === corner1) mid1 = id2;
          else if (id2 === corner1) mid1 = id3;
          else if (id3 === corner1) mid1 = id4;
          else if (id4 === corner1) mid1 = id1;

          if (id1 === corner2) mid2 = id2;
          else if (id2 === corner2) mid2 = id3;
          else if (id3 === corner2) mid2 = id4;
          else if (id4 === corner2) mid2 = id1;

          if (id1 === corner3) mid3 = id2;
          else if (id2 === corner3) mid3 = id3;
          else if (id3 === corner3) mid3 = id4;
          else if (id4 === corner3) mid3 = id1;

          if (id1 === corner4) mid4 = id2;
          else if (id2 === corner4) mid4 = id3;
          else if (id3 === corner4) mid4 = id4;
          else if (id4 === corner4) mid4 = id1;
        }
      }
      tag1 = tagMid[mid1];
      tag2 = tagMid[mid2];
      tag3 = tagMid[mid3];
      tag4 = mid4 >= 0 ? tagMid[mid4] : -1;
      tag5 = mid5 >= 0 ? tagMid[mid5] : -1;
      if (tag1 === 0) {
        tagMid[mid1] = 1;
        vertexMapUp[acc++] = mid1;
      }
      if (tag2 === 0) {
        tagMid[mid2] = 1;
        vertexMapUp[acc++] = mid2;
      }
      if (tag3 === 0) {
        tagMid[mid3] = 1;
        vertexMapUp[acc++] = mid3;
      }
      if (tag4 === 0) {
        tagMid[mid4] = 1;
        vertexMapUp[acc++] = mid4;
      }
      if (tag5 === 0) {
        tagMid[mid5] = 1;
        vertexMapUp[acc++] = mid5;
      }
    }
  };

  /** Copy the vertices data from up to low */
  var copyVerticesData = function (baseMesh, newMesh) {
    var vArUp = baseMesh.getVertices();
    var cArUp = baseMesh.getColors();
    var mArUp = baseMesh.getMaterials();
    var vArDown = newMesh.getVertices();
    var cArDown = new Float32Array(vArDown.length);
    var mArDown = new Float32Array(vArDown.length);
    newMesh.setColors(cArDown);
    newMesh.setMaterials(mArDown);
    var vertexMapUp = newMesh.getVerticesMapping();
    var i = 0;
    var nbVertices = newMesh.getNbVertices();
    for (i = 0; i < nbVertices; ++i) {
      if (vertexMapUp[i] >= nbVertices)
        break;
    }
    if (i === nbVertices) {
      // we don't have to keep the vertex mapping
      var fArDown = newMesh.getFaces();
      var nb = fArDown.length;
      for (i = 0; i < nb; ++i) {
        var idv = fArDown[i];
        if (idv >= 0)
          fArDown[i] = vertexMapUp[idv];
      }
      // direct mapping for even vertices
      for (i = 0; i < nbVertices; ++i)
        vertexMapUp[i] = i;
      vArDown.set(vArUp.subarray(0, nbVertices * 3));
      cArDown.set(cArUp.subarray(0, nbVertices * 3));
      mArDown.set(mArUp.subarray(0, nbVertices * 3));
    } else {
      // we keep the vertex mapping
      newMesh.setEvenMapping(true);
      for (i = 0; i < nbVertices; ++i) {
        var id = i * 3;
        var idUp = vertexMapUp[i] * 3;
        vArDown[id] = vArUp[idUp];
        vArDown[id + 1] = vArUp[idUp + 1];
        vArDown[id + 2] = vArUp[idUp + 2];
        cArDown[id] = cArUp[idUp];
        cArDown[id + 1] = cArUp[idUp + 1];
        cArDown[id + 2] = cArUp[idUp + 2];
        mArDown[id] = mArUp[idUp];
        mArDown[id + 1] = mArUp[idUp + 1];
        mArDown[id + 2] = mArUp[idUp + 2];
      }
    }
  };

  /** Apply the reverse of a subdivision for the texCoord mesh */
  var computeTexCoords = function (baseMesh, newMesh, triFaceOrQuadCenter) {
    var dupUp = baseMesh.getVerticesDuplicateStartCount();

    var nbVertices = newMesh.getNbVertices();
    var dup = new Uint32Array(nbVertices * 2);
    var vertexMapUp = newMesh.getVerticesMapping();

    var uvArUp = baseMesh.getTexCoords();
    var uvAr = new Float32Array(Utils.getMemory(baseMesh.getNbTexCoords() * 4 * 2), 0, baseMesh.getNbTexCoords() * 2);
    var uvMap = new Uint32Array(nbVertices);
    var nbTexCoords = nbVertices;
    for (var i = 0; i < nbVertices; ++i) {
      var ivUp = vertexMapUp[i];
      var start = dupUp[ivUp * 2];
      uvAr[i * 2] = uvArUp[ivUp * 2];
      uvAr[i * 2 + 1] = uvArUp[ivUp * 2 + 1];
      if (start === 0)
        continue;
      // vertex with duplicates
      var startOld = uvMap[i] = start - nbTexCoords;
      var nbDupl = dupUp[ivUp * 2 + 1];
      for (var j = nbTexCoords, end = nbTexCoords + nbDupl; j < end; ++j) {
        uvAr[j * 2] = uvArUp[(startOld + j) * 2];
        uvAr[j * 2 + 1] = uvArUp[(startOld + j) * 2 + 1];
      }
      dup[i * 2] = nbTexCoords;
      dup[i * 2 + 1] = nbDupl;
      nbTexCoords += nbDupl;
    }
    newMesh.setTexCoords(new Float32Array(uvAr.subarray(0, nbTexCoords * 2)));
    newMesh.setVerticesDuplicateStartCount(dup);

    computeFaceTexCoords(baseMesh, newMesh, triFaceOrQuadCenter, uvMap);
  };

  /** Computes uv faces and uv coordinates for center vertices */
  var computeFaceTexCoords = function (baseMesh, newMesh, triFaceOrQuadCenter, uvMap) {
    var fArUp = baseMesh.getFaces();
    var fArUVUp = baseMesh.getFacesTexCoord();
    var vrfSC = baseMesh.getVerticesRingFaceStartCount();
    var vrf = baseMesh.getVerticesRingFace();
    var dupUp = baseMesh.getVerticesDuplicateStartCount();

    var fAr = newMesh.getFaces();
    var fArUV = new Int32Array(fAr);
    var vertexMapUp = newMesh.getVerticesMapping();

    for (var i = 0, len = fAr.length; i < len; ++i) {
      var iv = fAr[i];
      if (iv < 0)
        continue;
      var ivUp = vertexMapUp[iv];
      if (dupUp[ivUp * 2] === 0)
        continue;
      // vertex with duplicates
      var index = i % 4;
      var iCen = triFaceOrQuadCenter[(i - index) / 4];
      var vertUV = -1;
      if (iCen >= 0) {
        // tri
        var idCen = iCen * 4;
        var mid1, mid2;
        if (index === 0) {
          mid1 = fArUp[idCen + 1];
          mid2 = fArUp[idCen];
        } else if (index === 1) {
          mid1 = fArUp[idCen + 2];
          mid2 = fArUp[idCen + 1];
        } else {
          mid1 = fArUp[idCen];
          mid2 = fArUp[idCen + 2];
        }
        var startTri = vrfSC[ivUp * 2];
        var endTri = startTri + vrfSC[ivUp * 2 + 1];
        for (var idt = startTri; idt < endTri; ++idt) {
          var idTri = vrf[idt] * 4;
          var idMid1 = fArUp[idTri];
          var idMid2 = fArUp[idTri + 1];
          var idMid3 = fArUp[idTri + 2];
          if (idMid1 === mid1) {
            if (idMid2 === mid2) vertUV = fArUVUp[idTri + 2];
          } else if (idMid2 === mid1) {
            if (idMid3 === mid2) vertUV = fArUVUp[idTri];
          } else if (idMid3 === mid1) {
            if (idMid1 === mid2) vertUV = fArUVUp[idTri + 1];
          }
          if (vertUV >= 0) break;
        }
      } else {
        // quad
        iCen = -iCen - 1;
        var startQuad = vrfSC[iCen * 2];
        var endQuad = startQuad + 4;
        for (var idq = startQuad; idq < endQuad; ++idq) {
          var idQuad = vrf[idq] * 4;
          if (fArUp[idQuad] === ivUp) vertUV = fArUVUp[idQuad];
          else if (fArUp[idQuad + 1] === ivUp) vertUV = fArUVUp[idQuad + 1];
          else if (fArUp[idQuad + 2] === ivUp) vertUV = fArUVUp[idQuad + 2];
          else if (fArUp[idQuad + 3] === ivUp) vertUV = fArUVUp[idQuad + 3];
          if (vertUV >= 0) break;
        }
      }
      fArUV[i] = vertUV === ivUp ? vertUV : vertUV - uvMap[iv];
    }

    newMesh.setFacesTexCoord(fArUV);
  };

  /** Apply the reverse of a subdivision */
  Reversion.computeReverse = function (baseMesh, newMesh) {
    if (baseMesh.getNbFaces() % 4 !== 0)
      return false;
    var vEvenTags = tagEvenVertices(baseMesh);
    if (!vEvenTags)
      return false;
    var triFaceOrQuadCenter = createFaces(baseMesh, newMesh, vEvenTags);
    if (!triFaceOrQuadCenter)
      return false;
    createVertices(baseMesh, newMesh, triFaceOrQuadCenter);
    copyVerticesData(baseMesh, newMesh);
    if (baseMesh.hasUV())
      computeTexCoords(baseMesh, newMesh, triFaceOrQuadCenter);
    newMesh.allocateArrays();
    return true;
  };

  module.exports = Reversion;
});
define('mesh/multiresolution/Multimesh',['require','exports','module','misc/Utils','mesh/multiresolution/MeshResolution','mesh/multiresolution/LowRender','editing/Subdivision','editing/Reversion'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var MeshResolution = require('mesh/multiresolution/MeshResolution');
  var LowRender = require('mesh/multiresolution/LowRender');
  var Subdivision = require('editing/Subdivision');
  var Reversion = require('editing/Reversion');

  var Multimesh = function (mesh) {
    // every submeshes will share the same render/transformData
    mesh.getRender()._mesh = this;
    mesh.getTransformData()._mesh = this;
    this._meshes = [new MeshResolution(mesh.getTransformData(), mesh.getRender(), mesh)];
    this._sel = 0;
    this._lowRender = new LowRender(mesh.getRender());
  };

  Multimesh.RENDER_HINT = 0;
  Multimesh.NONE = 0;
  Multimesh.SCULPT = 1;
  Multimesh.CAMERA = 2;
  Multimesh.PICKING = 3;

  Multimesh.prototype = {
    getCurrentMesh: function () {
      return this._meshes[this._sel];
    },
    addLevel: function () {
      if ((this._meshes.length - 1) !== this._sel)
        return this.getCurrentMesh();
      var baseMesh = this.getCurrentMesh();
      var newMesh = new MeshResolution(baseMesh.getTransformData(), baseMesh.getRender());
      newMesh.setID(this.getID());
      baseMesh.setVerticesMapping(undefined);

      Subdivision.fullSubdivision(baseMesh, newMesh);
      newMesh.initTopology();

      this.pushMesh(newMesh);
      this.getRender().initRender();
      return newMesh;
    },
    computeReverse: function () {
      if (this._sel !== 0)
        return this.getCurrentMesh();
      var baseMesh = this.getCurrentMesh();
      var newMesh = new MeshResolution(baseMesh.getTransformData(), baseMesh.getRender());
      newMesh.setID(this.getID());

      var status = Reversion.computeReverse(baseMesh, newMesh);
      if (!status)
        return;
      newMesh.initTopology();

      this.unshiftMesh(newMesh);
      this.getRender().initRender();
      return newMesh;
    },
    lowerLevel: function () {
      if (this._sel === 0)
        return this._meshes[0];
      this._meshes[this._sel - 1].lowerAnalysis(this.getCurrentMesh());
      --this._sel;
      this.updateResolution();
      return this.getCurrentMesh();
    },
    higherLevel: function () {
      if (this._sel === this._meshes.length - 1)
        return this.getCurrentMesh();
      this._meshes[this._sel + 1].higherSynthesis(this.getCurrentMesh());
      ++this._sel;
      this.updateResolution();
      return this.getCurrentMesh();
    },
    updateResolution: function () {
      this.updateGeometry();
      this.updateDuplicateColorsAndMaterials();
      this.updateBuffers();
      this._lowRender.updateBuffers(this._meshes[this.getLowIndexRender()]);
    },
    selectResolution: function (sel) {
      while (this._sel > sel) {
        this.lowerLevel();
      }
      while (this._sel < sel) {
        this.higherLevel();
      }
    },
    findIndexFromMesh: function (mesh) {
      var meshes = this._meshes;
      for (var i = 0, l = meshes.length; i < l; ++i) {
        if (mesh === meshes[i])
          return i;
      }
    },
    selectMesh: function (mesh) {
      var val = this.findIndexFromMesh(mesh);
      this.selectResolution(val);
    },
    pushMesh: function (mesh) {
      this._meshes.push(mesh);
      this._sel = this._meshes.length - 1;
      this.updateResolution();
    },
    unshiftMesh: function (mesh) {
      this._meshes.unshift(mesh);
      this._sel = 1;
      this.lowerLevel();
    },
    popMesh: function () {
      this._meshes.pop();
      this._sel = this._meshes.length - 1;
      this.updateResolution();
    },
    shiftMesh: function () {
      this._meshes.shift();
      this._sel = 0;
      this.updateResolution();
    },
    deleteLower: function () {
      this._meshes.splice(0, this._sel);
      this._sel = 0;
    },
    deleteHigher: function () {
      this._meshes.splice(this._sel + 1);
    },
    getLowIndexRender: function () {
      var limit = 500000;
      var sel = this._sel;
      while (sel >= 0) {
        var mesh = this._meshes[sel];
        // we disable low rendering for lower resolution mesh with
        // an index indirection for even vertices
        if (mesh.getEvenMapping() === true)
          return sel === this._sel ? sel : sel + 1;
        if (mesh.getNbTriangles() < limit)
          return sel;
        --sel;
      }
      return 0;
    },
    _renderLow: function (main) {
      var tmpSel = this._sel;
      this._sel = this.getLowIndexRender();
      this._lowRender.render(main);
      this._sel = tmpSel;
    },
    _renderWireframeLow: function (main) {
      var tmpSel = this._sel;
      this._sel = this.getLowIndexRender();
      this._lowRender.renderWireframe(main);
      this._sel = tmpSel;
    },
    _canUseLowRender: function (main) {
      if (this.getCurrentMesh().isUsingTexCoords() || this.isUsingDrawArrays()) return false;
      if (Multimesh.RENDER_HINT === Multimesh.PICKING || Multimesh.RENDER_HINT === Multimesh.NONE) return false;
      if (main.getMesh() === this && Multimesh.RENDER_HINT !== Multimesh.CAMERA) return false;
      if (this.getLowIndexRender() === this._sel) return false;
      return true;
    },
    render: function (main) {
      return this._canUseLowRender(main) ? this._renderLow(main) : this.getCurrentMesh().render(main);
    },
    renderWireframe: function (main) {
      return this._canUseLowRender(main) ? this._renderWireframeLow(main) : this.getCurrentMesh().renderWireframe(main);
    }
  };

  Utils.makeProxy(MeshResolution, Multimesh, function (proto) {
    return function () {
      return proto.apply(this.getCurrentMesh(), arguments);
    };
  });

  module.exports = Multimesh;
});
define('mesh/dynamic/Subdivision',['require','exports','module','lib/glMatrix','misc/Utils','math3d/Geometry','editing/tools/Smooth'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Utils = require('misc/Utils');
  var Geometry = require('math3d/Geometry');
  var Smooth = require('editing/tools/Smooth');

  var vec3 = glm.vec3;

  var Subdivision = function (mesh) {
    this._mesh = mesh;
    this._linear = false; // linear subdivision
    this._verticesMap = new Map(); // to detect new vertices at the middle of edge (for subdivision)
    this._states = null; // for undo-redo

    this._center = [0.0, 0.0, 0.0]; // center point of select sphere
    this._radius2 = 0.0; // radius squared of select sphere

    this._edgeMax2 = 0.0; // maximal squared edge length before we subdivide it
  };

  Subdivision.prototype = {
    /** Subdivide until every selected triangles comply with a detail level */
    subdivision: function (iTris, center, radius2, detail2, states) {
      vec3.copy(this._center, center);
      this._radius2 = radius2;
      this._edgeMax2 = detail2;
      this._states = states;
      var mesh = this._mesh;
      var nbTriangles = 0;
      while (nbTriangles !== mesh.getNbTriangles()) {
        nbTriangles = mesh.getNbTriangles();
        iTris = this.subdivide(iTris);
      }
      return iTris;
    },
    /**
     * Subdivide a set of triangle. Main steps are :
     * 1. Detect the triangles that need to be split, and at which edge the split should occur
     * 2. Subdivide all those triangles (split them in two)
     * 3. Take the 2-ring neighborhood of the triangles that have been split
     * 4. Fill the triangles (just create an edge where it's needed)
     * 5. Smooth newly created vertices (along the plane defined by their own normals)
     * 6. Tag the newly created vertices if they are inside the sculpt brush radius
     */
    subdivide: function (iTris) {
      var mesh = this._mesh;
      var nbVertsInit = mesh.getNbVertices();
      var nbTrisInit = mesh.getNbTriangles();
      this._verticesMap = new Map();

      var res = this.initSplit(iTris);
      var iTrisSubd = res[0];
      var split = res[1];
      if (iTrisSubd.length > 5) {
        iTrisSubd = mesh.expandsFaces(iTrisSubd, 3);
        split = new Uint8Array(iTrisSubd.length);
        split.set(res[1]);
      }

      // undo-redo
      this._states.pushVertices(mesh.getVerticesFromFaces(iTrisSubd));
      this._states.pushFaces(iTrisSubd);

      mesh.reAllocateArrays(split.length);
      this.subdivideTriangles(iTrisSubd, split);

      var i = 0;
      var nbNewTris = mesh.getNbTriangles() - nbTrisInit;
      var newTriangles = new Uint32Array(nbNewTris);
      for (i = 0; i < nbNewTris; ++i)
        newTriangles[i] = nbTrisInit + i;
      newTriangles = mesh.expandsFaces(newTriangles, 1);

      // undo-redo
      iTrisSubd = newTriangles.subarray(nbNewTris);
      this._states.pushVertices(mesh.getVerticesFromFaces(iTrisSubd));
      this._states.pushFaces(iTrisSubd);

      var temp = iTris;
      var nbTris = iTris.length;
      iTris = new Uint32Array(nbTris + newTriangles.length);
      iTris.set(temp);
      iTris.set(newTriangles, nbTris);

      var ftf = mesh.getFacesTagFlags();
      var nbTrisMask = iTris.length;
      var iTrisMask = new Uint32Array(Utils.getMemory(nbTrisMask * 4), 0, nbTrisMask);
      var nbTriMask = 0;
      var tagFlag = ++Utils.TAG_FLAG;
      for (i = 0; i < nbTrisMask; ++i) {
        var iTri = iTris[i];
        if (ftf[iTri] === tagFlag)
          continue;
        ftf[iTri] = tagFlag;
        iTrisMask[nbTriMask++] = iTri;
      }
      iTrisMask = new Uint32Array(iTrisMask.subarray(0, nbTriMask));

      var nbTrianglesOld = mesh.getNbTriangles();
      while (newTriangles.length > 0) {
        mesh.reAllocateArrays(newTriangles.length);
        newTriangles = this.fillTriangles(newTriangles);
      }

      nbNewTris = mesh.getNbTriangles() - nbTrianglesOld;
      temp = iTrisMask;
      iTrisMask = new Uint32Array(nbTriMask + nbNewTris);
      iTrisMask.set(temp);
      for (i = 0; i < nbNewTris; ++i)
        iTrisMask[nbTriMask + i] = nbTrianglesOld + i;

      var nbVNew = mesh.getNbVertices() - nbVertsInit;
      var vNew = new Uint32Array(nbVNew);
      for (i = 0; i < nbVNew; ++i)
        vNew[i] = nbVertsInit + i;

      vNew = mesh.expandsVertices(vNew, 1);
      if (!this._linear) {
        var expV = vNew.subarray(nbVNew);
        var smo = new Smooth();
        smo.setToolMesh(mesh);
        smo.smoothTangent(expV, 1.0);
        mesh.updateTopology(mesh.getFacesFromVertices(expV));
      }

      var vAr = mesh.getVertices();
      var vscf = mesh.getVerticesSculptFlags();
      var centerPoint = this._center;
      var xcen = centerPoint[0];
      var ycen = centerPoint[1];
      var zcen = centerPoint[2];

      var vertexSculptMask = Utils.SCULPT_FLAG;
      nbVNew = vNew.length;
      for (i = 0; i < nbVNew; ++i) {
        var ind = vNew[i];
        var j = ind * 3;
        var dx = vAr[j] - xcen;
        var dy = vAr[j + 1] - ycen;
        var dz = vAr[j + 2] - zcen;
        vscf[ind] = (dx * dx + dy * dy + dz * dz) < this._radius2 ? vertexSculptMask : vertexSculptMask - 1;
      }
      return iTrisMask;
    },
    /** Detect which triangles to split and the edge that need to be split */
    initSplit: function (iTris) {
      var nbTris = iTris.length;

      var buffer = Utils.getMemory((4 + 1) * nbTris);
      var iTrisSubd = new Uint32Array(buffer, 0, nbTris);
      var split = new Uint8Array(buffer, 4 * nbTris, nbTris);

      var acc = 0;
      for (var i = 0; i < nbTris; ++i) {
        var iTri = iTris[i];
        var splitNum = this.findSplit(iTri, true);
        if (splitNum === 0) continue;
        split[acc] = splitNum;
        iTrisSubd[acc++] = iTri;
      }
      return [new Uint32Array(iTrisSubd.subarray(0, acc)), new Uint8Array(split.subarray(0, acc))];
    },
    /** Find the edge to be split (0 otherwise) */
    findSplit: (function () {
      var v1 = [0.0, 0.0, 0.0];
      var v2 = [0.0, 0.0, 0.0];
      var v3 = [0.0, 0.0, 0.0];
      var tis = Geometry.triangleInsideSphere;
      var pit = Geometry.pointInsideTriangle;
      return function (iTri, checkInsideSphere) {
        var mesh = this._mesh;
        var vAr = mesh.getVertices();
        var fAr = mesh.getFaces();

        var id = iTri * 4;
        var ind1 = fAr[id] * 3;
        var ind2 = fAr[id + 1] * 3;
        var ind3 = fAr[id + 2] * 3;
        v1[0] = vAr[ind1];
        v1[1] = vAr[ind1 + 1];
        v1[2] = vAr[ind1 + 2];
        v2[0] = vAr[ind2];
        v2[1] = vAr[ind2 + 1];
        v2[2] = vAr[ind2 + 2];
        v3[0] = vAr[ind3];
        v3[1] = vAr[ind3 + 1];
        v3[2] = vAr[ind3 + 2];

        if (checkInsideSphere && !tis(this._center, this._radius2, v1, v2, v3) && !pit(this._center, v1, v2, v3))
          return 0;

        var length1 = vec3.sqrDist(v1, v2);
        var length2 = vec3.sqrDist(v2, v3);
        var length3 = vec3.sqrDist(v1, v3);
        if (length1 > length2 && length1 > length3) return length1 > this._edgeMax2 ? 1 : 0;
        else if (length2 > length3) return length2 > this._edgeMax2 ? 2 : 0;
        else return length3 > this._edgeMax2 ? 3 : 0;
      };
    })(),

    /** Subdivide all the triangles that need to be subdivided */
    subdivideTriangles: function (iTrisSubd, split) {
      var fAr = this._mesh.getFaces();
      var nbTris = iTrisSubd.length;
      for (var i = 0; i < nbTris; ++i) {
        var iTri = iTrisSubd[i];
        var splitNum = split[i];
        if (splitNum === 0) splitNum = this.findSplit(iTri);
        var ind = iTri * 4;
        if (splitNum === 1) this.halfEdgeSplit(iTri, fAr[ind], fAr[ind + 1], fAr[ind + 2]);
        else if (splitNum === 2) this.halfEdgeSplit(iTri, fAr[ind + 1], fAr[ind + 2], fAr[ind]);
        else if (splitNum === 3) this.halfEdgeSplit(iTri, fAr[ind + 2], fAr[ind], fAr[ind + 1]);
      }
    },
    /**
     * Subdivide one triangle, it simply cut the triangle in two at a given edge.
     * The position of the vertex is computed as follow :
     * 1. Initial position of the new vertex at the middle of the edge
     * 2. Compute normal of the new vertex (average of the two normals of the two vertices defining the edge)
     * 3. Compute angle between those two normals
     * 4. Move the new vertex along its normal with a strengh proportional to the angle computed at step 3.
     */
    halfEdgeSplit: function (iTri, iv1, iv2, iv3) {
      var mesh = this._mesh;
      var vAr = mesh.getVertices();
      var nAr = mesh.getNormals();
      var cAr = mesh.getColors();
      var mAr = mesh.getMaterials();
      var fAr = mesh.getFaces();

      var pil = mesh.getFacePosInLeaf();
      var fleaf = mesh.getFaceLeaf();
      var vrv = mesh.getVerticesRingVert();
      var vrf = mesh.getVerticesRingFace();
      var fstf = mesh.getFacesStateFlags();
      var vstf = mesh.getVerticesStateFlags();

      var vMap = this._verticesMap;
      var key = Math.min(iv1, iv2) + '+' + Math.max(iv1, iv2);
      var isNewVertex = false;
      var ivMid = vMap.get(key);
      if (ivMid === undefined) {
        ivMid = mesh.getNbVertices();
        isNewVertex = true;
        vMap.set(key, ivMid);
      }

      vrv[iv3].push(ivMid);
      var id = iTri * 4;
      fAr[id] = iv1;
      fAr[id + 1] = ivMid;
      fAr[id + 2] = iv3;
      fAr[id + 3] = -1;

      var iNewTri = mesh.getNbTriangles();
      id = iNewTri * 4;
      fAr[id] = ivMid;
      fAr[id + 1] = iv2;
      fAr[id + 2] = iv3;
      fAr[id + 3] = -1;
      fstf[iNewTri] = Utils.STATE_FLAG;

      vrf[iv3].push(iNewTri);
      Utils.replaceElement(vrf[iv2], iTri, iNewTri);
      var leaf = fleaf[iTri];
      var iTrisLeaf = leaf._iFaces;
      fleaf[iNewTri] = leaf;
      pil[iNewTri] = iTrisLeaf.length;
      iTrisLeaf.push(iNewTri);

      if (!isNewVertex) {
        vrv[ivMid].push(iv3);
        vrf[ivMid].push(iTri, iNewTri);
        mesh.addNbFace(1);
        return;
      }
      //new vertex
      var iNewVer = mesh.getNbVertices();

      var id1 = iv1 * 3;
      var v1x = vAr[id1];
      var v1y = vAr[id1 + 1];
      var v1z = vAr[id1 + 2];
      var n1x = nAr[id1];
      var n1y = nAr[id1 + 1];
      var n1z = nAr[id1 + 2];

      var id2 = iv2 * 3;
      var v2x = vAr[id2];
      var v2y = vAr[id2 + 1];
      var v2z = vAr[id2 + 2];
      var n2x = nAr[id2];
      var n2y = nAr[id2 + 1];
      var n2z = nAr[id2 + 2];

      var n1n2x = n1x + n2x;
      var n1n2y = n1y + n2y;
      var n1n2z = n1z + n2z;
      id = iNewVer * 3;
      nAr[id] = n1n2x * 0.5;
      nAr[id + 1] = n1n2y * 0.5;
      nAr[id + 2] = n1n2z * 0.5;
      cAr[id] = (cAr[id1] + cAr[id2]) * 0.5;
      cAr[id + 1] = (cAr[id1 + 1] + cAr[id2 + 1]) * 0.5;
      cAr[id + 2] = (cAr[id1 + 2] + cAr[id2 + 2]) * 0.5;
      mAr[id] = (mAr[id1] + mAr[id2]) * 0.5;
      mAr[id + 1] = (mAr[id1 + 1] + mAr[id2 + 1]) * 0.5;
      mAr[id + 2] = (mAr[id1 + 2] + mAr[id2 + 2]) * 0.5;

      var offset = 0;
      if (this._linear) {
        vAr[id] = (v1x + v2x) * 0.5;
        vAr[id + 1] = (v1y + v2y) * 0.5;
        vAr[id + 2] = (v1z + v2z) * 0.5;
      } else {
        var len = n1x * n1x + n1y * n1y + n1z * n1z;
        if (len === 0.0) {
          n1x = 1.0;
        } else {
          len = 1.0 / Math.sqrt(len);
          n1x *= len;
          n1y *= len;
          n1z *= len;
        }
        len = n2x * n2x + n2y * n2y + n2z * n2z;
        if (len === 0.0) {
          n2x = 1.0;
        } else {
          len = 1.0 / Math.sqrt(len);
          n2x *= len;
          n2y *= len;
          n2z *= len;
        }
        var dot = n1x * n2x + n1y * n2y + n1z * n2z;
        var angle = 0;
        if (dot <= -1) angle = Math.PI;
        else if (dot >= 1) angle = 0;
        else angle = Math.acos(dot);

        var edgex = v1x - v2x;
        var edgey = v1y - v2y;
        var edgez = v1z - v2z;
        offset = angle * 0.12;
        offset *= Math.sqrt(edgex * edgex + edgey * edgey + edgez * edgez);
        len = n1n2x * n1n2x + n1n2y * n1n2y + n1n2z * n1n2z;
        if (len > 0) offset /= Math.sqrt(len);

        if ((edgex * (n1x - n2x) + edgey * (n1y - n2y) + edgez * (n1z - n2z)) < 0)
          offset = -offset;
        vAr[id] = (v1x + v2x) * 0.5 + n1n2x * offset;
        vAr[id + 1] = (v1y + v2y) * 0.5 + n1n2y * offset;
        vAr[id + 2] = (v1z + v2z) * 0.5 + n1n2z * offset;
      }

      vstf[iNewVer] = Utils.STATE_FLAG;
      vrv[iNewVer] = [iv1, iv2, iv3];
      vrf[iNewVer] = [iTri, iNewTri];
      Utils.replaceElement(vrv[iv1], iv2, ivMid);
      Utils.replaceElement(vrv[iv2], iv1, ivMid);
      mesh.addNbVertice(1);
      mesh.addNbFace(1);
    },
    /**
     * Fill the triangles. It checks if a newly vertex has been created at the middle
     * of the edge. If several split are needed, it first chooses the split that minimize
     * the valence of the vertex.
     */
    fillTriangles: function (iTris) {
      var mesh = this._mesh;
      var vrv = mesh.getVerticesRingVert();
      var fAr = mesh.getFaces();

      var nbTris = iTris.length;
      var iTrisNext = new Uint32Array(Utils.getMemory(4 * 2 * nbTris), 0, 2 * nbTris);
      var nbNext = 0;
      var vMap = this._verticesMap;
      for (var i = 0; i < nbTris; ++i) {
        var iTri = iTris[i];
        var j = iTri * 4;
        var iv1 = fAr[j];
        var iv2 = fAr[j + 1];
        var iv3 = fAr[j + 2];

        var val1 = vMap.get(Math.min(iv1, iv2) + '+' + Math.max(iv1, iv2));
        var val2 = vMap.get(Math.min(iv2, iv3) + '+' + Math.max(iv2, iv3));
        var val3 = vMap.get(Math.min(iv1, iv3) + '+' + Math.max(iv1, iv3));

        var num1 = vrv[iv1].length;
        var num2 = vrv[iv2].length;
        var num3 = vrv[iv3].length;
        var split = 0;
        if (val1) {
          if (val2) {
            if (val3) {
              if (num1 < num2 && num1 < num3) split = 2;
              else if (num2 < num3) split = 3;
              else split = 1;
            } else if (num1 < num3) split = 2;
            else split = 1;
          } else if (val3 && num2 < num3) split = 3;
          else split = 1;
        } else if (val2) {
          if (val3 && num2 < num1) split = 3;
          else split = 2;
        } else if (val3) split = 3;

        if (split === 1) this.fillTriangle(iTri, iv1, iv2, iv3, val1);
        else if (split === 2) this.fillTriangle(iTri, iv2, iv3, iv1, val2);
        else if (split === 3) this.fillTriangle(iTri, iv3, iv1, iv2, val3);
        else continue;
        iTrisNext[nbNext++] = iTri;
        iTrisNext[nbNext++] = mesh.getNbTriangles() - 1;
      }
      return new Uint32Array(iTrisNext.subarray(0, nbNext));
    },
    /** Fill crack on one triangle */
    fillTriangle: function (iTri, iv1, iv2, iv3, ivMid) {
      var mesh = this._mesh;

      var vrv = mesh.getVerticesRingVert();
      var vrf = mesh.getVerticesRingFace();
      var pil = mesh.getFacePosInLeaf();
      var fleaf = mesh.getFaceLeaf();
      var fstf = mesh.getFacesStateFlags();
      var fAr = mesh.getFaces();

      var j = iTri * 4;
      fAr[j] = iv1;
      fAr[j + 1] = ivMid;
      fAr[j + 2] = iv3;
      fAr[j + 3] = -1;
      var leaf = fleaf[iTri];
      var iTrisLeaf = leaf._iFaces;

      vrv[ivMid].push(iv3);
      vrv[iv3].push(ivMid);

      var iNewTri = mesh.getNbTriangles();
      vrf[ivMid].push(iTri, iNewTri);

      j = iNewTri * 4;
      fAr[j] = ivMid;
      fAr[j + 1] = iv2;
      fAr[j + 2] = iv3;
      fAr[j + 3] = -1;
      fstf[iNewTri] = Utils.STATE_FLAG;
      fleaf[iNewTri] = leaf;
      pil[iNewTri] = iTrisLeaf.length;

      vrf[iv3].push(iNewTri);
      Utils.replaceElement(vrf[iv2], iTri, iNewTri);

      iTrisLeaf.push(iNewTri);
      mesh.addNbFace(1);
    }
  };

  module.exports = Subdivision;
});
define('mesh/dynamic/Decimation',['require','exports','module','misc/Utils'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');

  var Decimation = function (mesh) {
    this._mesh = mesh;
    this._states = null; // for undo-redo

    this._iTrisToDelete = []; // triangles to be deleted
    this._iVertsToDelete = []; // vertices to be deleted
    this._iVertsDecimated = []; // vertices to be updated (mainly for the VBO's, used in decimation and adaptive topo)
  };

  var sortFunc = function (a, b) {
    return a - b;
  };

  Decimation.prototype = {
    /** Decimation */
    decimation: function (iTris, center, radius2, detail2, states) {
      this._states = states;
      this._iVertsDecimated.length = 0;
      this._iTrisToDelete.length = 0;
      this._iVertsToDelete.length = 0;

      var radius = Math.sqrt(radius2);
      var mesh = this._mesh;
      var ftf = mesh.getFacesTagFlags();
      var vAr = mesh.getVertices();
      var fAr = mesh.getFaces();

      var cenx = center[0];
      var ceny = center[1];
      var cenz = center[2];

      var i = 0;
      var nbInit = iTris.length;
      var dynArr = new Array(nbInit);
      for (i = 0; i < nbInit; ++i)
        dynArr[i] = iTris[i];

      for (i = 0; i < dynArr.length; ++i) {
        var iTri = dynArr[i];
        if (ftf[iTri] < 0)
          continue;

        var id = iTri * 4;
        var iv1 = fAr[id];
        var iv2 = fAr[id + 1];
        var iv3 = fAr[id + 2];

        id = iv1 * 3;
        var v1x = vAr[id];
        var v1y = vAr[id + 1];
        var v1z = vAr[id + 2];

        id = iv2 * 3;
        var v2x = vAr[id];
        var v2y = vAr[id + 1];
        var v2z = vAr[id + 2];

        id = iv3 * 3;
        var v3x = vAr[id];
        var v3y = vAr[id + 1];
        var v3z = vAr[id + 2];

        var dx = (v1x + v2x + v3x) / 3.0 - cenx;
        var dy = (v1y + v2y + v3y) / 3.0 - ceny;
        var dz = (v1z + v2z + v3z) / 3.0 - cenz;
        var fallOff = dx * dx + dy * dy + dz * dz;

        if (fallOff < radius2)
          fallOff = 1.0;
        else if (fallOff < radius2 * 2.0) {
          fallOff = (Math.sqrt(fallOff) - radius) / (radius * Math.SQRT2 - radius);
          var f2 = fallOff * fallOff;
          fallOff = 3.0 * f2 * f2 - 4.0 * f2 * fallOff + 1.0;
        } else
          continue;

        dx = v2x - v1x;
        dy = v2y - v1y;
        dz = v2z - v1z;
        var len1 = dx * dx + dy * dy + dz * dz;

        dx = v2x - v3x;
        dy = v2y - v3y;
        dz = v2z - v3z;
        var len2 = dx * dx + dy * dy + dz * dz;

        dx = v1x - v3x;
        dy = v1y - v3y;
        dz = v1z - v3z;
        var len3 = dx * dx + dy * dy + dz * dz;

        if (len1 < len2 && len1 < len3) {
          if (len1 < detail2 * fallOff)
            this.decimateTriangles(iTri, this.findOppositeTriangle(iTri, iv1, iv2), dynArr);
        } else if (len2 < len3) {
          if (len2 < detail2 * fallOff)
            this.decimateTriangles(iTri, this.findOppositeTriangle(iTri, iv2, iv3), dynArr);
        } else {
          if (len3 < detail2 * fallOff)
            this.decimateTriangles(iTri, this.findOppositeTriangle(iTri, iv1, iv3), dynArr);
        }
      }
      this.applyDeletion();
      iTris = this.getValidModifiedTriangles(this.getValidModifiedVertices(), dynArr);
      return iTris;
    },
    /** Apply deletion on vertices and triangles */
    applyDeletion: function () {
      var iTrisToDelete = this._iTrisToDelete;
      Utils.tidy(iTrisToDelete);
      var nbTrisDelete = iTrisToDelete.length;
      var i = 0;
      for (i = nbTrisDelete - 1; i >= 0; --i)
        this.deleteTriangle(iTrisToDelete[i]);

      var iVertsToDelete = this._iVertsToDelete;
      Utils.tidy(iVertsToDelete);
      var nbVertsToDelete = iVertsToDelete.length;
      for (i = nbVertsToDelete - 1; i >= 0; --i)
        this.deleteVertex(iVertsToDelete[i]);
    },
    /** Return the valid modified vertices (no duplicates) */
    getValidModifiedVertices: function () {
      var mesh = this._mesh;
      var vtf = mesh.getVerticesTagFlags();
      var nbVertices = mesh.getNbVertices();

      var tagFlag = ++Utils.TAG_FLAG;
      var iVertsDecimated = this._iVertsDecimated;
      var nbVertsDecimated = iVertsDecimated.length;
      var validVertices = new Uint32Array(Utils.getMemory(nbVertsDecimated * 4), 0, nbVertsDecimated);
      var nbValid = 0;
      for (var i = 0; i < nbVertsDecimated; ++i) {
        var iVert = iVertsDecimated[i];
        if (iVert >= nbVertices)
          continue;
        if (vtf[iVert] === tagFlag)
          continue;
        vtf[iVert] = tagFlag;
        validVertices[nbValid++] = iVert;
      }
      return new Uint32Array(validVertices.subarray(0, nbValid));
    },
    /** Return the valid modified triangles (no duplicates) */
    getValidModifiedTriangles: function (iVerts, iTris) {
      var mesh = this._mesh;
      var ftf = mesh.getFacesTagFlags();
      var nbTriangles = mesh.getNbTriangles();

      var newTris = mesh.getFacesFromVertices(iVerts);
      var temp = iTris;
      var nbTris = iTris.length;
      iTris = new Uint32Array(nbTris + newTris.length);
      iTris.set(temp);
      iTris.set(newTris, nbTris);

      var tagFlag = ++Utils.TAG_FLAG;
      nbTris = iTris.length;
      var validTriangles = new Uint32Array(Utils.getMemory(nbTris * 4), 0, nbTris);
      var nbValid = 0;
      for (var i = 0; i < nbTris; ++i) {
        var iTri = iTris[i];
        if (iTri >= nbTriangles)
          continue;
        if (ftf[iTri] === tagFlag)
          continue;
        ftf[iTri] = tagFlag;
        validTriangles[nbValid++] = iTri;
      }
      return new Uint32Array(validTriangles.subarray(0, nbValid));
    },
    /** Find opposite triangle */
    findOppositeTriangle: function (iTri, iv1, iv2) {
      var vrf = this._mesh.getVerticesRingFace();
      var iTris1 = vrf[iv1];
      var iTris2 = vrf[iv2];
      iTris1.sort(sortFunc);
      iTris2.sort(sortFunc);
      var res = Utils.intersectionArrays(iTris1, iTris2);
      if (res.length !== 2)
        return -1;
      return res[0] === iTri ? res[1] : res[0];
    },
    /** Decimate triangles (find orientation of the 2 triangles) */
    decimateTriangles: function (iTri1, iTri2, iTris) {
      if (iTri2 === -1)
        return;
      var fAr = this._mesh.getFaces();

      var id = iTri1 * 4;
      var iv11 = fAr[id];
      var iv21 = fAr[id + 1];
      var iv31 = fAr[id + 2];

      id = iTri2 * 4;
      var iv12 = fAr[id];
      var iv22 = fAr[id + 1];
      var iv32 = fAr[id + 2];

      if (iv11 === iv12) {
        if (iv21 === iv32) this.edgeCollapse(iTri1, iTri2, iv11, iv21, iv31, iv22, iTris);
        else this.edgeCollapse(iTri1, iTri2, iv11, iv31, iv21, iv32, iTris);
      } else if (iv11 === iv22) {
        if (iv21 === iv12) this.edgeCollapse(iTri1, iTri2, iv11, iv21, iv31, iv32, iTris);
        else this.edgeCollapse(iTri1, iTri2, iv11, iv31, iv21, iv12, iTris);
      } else if (iv11 === iv32) {
        if (iv21 === iv22) this.edgeCollapse(iTri1, iTri2, iv11, iv21, iv31, iv12, iTris);
        else this.edgeCollapse(iTri1, iTri2, iv11, iv31, iv21, iv22, iTris);
      } else if (iv21 === iv12) this.edgeCollapse(iTri1, iTri2, iv31, iv21, iv11, iv22, iTris);
      else if (iv21 === iv22) this.edgeCollapse(iTri1, iTri2, iv31, iv21, iv11, iv32, iTris);
      else this.edgeCollapse(iTri1, iTri2, iv31, iv21, iv11, iv12, iTris);
    },
    /** Decimate 2 triangles (collapse 1 edge) */
    edgeCollapse: function (iTri1, iTri2, iv1, iv2, ivOpp1, ivOpp2, iTris) {
      var mesh = this._mesh;
      var vAr = mesh.getVertices();
      var nAr = mesh.getNormals();
      var cAr = mesh.getColors();
      var mAr = mesh.getMaterials();
      var fAr = mesh.getFaces();

      var vtf = mesh.getVerticesTagFlags();
      var ftf = mesh.getFacesTagFlags();
      var vrv = mesh.getVerticesRingVert();
      var vrf = mesh.getVerticesRingFace();

      var ring1 = vrv[iv1];
      var ring2 = vrv[iv2];
      var tris1 = vrf[iv1];
      var tris2 = vrf[iv2];

      // vertices on the edge... we don't do anything
      if (ring1.length !== tris1.length || ring2.length !== tris2.length)
        return;

      var ringOpp1 = vrv[ivOpp1];
      var ringOpp2 = vrv[ivOpp2];
      var trisOpp1 = vrf[ivOpp1];
      var trisOpp2 = vrf[ivOpp2];
      if (ringOpp1.length !== trisOpp1.length || ringOpp2.length !== trisOpp2.length)
        return;

      this._iVertsDecimated.push(iv1, iv2);

      // undo-redo
      this._states.pushVertices(ring1);
      this._states.pushVertices(ring2);
      this._states.pushFaces(tris1);
      this._states.pushFaces(tris2);

      ring1.sort(sortFunc);
      ring2.sort(sortFunc);

      var id = 0;
      if (Utils.intersectionArrays(ring1, ring2).length >= 3) { // edge flip
        Utils.removeElement(tris1, iTri2);
        Utils.removeElement(tris2, iTri1);
        trisOpp1.push(iTri2);
        trisOpp2.push(iTri1);

        id = iTri1 * 4;
        if (fAr[id] === iv2) fAr[id] = ivOpp2;
        else if (fAr[id + 1] === iv2) fAr[id + 1] = ivOpp2;
        else fAr[id + 2] = ivOpp2;

        id = iTri2 * 4;
        if (fAr[id] === iv1) fAr[id] = ivOpp1;
        else if (fAr[id + 1] === iv1) fAr[id + 1] = ivOpp1;
        else fAr[id + 2] = ivOpp1;

        mesh.computeRingVertices(iv1);
        mesh.computeRingVertices(iv2);
        mesh.computeRingVertices(ivOpp1);
        mesh.computeRingVertices(ivOpp2);
        // this.cleanUpSingularVertex(iv1);
        // this.cleanUpSingularVertex(iv2);
        // this.cleanUpSingularVertex(ivOpp1);
        // this.cleanUpSingularVertex(ivOpp2);
        return;
      }

      id = iv1 * 3;
      var id2 = iv2 * 3;
      var nx = nAr[id] + nAr[id2];
      var ny = nAr[id + 1] + nAr[id2 + 1];
      var nz = nAr[id + 2] + nAr[id2 + 2];
      var len = nx * nx + ny * ny + nz * nz;
      if (len === 0) {
        nx = 1.0;
      } else {
        len = 1.0 / Math.sqrt(len);
        nx *= len;
        ny *= len;
        nz *= len;
      }
      nAr[id] = nx;
      nAr[id + 1] = ny;
      nAr[id + 2] = nz;
      cAr[id] = (cAr[id] + cAr[id2]) * 0.5;
      cAr[id + 1] = (cAr[id + 1] + cAr[id2 + 1]) * 0.5;
      cAr[id + 2] = (cAr[id + 2] + cAr[id2 + 2]) * 0.5;
      mAr[id] = (mAr[id] + mAr[id2]) * 0.5;
      mAr[id + 1] = (mAr[id + 1] + mAr[id2 + 1]) * 0.5;
      mAr[id + 2] = (mAr[id + 2] + mAr[id2 + 2]) * 0.5;

      Utils.removeElement(tris1, iTri1);
      Utils.removeElement(tris1, iTri2);
      Utils.removeElement(tris2, iTri1);
      Utils.removeElement(tris2, iTri2);
      Utils.removeElement(trisOpp1, iTri1);
      Utils.removeElement(trisOpp2, iTri2);

      var nb = tris2.length;
      var i = 0;
      for (i = 0; i < nb; ++i) {
        var tri2 = tris2[i];
        tris1.push(tri2);
        var iTri = tri2 * 4;
        if (fAr[iTri] === iv2) fAr[iTri] = iv1;
        else if (fAr[iTri + 1] === iv2) fAr[iTri + 1] = iv1;
        else fAr[iTri + 2] = iv1;
      }
      nb = ring2.length;
      for (i = 0; i < nb; ++i)
        ring1.push(ring2[i]);

      mesh.computeRingVertices(iv1);

      // flat smooth the vertex...
      var meanX = 0.0;
      var meanY = 0.0;
      var meanZ = 0.0;
      var nbRing1 = ring1.length;
      for (i = 0; i < nbRing1; ++i) {
        var ivRing = ring1[i];
        mesh.computeRingVertices(ivRing);
        ivRing *= 3;
        meanX += vAr[ivRing];
        meanY += vAr[ivRing + 1];
        meanZ += vAr[ivRing + 2];
      }
      meanX /= nbRing1;
      meanY /= nbRing1;
      meanZ /= nbRing1;
      var dot = nx * (meanX - vAr[id]) + ny * (meanY - vAr[id + 1]) + nz * (meanZ - vAr[id + 2]);
      vAr[id] = meanX - nx * dot;
      vAr[id + 1] = meanY - ny * dot;
      vAr[id + 2] = meanZ - nz * dot;

      vtf[iv2] = ftf[iTri1] = ftf[iTri2] = -1;
      this._iVertsToDelete.push(iv2);
      this._iTrisToDelete.push(iTri1, iTri2);

      nb = tris1.length;
      for (i = 0; i < nb; ++i)
        iTris.push(tris1[i]);

      // this.cleanUpSingularVertex(iv1);
    },
    /** Update last triangle of array and move its position */
    deleteTriangle: function (iTri) {
      var mesh = this._mesh;
      var vrf = mesh.getVerticesRingFace();
      var ftf = mesh.getFacesTagFlags();
      var fAr = mesh.getFaces();
      var pil = mesh.getFacePosInLeaf();
      var fleaf = mesh.getFaceLeaf();
      var fstf = mesh.getFacesStateFlags();

      var oldPos = pil[iTri];
      var iTrisLeaf = fleaf[iTri]._iFaces;
      var lastTri = iTrisLeaf[iTrisLeaf.length - 1];
      if (iTri !== lastTri) {
        iTrisLeaf[oldPos] = lastTri;
        pil[lastTri] = oldPos;
      }
      iTrisLeaf.pop();

      var lastPos = mesh.getNbTriangles() - 1;
      if (lastPos === iTri) {
        mesh.addNbFace(-1);
        return;
      }
      var id = lastPos * 4;
      var iv1 = fAr[id];
      var iv2 = fAr[id + 1];
      var iv3 = fAr[id + 2];

      // undo-redo
      this._states.pushVertices([iv1, iv2, iv3]);
      this._states.pushFaces([lastPos]);

      Utils.replaceElement(vrf[iv1], lastPos, iTri);
      Utils.replaceElement(vrf[iv2], lastPos, iTri);
      Utils.replaceElement(vrf[iv3], lastPos, iTri);

      var leafLast = fleaf[lastPos];
      var pilLast = pil[lastPos];
      leafLast._iFaces[pilLast] = iTri;
      fleaf[iTri] = leafLast;
      pil[iTri] = pilLast;

      ftf[iTri] = ftf[lastPos];
      fstf[iTri] = fstf[lastPos];
      iTri *= 4;
      fAr[iTri] = iv1;
      fAr[iTri + 1] = iv2;
      fAr[iTri + 2] = iv3;
      fAr[iTri + 3] = -1;

      this._iVertsDecimated.push(iv1, iv2, iv3);

      mesh.addNbFace(-1);
    },
    /** Update last vertex of array and move its position */
    deleteVertex: function (iVert) {
      var mesh = this._mesh;
      var vrv = mesh.getVerticesRingVert();
      var vrf = mesh.getVerticesRingFace();
      var vAr = mesh.getVertices();
      var nAr = mesh.getNormals();
      var cAr = mesh.getColors();
      var mAr = mesh.getMaterials();
      var fAr = mesh.getFaces();
      var vtf = mesh.getVerticesTagFlags();
      var vstf = mesh.getVerticesStateFlags();
      var vsctf = mesh.getVerticesSculptFlags();

      var lastPos = mesh.getNbVertices() - 1;
      if (iVert === lastPos) {
        mesh.addNbVertice(-1);
        return;
      }
      var id = 0;

      // undo-redo
      var states = this._states;
      states.pushVertices([lastPos]);

      var iTris = vrf[lastPos];
      var ring = vrv[lastPos];
      var nbTris = iTris.length;
      var nbRing = ring.length;
      var i = 0;
      for (i = 0; i < nbTris; ++i) {
        id = iTris[i];
        states.pushFaces([id]); // undo-redo

        id *= 4;
        if (fAr[id] === lastPos) fAr[id] = iVert;
        else if (fAr[id + 1] === lastPos) fAr[id + 1] = iVert;
        else fAr[id + 2] = iVert;
      }

      for (i = 0; i < nbRing; ++i) {
        id = ring[i];
        states.pushVertices([id]); // undo-redo
        Utils.replaceElement(vrv[id], lastPos, iVert);
      }

      vrv[iVert] = vrv[lastPos].slice(); // slice ?
      vrf[iVert] = vrf[lastPos].slice(); // slice ?
      vtf[iVert] = vtf[lastPos];
      vstf[iVert] = vstf[lastPos];
      vsctf[iVert] = vsctf[lastPos];
      var idLast = lastPos * 3;
      id = iVert * 3;
      vAr[id] = vAr[idLast];
      vAr[id + 1] = vAr[idLast + 1];
      vAr[id + 2] = vAr[idLast + 2];
      nAr[id] = nAr[idLast];
      nAr[id + 1] = nAr[idLast + 1];
      nAr[id + 2] = nAr[idLast + 2];
      cAr[id] = cAr[idLast];
      cAr[id + 1] = cAr[idLast + 1];
      cAr[id + 2] = cAr[idLast + 2];
      mAr[id] = mAr[idLast];
      mAr[id + 1] = mAr[idLast + 1];
      mAr[id + 2] = mAr[idLast + 2];

      mesh.addNbVertice(-1);
    }
  };

  module.exports = Decimation;
});
define('mesh/dynamic/Topology',['require','exports','module','mesh/dynamic/Subdivision','mesh/dynamic/Decimation'],function (require, exports, module) {

  'use strict';

  var Subdivision = require('mesh/dynamic/Subdivision');
  var Decimation = require('mesh/dynamic/Decimation');

  var Topology = function (mesh) {
    this._mesh = mesh;
    this._subdivision = new Subdivision(mesh);
    this._decimation = new Decimation(mesh);
  };

  Topology.subFactor = 75; // subdivision factor
  Topology.decFactor = 0; // decimation factor
  Topology.linear = false; // linear subdivision

  Topology.prototype = {
    getSubdivisionFactor: function () {
      return Topology.subFactor * 0.01;
    },
    getDecimationFactor: function () {
      return Topology.decFactor * 0.01;
    },
    subdivision: function (iTris, center, radius2, detail2, states) {
      this._subdivision._linear = Topology.linear;
      return this._subdivision.subdivision(iTris, center, radius2, detail2, states);
    },
    decimation: function (iTris, center, radius2, detail2, states) {
      return this._decimation.decimation(iTris, center, radius2, detail2, states);
    }
  };

  module.exports = Topology;
});
define('mesh/dynamic/MeshDynamic',['require','exports','module','misc/Utils','mesh/dynamic/Topology','mesh/Mesh'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var Topology = require('mesh/dynamic/Topology');
  var Mesh = require('mesh/Mesh');

  // Dynamic topology mesh (triangles only)
  // Obviously less performant than the static topology mesh
  // It "inherits" Mesh but in practice it almost overrides everything related to topology
  //
  // The edges are not computed though (kind of bothersome to update...)
  //
  // The wireframe is directly computed from the triangles (it's as stupid as 1 tri => 3 lines)
  // Basically... "quick and dirty" (the edges will be drawn twice)

  var MeshDynamic = function (mesh) {
    Mesh.call(this, mesh.getGL());
    this.setTransformData(mesh.getTransformData());
    this.setID(mesh.getID());
    this._dynamicTopology = new Topology(this);

    // vertices rings
    var vdata = this.getVertexData();
    this._vrings = vdata._vertRingVert = []; // vertex ring
    this._frings = vdata._vertRingFace = []; // face ring
    this._nbFaces = 0;
    this._nbVertices = 0;

    this._facesStateFlags = null; // state flags (<= Utils.STATE_FLAG) (Int32Array)
    this._wireframe = null; // Uint32Array
    this.init(mesh);
    this.setRender(mesh.getRender());
    if (mesh.isUsingTexCoords())
      this.setShaderName('MATCAP');
    mesh.getRender()._mesh = this;
    this.initRender();
  };

  MeshDynamic.prototype = {
    getDynamicTopology: function () {
      return this._dynamicTopology;
    },
    getVerticesProxy: function () {
      return this.getVertices(); // for now no proxy sculpting for dynamic meshes
    },
    getNbVertices: function () {
      return this._nbVertices;
    },
    setNbVertices: function (nbVertices) {
      this._nbVertices = nbVertices;
    },
    addNbVertice: function (nb) {
      this._nbVertices += nb;
    },
    getNbFaces: function () {
      return this._nbFaces;
    },
    getNbTriangles: function () {
      return this._nbFaces;
    },
    setNbFaces: function (nbFaces) {
      this._nbFaces = nbFaces;
    },
    addNbFace: function (nb) {
      this._nbFaces += nb;
    },
    getNbEdges: function () {
      return this.getNbTriangles() * 3;
    },
    getFacesStateFlags: function () {
      return this._facesStateFlags;
    },
    getRenderVertices: function () {
      if (this.isUsingDrawArrays()) return this.getVerticesDrawArrays();
      return this.getVertices().subarray(0, this.getNbVertices() * 3);
    },
    getRenderNormals: function () {
      if (this.isUsingDrawArrays()) return this.getNormalsDrawArrays();
      return this.getNormals().subarray(0, this.getNbVertices() * 3);
    },
    getRenderColors: function () {
      if (this.isUsingDrawArrays()) return this.getColorsDrawArrays();
      return this.getColors().subarray(0, this.getNbVertices() * 3);
    },
    getRenderMaterials: function () {
      if (this.isUsingDrawArrays()) return this.getMaterialsDrawArrays();
      return this.getMaterials().subarray(0, this.getNbVertices() * 3);
    },
    getRenderTriangles: function () {
      return this.getTriangles().subarray(0, this.getNbTriangles() * 3);
    },
    init: function (mesh) {
      this.setVertices(mesh.getVertices().slice());
      this.setColors(mesh.getColors().slice());
      this.setMaterials(mesh.getMaterials().slice());
      this.setFaces(new Int32Array(mesh.getNbTriangles() * 4));
      this.setNbFaces(mesh.getNbTriangles());
      this.setNbVertices(mesh.getNbVertices());

      this.allocateArrays();

      this.initTriangles(mesh);
      this.initRenderTriangles();
      this.initVerticesTopology();

      this.updateFacesAabbAndNormal();
      this.updateVerticesNormal();
      this.updateOctree();
    },
    updateTopology: function (iFaces) {
      this.updateRenderTriangles(iFaces);
      if (this.getShowWireframe())
        this.updateWireframe(iFaces);
      if (this.isUsingDrawArrays())
        this.updateDrawArrays(iFaces);
    },
    getWireframe: function () {
      if (!this._wireframe) {
        this._wireframe = new Uint32Array(this.getTriangles().length * 2);
        this.updateWireframe();
      }
      return this._wireframe.subarray(0, this.getNbEdges() * 2);
    },
    setShowWireframe: function (showWireframe) {
      this._wireframe = null;
      this.getRender().setShowWireframe(showWireframe);
    },
    updateWireframe: function (iFaces) {
      var wire = this._wireframe;
      var tris = this.getTriangles();
      var full = iFaces === undefined;
      var useDA = this.isUsingDrawArrays();
      var nbTriangles = full ? this.getNbTriangles() : iFaces.length;
      for (var i = 0; i < nbTriangles; ++i) {
        var ind = full ? i : iFaces[i];
        var idw = ind * 6;
        var idt = ind * 3;
        if (useDA) {
          wire[idw] = wire[idw + 5] = idt;
          wire[idw + 1] = wire[idw + 2] = idt + 2;
          wire[idw + 3] = wire[idw + 4] = idt + 1;
        } else {
          wire[idw] = wire[idw + 5] = tris[idt];
          wire[idw + 1] = wire[idw + 2] = tris[idt + 1];
          wire[idw + 3] = wire[idw + 4] = tris[idt + 2];
        }
      }
    },
    updateRenderTriangles: function (iFaces) {
      var tAr = this.getTriangles();
      var fAr = this.getFaces();
      var full = iFaces === undefined;
      var nbFaces = full ? this.getNbFaces() : iFaces.length;
      for (var i = 0; i < nbFaces; ++i) {
        var id = full ? i : iFaces[i];
        var idt = id * 3;
        var idf = id * 4;
        tAr[idt] = fAr[idf];
        tAr[idt + 1] = fAr[idf + 1];
        tAr[idt + 2] = fAr[idf + 2];
      }
    },
    resizeArray: function (orig, targetSize) {
      if (!orig) return null;
      // multiply by 2 the size
      if (orig.length >= targetSize) return orig.subarray(0, targetSize * 2);
      var tmp = new orig.constructor(targetSize * 2);
      tmp.set(orig);
      return tmp;
    },
    /** Reallocate mesh resources */
    reAllocateArrays: function (nbAddElements) {
      this.reAllocate(nbAddElements);
      if (this.isUsingDrawArrays())
        this.getDrawArraysData().reAllocateArrays(nbAddElements);
      this.getFaceData().reAllocateArrays(nbAddElements);
      this.getVertexData().reAllocateArrays(nbAddElements);
      this.getOctree().reAllocateArrays(nbAddElements);
    },
    reAllocate: function (nbAddElements) {
      var nbDyna = this._facesStateFlags.length;
      var nbTriangles = this.getNbTriangles();
      var len = nbTriangles + nbAddElements;
      if (nbDyna < len || nbDyna > len * 4) {
        this._facesStateFlags = this.resizeArray(this._facesStateFlags, len);
        if (this.getShowWireframe())
          this._wireframe = this.resizeArray(this._wireframe, len * 6);
      }
    },
    initTriangles: function (mesh) {
      var iArMesh = mesh.getTriangles();
      var nbTriangles = this.getNbTriangles();
      var fAr = this.getFaces();
      this._facesStateFlags = new Int32Array(nbTriangles);
      for (var i = 0; i < nbTriangles; ++i) {
        var id3 = i * 3;
        var id4 = i * 4;
        fAr[id4] = iArMesh[id3];
        fAr[id4 + 1] = iArMesh[id3 + 1];
        fAr[id4 + 2] = iArMesh[id3 + 2];
        fAr[id4 + 3] = -1;
      }
    },
    initVerticesTopology: function () {
      var vrings = this._vrings;
      var frings = this._frings;
      var i = 0;
      var nbVertices = this.getNbVertices();
      vrings.length = frings.length = nbVertices;
      for (i = 0; i < nbVertices; ++i) {
        vrings[i] = [];
        frings[i] = [];
      }

      var nbTriangles = this.getNbTriangles();
      var iAr = this.getTriangles();
      for (i = 0; i < nbTriangles; ++i) {
        var j = i * 3;
        frings[iAr[j]].push(i);
        frings[iAr[j + 1]].push(i);
        frings[iAr[j + 2]].push(i);
      }

      for (i = 0; i < nbVertices; ++i)
        this.computeRingVertices(i);
    },
    /** Compute the vertices around a vertex */
    computeRingVertices: function (iVert) {
      var tagFlag = ++Utils.TAG_FLAG;
      var fAr = this.getFaces();
      var vflags = this.getVerticesTagFlags();

      var vring = this._vrings[iVert];
      var fring = this._frings[iVert];
      vring.length = 0;
      var nbTris = fring.length;

      for (var i = 0; i < nbTris; ++i) {
        var ind = fring[i] * 4;
        var iVer1 = fAr[ind];
        var iVer2 = fAr[ind + 1];
        var iVer3 = fAr[ind + 2];
        if (iVer1 !== iVert && vflags[iVer1] !== tagFlag) {
          vring.push(iVer1);
          vflags[iVer1] = tagFlag;
        }
        if (iVer2 !== iVert && vflags[iVer2] !== tagFlag) {
          vring.push(iVer2);
          vflags[iVer2] = tagFlag;
        }
        if (iVer3 !== iVert && vflags[iVer3] !== tagFlag) {
          vring.push(iVer3);
          vflags[iVer3] = tagFlag;
        }
      }
    }
  };

  Utils.makeProxy(Mesh, MeshDynamic);

  module.exports = MeshDynamic;
});
define('states/StateMultiresolution',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var StateMultiresolution = function (main, multimesh, type, isRedo) {
    this._main = main; // main application
    this._multimesh = multimesh; // the multires mesh
    this._mesh = multimesh.getCurrentMesh(); // the sub multimesh
    this._type = type; // the type of action
    this._sel = multimesh._sel; // the selected mesh

    switch (type) {
    case StateMultiresolution.DELETE_LOWER:
      this._deletedMeshes = multimesh._meshes.slice(0, multimesh._sel); // deleted meshes
      break;
    case StateMultiresolution.DELETE_HIGHER:
      this._deletedMeshes = multimesh._meshes.slice(multimesh._sel + 1); // deleted meshes
      if (!isRedo)
        this._vMappingState = this._mesh.getVerticesMapping(); // vertex mapping low to high res
      break;
    case StateMultiresolution.SUBDIVISION:
    case StateMultiresolution.REVERSION:
      if (!isRedo) {
        this._vArState = this._mesh.getVertices().slice(); // copies of vertices coordinates
        this._cArState = this._mesh.getColors().slice(); // copies of colors
        this._mArState = this._mesh.getMaterials().slice(); // copies of materials
      }
      break;
    }
  };

  StateMultiresolution.SUBDIVISION = 0; // subdivision of the mesh
  StateMultiresolution.REVERSION = 1; // reversion of the mesh
  StateMultiresolution.SELECTION = 2; // change selection of resolution
  StateMultiresolution.DELETE_LOWER = 3; // deletes lower resolution
  StateMultiresolution.DELETE_HIGHER = 4; // deletes higher resolution

  StateMultiresolution.prototype = {
    isNoop: function () {
      return false;
    },
    undo: function () {
      var mul = this._multimesh;
      switch (this._type) {
      case StateMultiresolution.SELECTION:
        mul.selectMesh(this._mesh);
        break;
      case StateMultiresolution.DELETE_LOWER:
        Array.prototype.unshift.apply(mul._meshes, this._deletedMeshes);
        mul._sel = this._deletedMeshes.length;
        break;
      case StateMultiresolution.DELETE_HIGHER:
        Array.prototype.push.apply(mul._meshes, this._deletedMeshes);
        this._mesh.setVerticesMapping(this._vMappingState);
        break;
      case StateMultiresolution.SUBDIVISION:
        this._mesh.setVertices(this._vArState.slice());
        this._mesh.setColors(this._cArState.slice());
        this._mesh.setMaterials(this._mArState.slice());
        mul.popMesh();
        break;
      case StateMultiresolution.REVERSION:
        this._mesh.setVertices(this._vArState.slice());
        this._mesh.setColors(this._cArState.slice());
        this._mesh.setMaterials(this._mArState.slice());
        mul.shiftMesh();
        break;
      }
      this._main.setMesh(mul);
    },
    redo: function () {
      var mul = this._multimesh;
      switch (this._type) {
      case StateMultiresolution.SELECTION:
        mul.selectMesh(this._mesh);
        break;
      case StateMultiresolution.DELETE_LOWER:
        mul.deleteLower();
        break;
      case StateMultiresolution.DELETE_HIGHER:
        mul.deleteHigher();
        break;
      case StateMultiresolution.SUBDIVISION:
        mul.pushMesh(this._mesh);
        break;
      case StateMultiresolution.REVERSION:
        mul.unshiftMesh(this._mesh);
        break;
      }
      this._main.setMesh(mul);
    },
    createRedo: function () {
      return new StateMultiresolution(this._main, this._multimesh, this._type, true);
    }
  };

  module.exports = StateMultiresolution;
});
define('gui/GuiTopology',['require','exports','module','gui/GuiTR','editing/Remesh','mesh/Mesh','mesh/multiresolution/Multimesh','mesh/dynamic/MeshDynamic','mesh/dynamic/Topology','states/StateMultiresolution'],function (require, exports, module) {

  'use strict';

  var TR = require('gui/GuiTR');
  var Remesh = require('editing/Remesh');
  var Mesh = require('mesh/Mesh');
  var Multimesh = require('mesh/multiresolution/Multimesh');
  var MeshDynamic = require('mesh/dynamic/MeshDynamic');
  var Topology = require('mesh/dynamic/Topology');
  var StateMultiresolution = require('states/StateMultiresolution');

  var GuiMultiresolution = function (guiParent, ctrlGui) {
    this._ctrlGui = ctrlGui;
    this._main = ctrlGui._main; // main application
    this._menu = null; // ui menu
    this._ctrlResolution = null; // multiresolution controller
    this._ctrlDynamic = null; // dynamic topology controller
    this.init(guiParent);
  };

  GuiMultiresolution.prototype = {
    /** Initialize */
    init: function (guiParent) {
      var menu = this._menu = guiParent.addMenu(TR('topologyTitle'));
      menu.close();

      // multires
      menu.addTitle(TR('multiresTitle'));
      this._ctrlResolution = menu.addSlider(TR('multiresResolution'), 1, this.onResolutionChanged.bind(this), 1, 1, 1);
      var dual = menu.addDualButton(TR('multiresReverse'), TR('multiresSubdivide'), this, this, 'reverse', 'subdivide');
      this._ctrlReverse = dual[0];
      this._ctrlSubdivide = dual[1];
      dual = this._dualButtonDel = menu.addDualButton(TR('multiresDelLower'), TR('multiresDelHigher'), this, this, 'deleteLower', 'deleteHigher');
      this._ctrlDelLower = dual[0];
      this._ctrlDelHigher = dual[1];
      this._ctrlDelLower.domButton.style.background = this._ctrlDelHigher.domButton.style.background = 'rgba(230,53,59,0.35)';

      // remeshing
      menu.addTitle(TR('remeshTitle'));
      menu.addSlider(TR('remeshResolution'), Remesh, 'RESOLUTION', 8, 400, 1);
      menu.addCheckbox(TR('remeshBlock'), Remesh, 'BLOCK');
      menu.addButton(TR('remeshRemesh'), this, 'remesh');

      // dynamic
      menu.addTitle(TR('dynamicTitle'));
      this._ctrlDynamic = menu.addCheckbox(TR('dynamicActivated'), false, this.dynamicToggleActivate.bind(this));
      this._ctrlDynSubd = menu.addSlider(TR('dynamicSubdivision'), Topology, 'subFactor', 0, 100, 1);
      this._ctrlDynDec = menu.addSlider(TR('dynamicDecimation'), Topology, 'decFactor', 0, 100, 1);
      this._ctrlDynLin = menu.addCheckbox(TR('dynamicLinear'), Topology, 'linear');
      this.updateDynamicVisibility(false);
    },
    updateDynamicVisibility: function (bool) {
      this._ctrlDynSubd.setVisibility(bool);
      this._ctrlDynDec.setVisibility(bool);
      this._ctrlDynLin.setVisibility(bool);
    },
    dynamicToggleActivate: function () {
      var main = this._main;
      var mesh = main.getMesh();
      if (!mesh)
        return;

      var newMesh = !mesh.getDynamicTopology ? new MeshDynamic(mesh) : this.convertToStaticMesh(mesh);
      this.updateDynamicVisibility(!mesh.getDynamicTopology);

      main.replaceMesh(mesh, newMesh);
      main.getStates().pushStateAddRemove(newMesh, mesh);
    },
    remesh: function () {
      var main = this._main;
      var mesh = main.getMesh();
      if (!mesh)
        return;

      var meshes = main.getMeshes();
      var selMeshes = main.getSelectedMeshes().slice();
      for (var i = 0, l = selMeshes.length; i < l; ++i) {
        var sel = selMeshes[i];
        meshes.splice(main.getIndexMesh(sel), 1);
        selMeshes[i] = this.convertToStaticMesh(sel);
        if (sel === mesh)
          mesh = selMeshes[i];
      }
      var newMesh = Remesh.remesh(selMeshes, mesh);
      main.getStates().pushStateAddRemove(newMesh, main.getSelectedMeshes().slice());
      main.getMeshes().push(newMesh);
      main.setMesh(newMesh);
    },
    /** Check if the mesh is a multiresolution one */
    isMultimesh: function (mesh) {
      return !!(mesh && mesh._meshes);
    },
    convertToStaticMesh: function (mesh) {
      if (!mesh.getDynamicTopology) // already static
        return mesh;
      // dynamic to static mesh
      var newMesh = new Mesh(mesh.getGL());
      newMesh.setID(mesh.getID());
      newMesh.setTransformData(mesh.getTransformData());
      newMesh.setVertices(mesh.getVertices().subarray(0, mesh.getNbVertices() * 3));
      newMesh.setColors(mesh.getColors().subarray(0, mesh.getNbVertices() * 3));
      newMesh.setMaterials(mesh.getMaterials().subarray(0, mesh.getNbVertices() * 3));
      newMesh.setFaces(mesh.getFaces().subarray(0, mesh.getNbFaces() * 4));
      newMesh.init();
      newMesh.setRender(mesh.getRender());
      mesh.getRender()._mesh = newMesh;
      newMesh.initRender();
      return newMesh;
    },
    /** Convert a mesh into a multiresolution one */
    convertToMultimesh: function (mesh) {
      if (this.isMultimesh(mesh))
        return mesh;
      var multimesh = new Multimesh(this.convertToStaticMesh(mesh));
      return multimesh;
    },
    /** Subdivide the mesh */
    subdivide: function () {
      var main = this._main;
      var mesh = main.getMesh();
      if (!mesh)
        return;
      var mul = this.convertToMultimesh(mesh);
      if (mul._sel !== mul._meshes.length - 1) {
        window.alert(TR('multiresSelectHighest'));
        return;
      }
      if (mul.getNbTriangles() > 400000) {
        if (!window.confirm(TR('multiresWarnBigMesh', mul.getNbFaces() * 4))) {
          if (mesh !== mul)
            mesh.getRender()._mesh = mesh;
          return;
        }
      }

      if (mesh !== mul) {
        main.replaceMesh(mesh, mul);
        main.getStates().pushStateAddRemove(mul, mesh, true);
      }
      main.getStates().pushState(new StateMultiresolution(main, mul, StateMultiresolution.SUBDIVISION));
      mul.addLevel();
      main.setMesh(mul);
      main.render();
    },
    /** Inverse subdivision */
    reverse: function () {
      var main = this._main;
      var mesh = main.getMesh();
      if (!mesh)
        return;
      var mul = this.convertToMultimesh(mesh);
      if (mul._sel !== 0) {
        window.alert(TR('multiresSelectLowest'));
        return;
      }
      var stateRes = new StateMultiresolution(main, mul, StateMultiresolution.REVERSION);
      var newMesh = mul.computeReverse();
      if (!newMesh) {
        if (mesh !== mul)
          mesh.getRender()._mesh = mesh;
        window.alert(TR('multiresNotReversible'));
        return;
      }

      if (mesh !== mul) {
        main.replaceMesh(mesh, mul);
        main.getStates().pushStateAddRemove(mul, mesh, true);
      }
      main.getStates().pushState(stateRes);
      main.setMesh(mul);
      main.render();
    },
    /** Delete the lower meshes */
    deleteLower: function () {
      var main = this._main;
      var mul = main._mesh;
      if (!this.isMultimesh(mul) || mul._sel === 0) {
        window.alert(TR('multiresNoLower'));
        return;
      }

      main.getStates().pushState(new StateMultiresolution(main, mul, StateMultiresolution.DELETE_LOWER));
      mul.deleteLower();
      this.updateMeshResolution();
    },
    /** Delete the higher meshes */
    deleteHigher: function () {
      var main = this._main;
      var mul = main.getMesh();
      if (!this.isMultimesh(mul) || mul._sel === mul._meshes.length - 1) {
        window.alert(TR('multiresNoHigher'));
        return;
      }

      main.getStates().pushState(new StateMultiresolution(main, mul, StateMultiresolution.DELETE_HIGHER));
      mul.deleteHigher();
      this.updateMeshResolution();
    },
    /** Change resoltuion */
    onResolutionChanged: function (value) {
      var uiRes = value - 1;
      var main = this._main;
      var multimesh = main.getMesh();
      if (!multimesh) return;
      var isMulti = this.isMultimesh(multimesh);
      var isLast = isMulti && multimesh._meshes.length - 1 === uiRes;

      this._ctrlReverse.setEnable(!isMulti || uiRes === 0);
      this._ctrlSubdivide.setEnable(!isMulti || isLast);
      this._ctrlDelLower.setEnable(isMulti && uiRes !== 0);
      this._ctrlDelHigher.setEnable(isMulti && !isLast);

      if (!isMulti || multimesh._sel === uiRes)
        return;

      main.getStates().pushState(new StateMultiresolution(main, multimesh, StateMultiresolution.SELECTION));
      multimesh.selectResolution(uiRes);
      this._ctrlGui.updateMeshInfo();
      main.render();
    },
    /** Update the mesh resolution slider */
    updateMeshResolution: function () {
      var multimesh = this._main.getMesh();
      if (!multimesh || !this.isMultimesh(multimesh)) {
        this._ctrlResolution.setMax(1);
        this._ctrlResolution.setValue(0);
        return;
      }
      this._ctrlResolution.setMax(multimesh._meshes.length);
      this._ctrlResolution.setValue(multimesh._sel + 1);
    },
    /** Update topology information */
    updateMesh: function () {
      if (!this._main.getMesh()) {
        this._menu.setVisibility(false);
        return;
      }
      this._menu.setVisibility(true);
      this.updateMeshResolution();
      var bool = this._main.getMesh().getDynamicTopology;
      this.updateDynamicVisibility(bool);
      this._ctrlDynamic.setValue(bool, true);
    }
  };

  module.exports = GuiMultiresolution;
});
define('gui/GuiRendering',['require','exports','module','gui/GuiTR','mesh/Render','render/ShaderLib'],function (require, exports, module) {

  'use strict';

  var TR = require('gui/GuiTR');
  var Render = require('mesh/Render');
  var Shader = require('render/ShaderLib');

  var ShaderMERGE = Shader.MERGE;
  var ShaderUV = Shader.UV;
  var ShaderPBR = Shader.PBR;
  var ShaderMatcap = Shader.MATCAP;

  var GuiRendering = function (guiParent, ctrlGui) {
    this._main = ctrlGui._main; // main application

    // ui rendering
    this._menu = null; // ui menu
    this._ctrlFlatShadizfng = null; // flat shading controller
    this._ctrlShowWireframe = null; // wireframe controller
    this._ctrlShaders = null; // shaders controller
    this._ctrlMatcap = null; // matcap texzfture controller
    this._ctrlUV = null; // upload a texture

    this.init(guiParent);
  };

  GuiRendering.prototype = {
    init: function (guiParent) {
      var menu = this._menu = guiParent.addMenu(TR('renderingTitle'));
      menu.close();

      // shader selection
      var optionsShaders = {};
      optionsShaders.MATCAP = TR('renderingMatcap');
      optionsShaders.PBR = TR('renderingPBR');
      optionsShaders.NORMAL = TR('renderingNormal');
      optionsShaders.UV = TR('renderingUV');
      menu.addTitle(TR('renderingShader'));
      this._ctrlShaders = menu.addCombobox('', 'PBR', this.onShaderChanged.bind(this), optionsShaders);

      // flat shading
      this._ctrlCurvature = menu.addSlider(TR('renderingCurvature'), 20, this.onCurvatureChanged.bind(this), 0, 100, 1);

      // filmic tonemapping
      this._ctrlFilmic = menu.addCheckbox(TR('renderingFilmic'), ShaderMERGE.FILMIC, this.onFilmic.bind(this));

      // environments
      var optionEnvs = {};
      for (var i = 0, envs = ShaderPBR.environments, l = envs.length; i < l; ++i)
        optionEnvs[i] = envs[i].name;
      this._ctrlEnvTitle = menu.addTitle(TR('renderingEnvironment'));
      this._ctrlEnv = menu.addCombobox('', ShaderPBR.idEnv, this.onEnvironmentChanged.bind(this), optionEnvs);

      // matcap texture
      var optionMatcaps = {};
      for (var j = 0, mats = ShaderMatcap.matcaps, k = mats.length; j < k; ++j)
        optionMatcaps[j] = mats[j].name;
      this._ctrlMatcapTitle = menu.addTitle(TR('renderingMaterial'));
      this._ctrlMatcap = menu.addCombobox(TR('renderingMatcap'), 0, this.onMatcapChanged.bind(this), optionMatcaps);

      // matcap load
      this._ctrlImportMatcap = menu.addButton(TR('renderingImportMatcap'), this, 'importMatcap');

      // uv texture
      this._ctrlUV = menu.addButton(TR('renderingImportUV'), this, 'importTexture');

      this._ctrlExposure = menu.addSlider(TR('renderingExposure'), 20, this.onExposureChanged.bind(this), 0, 100, 1);

      menu.addTitle(TR('renderingExtra'));
      this._ctrlTransparency = menu.addSlider(TR('renderingTransparency'), 0.0, this.onTransparencyChanged.bind(this), 0, 100, 1);

      // flat shading
      this._ctrlFlatShading = menu.addCheckbox(TR('renderingFlat'), false, this.onFlatShading.bind(this));

      // wireframe
      this._ctrlShowWireframe = menu.addCheckbox(TR('renderingWireframe'), false, this.onShowWireframe.bind(this));
      if (Render.ONLY_DRAW_ARRAYS)
        this._ctrlShowWireframe.setVisibility(false);

      this.addEvents();
    },
    onFilmic: function (val) {
      ShaderMERGE.FILMIC = val;
      this._main.render();
    },
    onCurvatureChanged: function (val) {
      if (!this._main.getMesh()) return;
      this._main.getMesh().setCurvature(val / 20.0);
      this._main.render();
    },
    onEnvironmentChanged: function (val) {
      ShaderPBR.idEnv = val;
      this._main.render();
    },
    onExposureChanged: function (val) {
      ShaderPBR.exposure = val / 20;
      this._main.render();
    },
    onTransparencyChanged: function (val) {
      if (!this._main.getMesh()) return;
      this._main.getMesh().setOpacity(1.0 - val / 100.0);
      this._main.render();
    },
    onShaderChanged: function (val) {
      var main = this._main;
      var mesh = main.getMesh();
      if (mesh) {
        if (val === 'UV' && !mesh.hasUV()) {
          this.updateMesh();
          window.alert('No UV on this mesh.');
        } else {
          mesh.setShaderName(val);
          main.render();
        }
      }
      this.updateVisibility();
    },
    onMatcapChanged: function (value) {
      if (!this._main.getMesh()) return;
      this._main.getMesh().setMatcap(value);
      this._main.render();
    },
    onFlatShading: function (bool) {
      if (!this._main.getMesh()) return;
      this._main.getMesh().setFlatShading(bool);
      this._main.render();
    },
    onShowWireframe: function (bool) {
      if (!this._main.getMesh()) return;
      this._main.getMesh().setShowWireframe(bool);
      this._main.render();
    },
    addEvents: function () {
      var cbLoadTex = this.loadTextureUV.bind(this);
      var cbLoadMatcap = this.loadMatcap.bind(this);
      document.getElementById('textureopen').addEventListener('change', cbLoadTex, false);
      document.getElementById('matcapopen').addEventListener('change', cbLoadMatcap, false);

      this.removeCallback = function () {
        document.getElementById('textureopen').removeEventListener('change', cbLoadTex, false);
        document.getElementById('matcapopen').removeEventListener('change', cbLoadMatcap, false);
      };
    },
    removeEvents: function () {
      if (this.removeCallback) this.removeCallback();
    },
    updateMesh: function () {
      var mesh = this._main.getMesh();
      if (!mesh) {
        this._menu.setVisibility(false);
        return;
      }
      this._menu.setVisibility(true);
      this._ctrlShaders.setValue(mesh.getShaderName(), true);
      this._ctrlFlatShading.setValue(mesh.getFlatShading(), true);
      this._ctrlShowWireframe.setValue(mesh.getShowWireframe(), true);
      this._ctrlMatcap.setValue(mesh.getMatcap(), true);
      this._ctrlTransparency.setValue(100 - 100 * mesh.getOpacity(), true);
      this._ctrlCurvature.setValue(20 * mesh.getCurvature(), true);
      this.updateVisibility();
    },
    updateVisibility: function () {
      var mesh = this._main.getMesh();
      if (!mesh) return;
      var val = mesh.getShaderName();
      this._ctrlMatcapTitle.setVisibility(val === 'MATCAP');
      this._ctrlMatcap.setVisibility(val === 'MATCAP');
      this._ctrlImportMatcap.setVisibility(val === 'MATCAP');

      this._ctrlExposure.setVisibility(val === 'PBR');
      this._ctrlEnvTitle.setVisibility(val === 'PBR');
      this._ctrlEnv.setVisibility(val === 'PBR');

      this._ctrlUV.setVisibility(val === 'UV');
    },
    getFlatShading: function () {
      return this._ctrlFlatShading.getValue();
    },
    getWireframe: function () {
      return this._ctrlShowWireframe.getValue();
    },
    getShaderName: function () {
      return this._ctrlShaders.getValue();
    },
    importTexture: function () {
      document.getElementById('textureopen').click();
    },
    loadTextureUV: function (event) {
      if (event.target.files.length === 0)
        return;

      var file = event.target.files[0];
      if (!file.type.match('image.*'))
        return;

      var reader = new FileReader();
      var main = this._main;
      reader.onload = function (evt) {
        // urk...
        ShaderUV.texture0 = undefined;
        ShaderUV.texPath = evt.target.result;
        main.render();
      };

      document.getElementById('textureopen').value = '';
      reader.readAsDataURL(file);
    },
    loadMatcap: function (event) {
      if (event.target.files.length === 0)
        return;

      var file = event.target.files[0];
      if (!file.type.match('image.*'))
        return;

      var reader = new FileReader();
      var main = this._main;
      var ctrl = this._ctrlMatcap;

      reader.onload = function (evt) {
        var img = new Image();
        img.src = evt.target.result;

        img.onload = function () {
          var idMatcap = ShaderMatcap.matcaps.length;
          ShaderMatcap.matcaps.push({
            name: file.name
          });

          ShaderMatcap.createTexture(main._gl, img, idMatcap);

          var entry = {};
          entry[idMatcap] = file.name;
          ctrl.addOptions(entry);
          ctrl.setValue(idMatcap);

          main.render();
        };
      };

      document.getElementById('matcapopen').value = '';
      reader.readAsDataURL(file);
    },
    importMatcap: function () {
      document.getElementById('matcapopen').click();
    },
    ////////////////
    // KEY EVENTS
    ////////////////
    onKeyUp: function (event) {
      if (event.which === 87 && !event.ctrlKey) // W
        this._ctrlShowWireframe.setValue(!this._ctrlShowWireframe.getValue());
    }
  };

  module.exports = GuiRendering;
});
define('gui/GuiScene',['require','exports','module','gui/GuiTR','editing/Remesh','render/shaders/ShaderBase'],function (require, exports, module) {

  'use strict';

  var TR = require('gui/GuiTR');
  var Remesh = require('editing/Remesh');
  var ShaderBase = require('render/shaders/ShaderBase');

  var GuiScene = function (guiParent, ctrlGui) {
    this._main = ctrlGui._main; // main application
    this._menu = null;
    this._hideMeshes = [];
    this._cbToggleShowHide = this.toggleShowHide.bind(this, true);
    this.init(guiParent);
  };

  GuiScene.prototype = {
    /** Initialize */
    init: function (guiParent) {
      var menu = this._menu = guiParent.addMenu(TR('sceneTitle'));

      // scene
      menu.addButton(TR('sceneReset'), this._main, 'clearScene' /*, 'CTRL+ALT+N'*/ );
      menu.addButton(TR('sceneAddSphere'), this._main, 'addSphere');
      menu.addButton(TR('sceneAddCube'), this._main, 'addCube');
      menu.addButton(TR('sceneAddCylinder'), this._main, 'addCylinder');
      menu.addButton(TR('sceneAddTorus'), this._main, 'addTorus');

      // menu.addTitle(TR('Torus'));
      // menu.addSlider(TR('Arc'), this._main._torusRadius, this.updateTorusRadius.bind(this), 0.01, Math.PI * 2, 0.001);
      // this.ctrlWI = menu.addSlider(TR('Width'), this._main._torusWidth, this.updateTorusWidth.bind(this), 0.01, 0.5, 0.01);
      // this.ctrlLE = menu.addSlider(TR('Length'), this._main._torusLength, this.updateTorusLength.bind(this), 0.2, 2.0, 0.01);
      // menu.addSlider(TR('Radial'), this._main._torusRadial, this.updateTorusRadial.bind(this), 3, 64, 1);
      // menu.addSlider(TR('Tubular'), this._main._torusTubular, this.updateTorusTubular.bind(this), 3, 256, 1);

      // this.ctrlValidate = menu.addButton(TR('Validate !'), this, 'validatePreview');
      // this.ctrlValidate.setVisibility(false);
      // this.ctrlDiscard = menu.addButton(TR('Discard !'), this, 'discardPreview');
      // this.ctrlDiscard.setVisibility(false);

      // selection stuffs
      menu.addTitle(TR('sceneSelection'));
      this._ctrlIsolate = menu.addCheckbox(TR('renderingIsolate'), false, this.showHide.bind(this));
      this._ctrlIsolate.setVisibility(false);
      this._ctrlMerge = menu.addButton(TR('sceneMerge'), this, 'merge');
      this._ctrlMerge.setVisibility(false);

      // extra
      menu.addTitle(TR('renderingExtra'));
      menu.addCheckbox(TR('darkenUnselected'), ShaderBase.darkenUnselected, this.onDarkenUnselected.bind(this));
      menu.addCheckbox(TR('contourShow'), this._main._showContour, this.onShowContour.bind(this));
      menu.addCheckbox(TR('renderingGrid'), this._main._showGrid, this.onShowGrid.bind(this));
      menu.addCheckbox(TR('renderingSymmetryLine'), ShaderBase.showSymmetryLine, this.onShowSymmetryLine.bind(this));
    },
    validatePreview: function () {
      if (!this._main._meshPreview)
        this._main.addTorus(true);

      this._main._meshPreview.setShowWireframe(false);
      this._main.addNewMesh(this._main._meshPreview);
      this._main._meshPreview = null;

      this.ctrlDiscard.setVisibility(false);
      this.ctrlValidate.setVisibility(false);
      this._main.render();
    },
    discardPreview: function () {
      this._main._meshPreview = null;
      this.ctrlDiscard.setVisibility(false);
      this.ctrlValidate.setVisibility(false);
      this._main.render();
    },
    updateTorusRadius: function (val) {
      this._main._torusRadius = val;
      this.updateTorus();
    },
    updateTorusRadial: function (val) {
      this._main._torusRadial = val;
      this.updateTorus();
    },
    updateTorusTubular: function (val) {
      this._main._torusTubular = val;
      this.updateTorus();
    },
    updateTorusWidth: function (val) {
      this._main._torusWidth = val;
      if (this._main._torusLength < this._main._torusWidth) {
        this.ctrlLE.setValue(val);
        return;
      }
      this.updateTorus();
    },
    updateTorusLength: function (val) {
      this._main._torusLength = val;
      if (this._main._torusLength < this._main._torusWidth) {
        this.ctrlWI.setValue(val);
        return;
      }
      this.updateTorus();
    },
    updateTorus: function () {
      this._main.addTorus(true);
      this.ctrlDiscard.setVisibility(true);
      this.ctrlValidate.setVisibility(true);
      this._main.render();
    },
    updateMesh: function () {
      var nbMeshes = this._main.getMeshes().length;
      var nbSelected = this._main.getSelectedMeshes().length;
      this._ctrlIsolate.setVisibility(this._hideMeshes.length > 0 || (nbMeshes !== nbSelected && nbSelected >= 1));
      this._ctrlMerge.setVisibility(nbSelected > 1);
    },
    merge: function () {
      var main = this._main;
      var selMeshes = main.getSelectedMeshes();
      if (selMeshes.length < 2) return;

      var newMesh = Remesh.mergeMeshes(selMeshes, main.getMesh() || selMeshes[0]);
      main.removeMeshes(selMeshes);
      main.getStates().pushStateAddRemove(newMesh, selMeshes.slice());
      main.getMeshes().push(newMesh);
      main.setMesh(newMesh);
    },
    toggleShowHide: function (ignoreCB) {
      this._ctrlIsolate.setValue(!this._ctrlIsolate.getValue(), !!ignoreCB);
    },
    showHide: function (bool) {
      if (bool) this.isolate();
      else this.showAll();
      this.updateMesh();
    },
    isolate: function () {
      var main = this._main;
      var selMeshes = main.getSelectedMeshes();
      var meshes = main.getMeshes();
      if (meshes.length === selMeshes.length || meshes.length < 2) {
        this._ctrlIsolate.setValue(false, true);
        return;
      }

      var hMeshes = this._hideMeshes;
      hMeshes.length = 0;
      for (var i = 0; i < meshes.length; ++i) {
        var id = main.getIndexSelectMesh(meshes[i]);
        if (id < 0) {
          hMeshes.push(meshes[i]);
          meshes.splice(i--, 1);
        }
      }

      main.getStates().pushStateRemove(hMeshes.slice());
      main.getStates().pushStateCustom(this._cbToggleShowHide, this._cbToggleShowHide, true);
      main.render();
    },
    showAll: function () {
      var main = this._main;
      var meshes = main.getMeshes();
      var hMeshes = this._hideMeshes;
      for (var i = 0, nbAdd = hMeshes.length; i < nbAdd; ++i) {
        meshes.push(hMeshes[i]);
      }
      main.getStates().pushStateAdd(hMeshes.slice());
      main.getStates().pushStateCustom(this._cbToggleShowHide, this._cbToggleShowHide, true);
      hMeshes.length = 0;
      main.render();
    },
    onDarkenUnselected: function (val) {
      ShaderBase.darkenUnselected = val;
      this._main.render();
    },
    onShowSymmetryLine: function (val) {
      ShaderBase.showSymmetryLine = val;
      this._main.render();
    },
    onShowGrid: function (bool) {
      var main = this._main;
      main._showGrid = bool;
      main.render();
    },
    onShowContour: function (bool) {
      var main = this._main;
      main._showContour = bool;
      main.render();
    },
    ////////////////
    // KEY EVENTS
    ////////////////
    onKeyDown: function (event) {
      if (event.handled === true)
        return;

      event.stopPropagation();
      if (!this._main._focusGui)
        event.preventDefault();

      if (event.which === 73) { // I
        this.toggleShowHide();
        event.handled = true;
      }
    }
  };

  module.exports = GuiScene;
});
define('math3d/Picking',['require','exports','module','lib/glMatrix','math3d/Geometry','misc/Tablet','misc/Utils','gui/GuiTR'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Geometry = require('math3d/Geometry');
  var Tablet = require('misc/Tablet');
  var Utils = require('misc/Utils');
  var TR = require('gui/GuiTR');

  var vec3 = glm.vec3;
  var mat4 = glm.mat4;

  var Picking = function (main, xSym) {
    this._mesh = null; // mesh
    this._main = main; // the camera
    this._pickedFace = -1; // face picked
    this._pickedVertices = []; // vertices selected
    this._interPoint = [0.0, 0.0, 0.0]; // intersection point (mesh local space)
    this._rLocal2 = 0.0; // radius of the selection area (local/object space)
    this._rWorld2 = 0.0; // radius of the selection area (world space)
    this._eyeDir = [0.0, 0.0, 0.0]; // eye direction

    this._xSym = !!xSym;

    this._pickedNormal = [0.0, 0.0, 0.0];
    // alpha stuffs
    this._alphaOrirign = [0.0, 0.0, 0.0];
    this._alphaSide = 0.0;
    this._alphaLookAt = mat4.create();
    this._alpha = null;
  };

  // TODO update i18n strings in a dynamic way
  Picking.INIT_ALPHAS_NAMES = [TR('alphaSquare'), TR('alphaSkin')];
  Picking.INIT_ALPHAS_PATHS = ['square.jpg', 'skin.jpg'];

  var none = TR('alphaNone');
  Picking.ALPHAS_NAMES = {};
  Picking.ALPHAS_NAMES[none] = none;

  Picking.ALPHAS = {};
  Picking.ALPHAS[Picking.ALPHAS_NAMES] = null;

  Picking.addAlpha = function (u8, width, height, name) {
    var newAlpha = {};
    newAlpha._name = name;
    newAlpha._texture = u8;
    newAlpha._ratioX = Math.max(1.0, width / height);
    newAlpha._ratioY = Math.max(1.0, height / width);
    newAlpha._ratioMax = Math.max(this._ratioX, this._ratioY);
    newAlpha._width = width;
    newAlpha._height = height;
    var i = 1;
    while (Picking.ALPHAS[newAlpha._name])
      newAlpha._name = name + (i++);
    Picking.ALPHAS[newAlpha._name] = newAlpha;
    Picking.ALPHAS_NAMES[newAlpha._name] = newAlpha._name;
    return newAlpha;
  };

  Picking.prototype = {
    setIdAlpha: function (id) {
      this._alpha = Picking.ALPHAS[id];
    },
    getAlpha: function (x, y, z) {
      var alpha = this._alpha;
      if (!alpha || !alpha._texture) return 1.0;

      var m = this._alphaLookAt;
      var rs = this._alphaSide;

      var xn = alpha._ratioY * (m[0] * x + m[4] * y + m[8] * z + m[12]) / (this._xSym ? -rs : rs);
      if (Math.abs(xn) > 1.0) return 0.0;

      var yn = alpha._ratioX * (m[1] * x + m[5] * y + m[9] * z + m[13]) / rs;
      if (Math.abs(yn) > 1.0) return 0.0;

      var aw = alpha._width;
      xn = (0.5 - xn * 0.5) * aw;
      yn = (0.5 - yn * 0.5) * alpha._height;
      return alpha._texture[(xn | 0) + aw * (yn | 0)] / 255.0;
    },
    updateAlpha: (function () {
      var nor = [0.0, 0.0, 0.0];
      var dir = [0.0, 0.0, 0.0];
      return function (keepOrigin) {
        var radius = Math.sqrt(this._rLocal2);
        this._alphaSide = radius * Math.SQRT1_2;

        vec3.sub(dir, this._interPoint, this._alphaOrirign);
        if (vec3.len(dir) === 0) return;
        vec3.normalize(dir, dir);

        var normal = this._pickedNormal;
        vec3.scaleAndAdd(dir, dir, normal, -vec3.dot(dir, normal));
        vec3.normalize(dir, dir);

        if (!keepOrigin)
          vec3.copy(this._alphaOrirign, this._interPoint);

        vec3.scaleAndAdd(nor, this._alphaOrirign, normal, radius);
        mat4.lookAt(this._alphaLookAt, this._alphaOrirign, nor, dir);
      };
    })(),
    initAlpha: function () {
      this.computePickedNormal();
      this.updateAlpha();
    },
    getMesh: function () {
      return this._mesh;
    },
    setLocalRadius2: function (radius) {
      this._rLocal2 = radius;
    },
    getLocalRadius2: function () {
      return this._rLocal2;
    },
    getLocalRadius: function () {
      return Math.sqrt(this._rLocal2);
    },
    getWorldRadius2: function () {
      return this._rWorld2;
    },
    getWorldRadius: function () {
      return Math.sqrt(this._rWorld2);
    },
    setIntersectionPoint: function (inter) {
      this._interPoint = inter;
    },
    getEyeDirection: function () {
      return this._eyeDir;
    },
    getIntersectionPoint: function () {
      return this._interPoint;
    },
    getPickedVertices: function () {
      return this._pickedVertices;
    },
    getPickedFace: function () {
      return this._pickedFace;
    },
    getPickedNormal: function () {
      return this._pickedNormal;
    },
    /** Intersection between a ray the mouse position for every meshes */
    intersectionMouseMeshes: (function () {
      var vNearTransform = [0.0, 0.0, 0.0];
      var vFarTransform = [0.0, 0.0, 0.0];
      var matInverse = mat4.create();
      var nearPoint = [0.0, 0.0, 0.0];
      return function (meshes, mouseX, mouseY) {

        var main = this._main;
        if (!meshes) meshes = main.getMeshes();
        if (mouseX === undefined) mouseX = main._mouseX;
        if (mouseY === undefined) mouseY = main._mouseY;

        var vNear = this.unproject(mouseX, mouseY, 0.0);
        var vFar = this.unproject(mouseX, mouseY, 0.1);
        var nearDistance = Infinity;
        var nearMesh = null;
        var nearFace = -1;

        for (var i = 0, nbMeshes = meshes.length; i < nbMeshes; ++i) {
          var mesh = meshes[i];
          mat4.invert(matInverse, mesh.getMatrix());
          vec3.transformMat4(vNearTransform, vNear, matInverse);
          vec3.transformMat4(vFarTransform, vFar, matInverse);
          if (!this.intersectionRayMesh(mesh, vNearTransform, vFarTransform))
            continue;

          var interTest = this.getIntersectionPoint();
          var testDistance = vec3.dist(vNearTransform, interTest) * mesh.getScale();
          if (testDistance < nearDistance) {
            nearDistance = testDistance;
            nearMesh = mesh;
            vec3.copy(nearPoint, interTest);
            nearFace = this.getPickedFace();
          }
        }

        this._mesh = nearMesh;
        vec3.copy(this._interPoint, nearPoint);
        this._pickedFace = nearFace;
        if (nearFace !== -1)
          this.updateLocalAndWorldRadius2();
        return !!nearMesh;
      };
    })(),
    /** Intersection between a ray the mouse position */
    intersectionMouseMesh: function (mesh, mouseX, mouseY) {
      var main = this._main;
      if (!mesh) mesh = main.getMesh();
      if (mouseX === undefined) mouseX = main._mouseX;
      if (mouseY === undefined) mouseY = main._mouseY;

      var vNear = this.unproject(mouseX, mouseY, 0.0);
      var vFar = this.unproject(mouseX, mouseY, 0.1);
      var matInverse = mat4.create();
      mat4.invert(matInverse, mesh.getMatrix());
      vec3.transformMat4(vNear, vNear, matInverse);
      vec3.transformMat4(vFar, vFar, matInverse);
      return this.intersectionRayMesh(mesh, vNear, vFar);
    },
    /** Intersection between a ray and a mesh */
    intersectionRayMesh: (function () {
      var v1 = [0.0, 0.0, 0.0];
      var v2 = [0.0, 0.0, 0.0];
      var v3 = [0.0, 0.0, 0.0];
      var vertInter = [0.0, 0.0, 0.0];
      var vNear = [0.0, 0.0, 0.0];
      var vFar = [0.0, 0.0, 0.0];
      return function (mesh, vNearOrig, vFarOrig) {
        // resest picking
        this._mesh = null;
        this._pickedFace = -1;
        // resest picking
        vec3.copy(vNear, vNearOrig);
        vec3.copy(vFar, vFarOrig);
        // apply symmetry
        if (this._xSym) {
          var ptPlane = mesh.getSymmetryOrigin();
          var nPlane = mesh.getSymmetryNormal();
          Geometry.mirrorPoint(vNear, ptPlane, nPlane);
          Geometry.mirrorPoint(vFar, ptPlane, nPlane);
        }
        var vAr = mesh.getVertices();
        var fAr = mesh.getFaces();
        // compute eye direction
        var eyeDir = this.getEyeDirection();
        vec3.sub(eyeDir, vFar, vNear);
        vec3.normalize(eyeDir, eyeDir);
        var iFacesCandidates = mesh.intersectRay(vNear, eyeDir, mesh.getNbFaces());
        var distance = Infinity;
        var nbFacesCandidates = iFacesCandidates.length;
        for (var i = 0; i < nbFacesCandidates; ++i) {
          var indFace = iFacesCandidates[i] * 4;
          var ind1 = fAr[indFace] * 3;
          var ind2 = fAr[indFace + 1] * 3;
          var ind3 = fAr[indFace + 2] * 3;
          v1[0] = vAr[ind1];
          v1[1] = vAr[ind1 + 1];
          v1[2] = vAr[ind1 + 2];
          v2[0] = vAr[ind2];
          v2[1] = vAr[ind2 + 1];
          v2[2] = vAr[ind2 + 2];
          v3[0] = vAr[ind3];
          v3[1] = vAr[ind3 + 1];
          v3[2] = vAr[ind3 + 2];
          var hitDist = Geometry.intersectionRayTriangle(vNear, eyeDir, v1, v2, v3, vertInter);
          if (hitDist < 0.0) {
            ind2 = fAr[indFace + 3] * 3;
            if (ind2 >= 0) {
              v2[0] = vAr[ind2];
              v2[1] = vAr[ind2 + 1];
              v2[2] = vAr[ind2 + 2];
              hitDist = Geometry.intersectionRayTriangle(vNear, eyeDir, v1, v3, v2, vertInter);
            }
          }
          if (hitDist >= 0.0 && hitDist < distance) {
            distance = hitDist;
            vec3.copy(this._interPoint, vertInter);
            this._pickedFace = iFacesCandidates[i];
          }
        }
        if (this._pickedFace !== -1) {
          this._mesh = mesh;
          this.updateLocalAndWorldRadius2();
          return true;
        }
        this._rLocal2 = 0.0;
        return false;
      };
    })(),
    /** Find all the vertices inside the sphere */
    pickVerticesInSphere: function (rLocal2) {
      var mesh = this._mesh;
      var vAr = mesh.getVertices();
      var vertSculptFlags = mesh.getVerticesSculptFlags();
      var leavesHit = mesh.getLeavesUpdate();
      var inter = this.getIntersectionPoint();

      var iFacesInCells = mesh.intersectSphere(inter, rLocal2, leavesHit, mesh.getNbFaces());
      var iVerts = mesh.getVerticesFromFaces(iFacesInCells);
      var nbVerts = iVerts.length;

      var sculptFlag = ++Utils.SCULPT_FLAG;
      var pickedVertices = new Uint32Array(Utils.getMemory(4 * nbVerts + 12), 0, nbVerts + 3);
      var acc = 0;
      var itx = inter[0];
      var ity = inter[1];
      var itz = inter[2];

      for (var i = 0; i < nbVerts; ++i) {
        var ind = iVerts[i];
        var j = ind * 3;
        var dx = itx - vAr[j];
        var dy = ity - vAr[j + 1];
        var dz = itz - vAr[j + 2];
        if ((dx * dx + dy * dy + dz * dz) < rLocal2) {
          vertSculptFlags[ind] = sculptFlag;
          pickedVertices[acc++] = ind;
        }
      }

      this._pickedVertices = new Uint32Array(pickedVertices.subarray(0, acc));
      return this._pickedVertices;
    },
    /** Find all the vertices inside the sphere (with topological check) */
    pickVerticesInSphereTopological: function (rLocal2) {
      var mesh = this._mesh;
      var nbVertices = mesh.getNbVertices();
      var vAr = mesh.getVertices();
      var fAr = mesh.getFaces();

      var vrvStartCount = mesh.getVerticesRingVertStartCount();
      var vertRingVert = mesh.getVerticesRingVert();
      var ringVerts = vertRingVert instanceof Array ? vertRingVert : null;

      var vertSculptFlags = mesh.getVerticesSculptFlags();
      var sculptFlag = ++Utils.SCULPT_FLAG;

      var idf = this.getPickedFace();
      var pickedVertices = new Uint32Array(Utils.getMemory(4 * nbVertices), 0, nbVertices);
      pickedVertices[0] = fAr[idf * 4];
      var acc = 1;

      var inter = this.getIntersectionPoint();
      var itx = inter[0];
      var ity = inter[1];
      var itz = inter[2];
      for (var i = 0; i < acc; ++i) {
        var id = pickedVertices[i];
        var start, end;
        if (ringVerts) {
          vertRingVert = ringVerts[id];
          start = 0;
          end = vertRingVert.length;
        } else {
          start = vrvStartCount[id * 2];
          end = start + vrvStartCount[id * 2 + 1];
        }

        for (var j = start; j < end; ++j) {
          var idv = vertRingVert[j];
          if (vertSculptFlags[idv] === sculptFlag)
            continue;
          vertSculptFlags[idv] = sculptFlag;
          var id3 = idv * 3;
          var dx = itx - vAr[id3];
          var dy = ity - vAr[id3 + 1];
          var dz = itz - vAr[id3 + 2];
          if ((dx * dx + dy * dy + dz * dz) > rLocal2)
            continue;
          pickedVertices[acc++] = idv;
        }
      }
      this._pickedVertices = new Uint32Array(pickedVertices.subarray(1, acc));
      return this._pickedVertices;
    },
    computeWorldRadius2: (function () {
      var inter = [0.0, 0.0, 0.0];

      return function (ignorePressure) {

        vec3.transformMat4(inter, this.getIntersectionPoint(), this._mesh.getMatrix());

        var offsetX = this._main.getSculpt().getCurrentTool().getScreenRadius();
        if (!ignorePressure) offsetX *= Tablet.getPressureRadius();

        var screenInter = this.project(inter);
        return vec3.sqrDist(inter, this.unproject(screenInter[0] + offsetX, screenInter[1], screenInter[2]));
      };
    })(),
    updateLocalAndWorldRadius2: function () {
      if (!this._mesh) return;
      this._rWorld2 = this.computeWorldRadius2();
      this._rLocal2 = this._rWorld2 / this._mesh.getScale2();
    },
    unproject: function (x, y, z) {
      return this._main.getCamera().unproject(x, y, z);
    },
    project: function (vec) {
      return this._main.getCamera().project(vec);
    },
    computePickedNormal: function () {
      if (!this._mesh || this._pickedFace < 0) return;
      this.polyLerp(this._mesh.getNormals(), this._pickedNormal);
      return vec3.normalize(this._pickedNormal, this._pickedNormal);
    },
    polyLerp: function (vField, out) {
      var vAr = this._mesh.getVertices();
      var fAr = this._mesh.getFaces();
      var id = this._pickedFace * 4;
      var iv1 = fAr[id] * 3;
      var iv2 = fAr[id + 1] * 3;
      var iv3 = fAr[id + 2] * 3;
      var iv4 = fAr[id + 3] * 3;

      var len1 = 1.0 / vec3.dist(this._interPoint, vAr.subarray(iv1, iv1 + 3));
      var len2 = 1.0 / vec3.dist(this._interPoint, vAr.subarray(iv2, iv2 + 3));
      var len3 = 1.0 / vec3.dist(this._interPoint, vAr.subarray(iv3, iv3 + 3));
      var len4 = iv4 >= 0 ? 1.0 / vec3.dist(this._interPoint, vAr.subarray(iv4, iv4 + 3)) : 0.0;

      var invSum = 1.0 / (len1 + len2 + len3 + len4);
      vec3.set(out, 0.0, 0.0, 0.0);
      vec3.scaleAndAdd(out, out, vField.subarray(iv1, iv1 + 3), len1 * invSum);
      vec3.scaleAndAdd(out, out, vField.subarray(iv2, iv2 + 3), len2 * invSum);
      vec3.scaleAndAdd(out, out, vField.subarray(iv3, iv3 + 3), len3 * invSum);
      if (iv4 >= 0) vec3.scaleAndAdd(out, out, vField.subarray(iv4, iv4 + 3), len4 * invSum);
      return out;
    }
  };

  module.exports = Picking;
});
define('gui/GuiSculptingTools',['require','exports','module','lib/glMatrix','editing/tools/Tools','gui/GuiTR','math3d/Picking','misc/Utils'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Tools = require('editing/tools/Tools');
  var TR = require('gui/GuiTR');
  var Picking = require('math3d/Picking');
  var Utils = require('misc/Utils');

  var vec3 = glm.vec3;

  var GuiSculptingTools = {};

  GuiSculptingTools.initGuiTools = function (sculpt, menu, main) {
    // init each tools ui
    var tnames = Tools.keys;
    for (var i = 0, nbTools = tnames.length; i < nbTools; ++i) {
      var tn = tnames[i];
      var uTool = GuiSculptingTools[tn];
      if (!uTool) {
        console.error('No gui for : ' + tn);
        GuiSculptingTools[tn] = {
          _ctrls: [],
          init: function () {}
        };
      }
      GuiSculptingTools[tn].init(sculpt.getTool(tn), menu, main);
      GuiSculptingTools.hide(tn);
    }
  };

  GuiSculptingTools.hide = function (toolKey) {
    for (var i = 0, ctrls = GuiSculptingTools[toolKey]._ctrls, nbCtrl = ctrls.length; i < nbCtrl; ++i)
      ctrls[i].setVisibility(false);
  };

  GuiSculptingTools.show = function (toolKey) {
    for (var i = 0, ctrls = GuiSculptingTools[toolKey]._ctrls, nbCtrl = ctrls.length; i < nbCtrl; ++i)
      ctrls[i].setVisibility(true);
  };

  var setOnChange = function (key, factor, val) {
    this[key] = factor ? val / factor : val;
  };

  // some helper functions
  var addCtrlRadius = function (tool, fold, widget, main) {
    var ctrl = fold.addSlider(TR('sculptRadius'), tool._radius, function (val) {
      setOnChange.call(tool, '_radius', 1, val);
      if (main.getSelectionRadius().getOffsetX() === 0.0)
        main.getSelectionRadius().setOffsetX(0.01); // it just have to be !== 0
      main.renderSelectOverRtt();
    }, 5, 500, 1);
    widget._ctrlRadius = ctrl;
    return ctrl;
  };
  var addCtrlIntensity = function (tool, fold, widget) {
    var ctrl = fold.addSlider(TR('sculptIntensity'), tool._intensity * 100, setOnChange.bind(tool, '_intensity', 100), 0, 100, 1);
    widget._ctrlIntensity = ctrl;
    return ctrl;
  };
  var addCtrlHardness = function (tool, fold) {
    return fold.addSlider(TR('sculptHardness'), tool._hardness * 100, setOnChange.bind(tool, '_hardness', 100), 0, 100, 1);
  };
  var addCtrlCulling = function (tool, fold) {
    return fold.addCheckbox(TR('sculptCulling'), tool, '_culling');
  };
  var addCtrlNegative = function (tool, fold, widget, name) {
    var ctrl = fold.addCheckbox(name || TR('sculptNegative'), tool, '_negative');
    widget.toggleNegative = function () {
      ctrl.setValue(!ctrl.getValue());
    };
    return ctrl;
  };

  var importAlpha = function () {
    document.getElementById('alphaopen').click();
  };
  var addCtrlAlpha = function (ctrls, fold, tool, ui) {
    ctrls.push(fold.addTitle(TR('sculptAlphaTitle')));
    if (tool._lockPosition !== undefined)
      ctrls.push(fold.addCheckbox(TR('sculptLockPositon'), tool, '_lockPosition'));
    ui._ctrlAlpha = fold.addCombobox(TR('sculptAlphaTex'), tool, '_idAlpha', Picking.ALPHAS_NAMES);
    ctrls.push(ui._ctrlAlpha);
    ctrls.push(fold.addButton(TR('sculptImportAlpha'), importAlpha));
  };

  GuiSculptingTools.BRUSH = {
    _ctrls: [],
    init: function (tool, fold, main) {
      this._ctrls.push(addCtrlRadius(tool, fold, this, main));
      this._ctrls.push(addCtrlIntensity(tool, fold, this));
      this._ctrls.push(addCtrlNegative(tool, fold, this));
      this._ctrls.push(fold.addCheckbox(TR('sculptClay'), tool, '_clay'));
      this._ctrls.push(fold.addCheckbox(TR('sculptAccumulate'), tool, '_accumulate'));
      this._ctrls.push(addCtrlCulling(tool, fold));
      addCtrlAlpha(this._ctrls, fold, tool, this);
    }
  };

  GuiSculptingTools.CREASE = {
    _ctrls: [],
    init: function (tool, fold, main) {
      this._ctrls.push(addCtrlRadius(tool, fold, this, main));
      this._ctrls.push(addCtrlIntensity(tool, fold, this));
      this._ctrls.push(addCtrlNegative(tool, fold, this));
      this._ctrls.push(addCtrlCulling(tool, fold));
      addCtrlAlpha(this._ctrls, fold, tool, this);
    }
  };

  GuiSculptingTools.DRAG = {
    _ctrls: [],
    init: function (tool, fold, main) {
      this._ctrls.push(addCtrlRadius(tool, fold, this, main));
      addCtrlAlpha(this._ctrls, fold, tool, this);
    }
  };

  GuiSculptingTools.FLATTEN = {
    _ctrls: [],
    init: function (tool, fold, main) {
      this._ctrls.push(addCtrlRadius(tool, fold, this, main));
      this._ctrls.push(addCtrlIntensity(tool, fold, this));
      this._ctrls.push(addCtrlNegative(tool, fold, this));
      this._ctrls.push(addCtrlCulling(tool, fold));
      addCtrlAlpha(this._ctrls, fold, tool, this);
    }
  };

  GuiSculptingTools.INFLATE = {
    _ctrls: [],
    init: function (tool, fold, main) {
      this._ctrls.push(addCtrlRadius(tool, fold, this, main));
      this._ctrls.push(addCtrlIntensity(tool, fold, this));
      this._ctrls.push(addCtrlNegative(tool, fold, this));
      this._ctrls.push(addCtrlCulling(tool, fold));
      addCtrlAlpha(this._ctrls, fold, tool, this);
    }
  };

  GuiSculptingTools.PAINT = {
    _ctrls: [],
    onMaterialChanged: function (main, tool, materials) {
      vec3.copy(tool._color, materials[0].getValue());
      tool._material[0] = materials[1].getValue() / 100;
      tool._material[1] = materials[2].getValue() / 100;

      var mesh = main.getMesh();
      if (!mesh) return;

      mesh.setAlbedo(tool._color);
      mesh.setRoughness(tool._material[0]);
      mesh.setMetallic(tool._material[1]);
      main.render();
    },
    resetMaterialOverride: function (main, tool) {
      if (this._ctrlPicker.getValue() !== tool._pickColor)
        this._ctrlPicker.setValue(tool._pickColor);

      var mesh = main.getMesh();
      if (!mesh || !mesh.getAlbedo) return;

      mesh.getAlbedo()[0] = -1.0;
      mesh.setRoughness(-1.0);
      mesh.setMetallic(-1.0);
      main.render();
    },
    onPickedMaterial: function (materials, tool, main, color, roughness, metallic) {
      main.setCanvasCursor(Utils.cursors.dropper);
      materials[0].setValue(color, true);
      materials[1].setValue(roughness * 100, true);
      materials[2].setValue(metallic * 100, true);
      vec3.copy(tool._color, color);
      tool._material[0] = roughness;
      tool._material[1] = metallic;
    },
    onColorPick: function (tool, main, val) {
      tool._pickColor = val;
      main.setCanvasCursor(val ? Utils.cursors.dropper : 'default');
      main._action = val ? 'SCULPT_EDIT' : 'NOTHING';
      main.renderSelectOverRtt();
    },
    init: function (tool, fold, main) {
      this._ctrls.push(addCtrlRadius(tool, fold, this, main));
      this._ctrls.push(addCtrlIntensity(tool, fold, this));
      this._ctrls.push(addCtrlHardness(tool, fold, this));
      this._ctrls.push(addCtrlCulling(tool, fold));

      this._ctrls.push(fold.addTitle(TR('sculptPBRTitle')));
      this._ctrls.push(fold.addButton(TR('sculptPaintAll'), tool, 'paintAll'));
      this._ctrlPicker = fold.addCheckbox(TR('sculptPickColor'), tool._pickColor, this.onColorPick.bind(this, tool, main));
      this._ctrls.push(this._ctrlPicker);

      var materials = [];
      var cbMatChanged = this.onMaterialChanged.bind(this, main, tool, materials);
      var ctrlColor = fold.addColor(TR('sculptColor'), tool._color, cbMatChanged);
      var ctrlRoughness = fold.addSlider(TR('sculptRoughness'), tool._material[0] * 100, cbMatChanged, 0, 100, 1);
      var ctrlMetallic = fold.addSlider(TR('sculptMetallic'), tool._material[1] * 100, cbMatChanged, 0, 100, 1);
      materials.push(ctrlColor, ctrlRoughness, ctrlMetallic);

      window.addEventListener('keyup', this.resetMaterialOverride.bind(this, main, tool));
      window.addEventListener('mouseup', this.resetMaterialOverride.bind(this, main, tool));

      tool.setPickCallback(this.onPickedMaterial.bind(this, materials, tool, main));

      this._ctrls.push(ctrlColor, ctrlRoughness, ctrlMetallic);
      addCtrlAlpha(this._ctrls, fold, tool, this);
    }
  };

  GuiSculptingTools.PINCH = {
    _ctrls: [],
    init: function (tool, fold, main) {
      this._ctrls.push(addCtrlRadius(tool, fold, this, main));
      this._ctrls.push(addCtrlIntensity(tool, fold, this));
      this._ctrls.push(addCtrlNegative(tool, fold, this));
      this._ctrls.push(addCtrlCulling(tool, fold));
      addCtrlAlpha(this._ctrls, fold, tool, this);
    }
  };

  GuiSculptingTools.TWIST = {
    _ctrls: [],
    init: function (tool, fold, main) {
      this._ctrls.push(addCtrlRadius(tool, fold, this, main));
      this._ctrls.push(addCtrlCulling(tool, fold));
      addCtrlAlpha(this._ctrls, fold, tool, this);
    }
  };

  GuiSculptingTools.LOCALSCALE = {
    _ctrls: [],
    init: function (tool, fold, main) {
      this._ctrls.push(addCtrlRadius(tool, fold, this, main));
      this._ctrls.push(addCtrlCulling(tool, fold));
      addCtrlAlpha(this._ctrls, fold, tool, this);
    }
  };

  GuiSculptingTools.MOVE = {
    _ctrls: [],
    init: function (tool, fold, main) {
      this._ctrls.push(addCtrlRadius(tool, fold, this, main));
      this._ctrls.push(addCtrlIntensity(tool, fold, this));
      this._ctrls.push(fold.addCheckbox(TR('sculptTopologicalCheck'), tool, '_topoCheck'));
      this._ctrls.push(addCtrlNegative(tool, fold, this, TR('sculptMoveAlongNormal')));
      addCtrlAlpha(this._ctrls, fold, tool, this);
    }
  };

  GuiSculptingTools.SMOOTH = {
    _ctrls: [],
    init: function (tool, fold, main) {
      this._ctrls.push(addCtrlRadius(tool, fold, this, main));
      this._ctrls.push(addCtrlIntensity(tool, fold, this));
      this._ctrls.push(fold.addCheckbox(TR('sculptTangentialSmoothing'), tool, '_tangent'));
      this._ctrls.push(addCtrlCulling(tool, fold));
      addCtrlAlpha(this._ctrls, fold, tool, this);
    }
  };

  GuiSculptingTools.MASKING = {
    _ctrls: [],
    init: function (tool, fold, main) {
      this._ctrls.push(addCtrlRadius(tool, fold, this, main));
      this._ctrls.push(addCtrlIntensity(tool, fold, this));
      this._ctrls.push(addCtrlHardness(tool, fold, this));
      this._ctrls.push(addCtrlNegative(tool, fold, this));
      this._ctrls.push(addCtrlCulling(tool, fold));
      this._main = main;
      this._tool = tool;
      var bci = fold.addDualButton(TR('sculptMaskingClear'), TR('sculptMaskingInvert'), tool, tool, 'clear', 'invert');
      var bbs = fold.addDualButton(TR('sculptMaskingBlur'), TR('sculptMaskingSharpen'), tool, tool, 'blur', 'sharpen');
      this._ctrls.push(bci[0], bci[1], bbs[0], bbs[1]);
      // mask extract
      this._ctrls.push(fold.addTitle(TR('sculptExtractTitle')));
      this._ctrls.push(fold.addSlider(TR('sculptExtractThickness'), tool, '_thickness', -5, 5, 0.001));
      this._ctrls.push(fold.addButton(TR('sculptExtractAction'), tool, 'extract'));
      addCtrlAlpha(this._ctrls, fold, tool, this);
    }
  };

  GuiSculptingTools.TRANSFORM = {
    _ctrls: [],
    init: function () {}
  };

  module.exports = GuiSculptingTools;
});
define('gui/GuiSculpting',['require','exports','module','gui/GuiTR','editing/tools/Tools','misc/getOptionsURL','gui/GuiSculptingTools'],function (require, exports, module) {

  'use strict';

  var TR = require('gui/GuiTR');
  var Tools = require('editing/tools/Tools');
  var getOptionsURL = require('misc/getOptionsURL');
  var GuiSculptingTools = require('gui/GuiSculptingTools');

  var GuiSculpting = function (guiParent, ctrlGui) {
    this._main = ctrlGui._main; // main application
    this._ctrlGui = ctrlGui; // main gui
    this._sculpt = ctrlGui._main.getSculpt(); // sculpting management
    this._toolOnRelease = -1; // tool to apply when the mouse or the key is released
    this._invertSign = false; // invert sign of tool (add/sub)

    this._modalBrushRadius = false; // modal brush radius change
    this._modalBrushIntensity = false; // modal brush intensity change

    // modal stuffs (not canvas based, because no 3D picking involved)
    this._lastPageX = 0;
    this._lastPageY = 0;
    // for modal radius
    this._refX = 0;
    this._refY = 0;

    this._menu = null;
    this._ctrlSculpt = null;
    this._ctrlSymmetry = null;
    this._ctrlContinuous = null;
    this._ctrlTitleCommon = null;
    this.init(guiParent);
  };

  GuiSculpting.prototype = {
    /** Initialisculze */
    init: function (guiParent) {
      var menu = this._menu = guiParent.addMenu(TR('sculptTitle'));
      menu.open();

      menu.addTitle(TR('sculptTool'));

      // sculpt tool
      var optTools = {};
      var tools = Tools.keys;
      for (var i = 0, nbTools = tools.length; i < nbTools; ++i) {
        var tn = tools[i];
        optTools[tn] = TR(Tools[tn].uiName);
      }
      this._ctrlSculpt = menu.addCombobox(TR('sculptTool'), this._sculpt._tool, this.onChangeTool.bind(this), optTools);

      GuiSculptingTools.initGuiTools(this._sculpt, this._menu, this._main);

      this._ctrlTitleCommon = menu.addTitle(TR('sculptCommon'));
      // symmetry
      this._ctrlSymmetry = menu.addCheckbox(TR('sculptSymmetry'), this._sculpt._symmetry, this.onSymmetryChange.bind(this));
      // continuous
      this._ctrlContinuous = menu.addCheckbox(TR('sculptContinuous'), this._sculpt, '_continuous');

      GuiSculptingTools.show(this._sculpt._tool);
      this.addEvents();
      this.onChangeTool(this._sculpt._tool);
    },
    onSymmetryChange: function (value) {
      this._sculpt._symmetry = value;
      this._main.render();
    },
    addEvents: function () {
      var cbLoadAlpha = this.loadAlpha.bind(this);
      document.getElementById('alphaopen').addEventListener('change', cbLoadAlpha, false);
      this.removeCallback = function () {
        document.getElementById('alphaopen').removeEventListener('change', cbLoadAlpha, false);
      };
    },
    removeEvents: function () {
      if (this.removeCallback) this.removeCallback();
    },
    getSelectedTool: function () {
      return this._ctrlSculpt.getValue();
    },
    releaseInvertSign: function () {
      if (!this._invertSign)
        return;
      this._invertSign = false;
      var tool = GuiSculptingTools[this.getSelectedTool()];
      if (tool.toggleNegative)
        tool.toggleNegative();
    },
    onChangeTool: function (newValue) {
      GuiSculptingTools.hide(this._sculpt._tool);
      this._sculpt._tool = newValue;
      GuiSculptingTools.show(newValue);

      var showContinuous = this._sculpt.canBeContinuous() === true;
      this._ctrlContinuous.setVisibility(showContinuous);

      var showSym = newValue !== 'TRANSFORM';
      this._ctrlSymmetry.setVisibility(showSym);

      this._ctrlTitleCommon.setVisibility(showContinuous || showSym);

      this._main.getPicking().updateLocalAndWorldRadius2();
    },
    loadAlpha: function (event) {
      if (event.target.files.length === 0)
        return;

      var file = event.target.files[0];
      if (!file.type.match('image.*'))
        return;

      var reader = new FileReader();
      var main = this._main;
      var tool = GuiSculptingTools[main.getSculpt()._tool];

      reader.onload = function (evt) {
        var img = new Image();
        img.src = evt.target.result;
        img.onload = main.onLoadAlphaImage.bind(main, img, file.name || 'new alpha', tool);
      };

      document.getElementById('alphaopen').value = '';
      reader.readAsDataURL(file);
    },
    addAlphaOptions: function (opts) {
      var keys = Tools.keys;
      for (var i = 0, nb = keys.length; i < nb; ++i) {
        var t = GuiSculptingTools[keys[i]];
        if (t && t._ctrlAlpha) t._ctrlAlpha.addOptions(opts);
      }
    },
    updateMesh: function () {
      this._menu.setVisibility(!!this._main.getMesh());
    },
    _startModalBrushRadius: function (x, y) {
      this._refX = x;
      this._refY = y;
      var cur = GuiSculptingTools[this.getSelectedTool()];
      if (cur._ctrlRadius) {
        var rad = cur._ctrlRadius.getValue();
        this._refX -= rad;
        this._main.getSelectionRadius().setOffsetX(-rad * this._main.getPixelRatio());
        this._main.renderSelectOverRtt();
      }
    },
    _checkModifierKey: function (event) {
      var selectedTool = this.getSelectedTool();

      if (this._main._action === 'NOTHING') {
        if (event.shiftKey && !event.altKey && !event.ctrlKey) {
          // smoothing on shift key
          if (selectedTool !== 'SMOOTH') {
            this._toolOnRelease = selectedTool;
            this._ctrlSculpt.setValue('SMOOTH');
          }
        }
        if (event.ctrlKey && !event.shiftKey && !event.altKey) {
          // masking on ctrl key
          if (selectedTool !== 'MASKING') {
            this._toolOnRelease = selectedTool;
            this._ctrlSculpt.setValue('MASKING');
          }
        }
      }
      if (event.altKey) {
        // invert sign on alt key
        if (this._invertSign || event.shiftKey) return true;
        this._invertSign = true;
        var curTool = GuiSculptingTools[selectedTool];
        if (curTool.toggleNegative)
          curTool.toggleNegative();
        return true;
      }
      return false;
    },
    ////////////////
    // KEY EVENTS
    //////////////// 
    onKeyDown: function (event) {
      if (event.handled === true)
        return;

      var main = this._main;
      var key = event.which;
      event.stopPropagation();

      if (!main._focusGui || key === 88 || key === 67)
        event.preventDefault();

      event.handled = true;
      if (this._checkModifierKey(event))
        return;

      if (main._action !== 'NOTHING')
        return;

      // handles numpad
      if (key >= 96 && key <= 105) key -= 48;
      var opts = getOptionsURL();
      var strTool = opts.shortcuts[key];
      if (strTool && Tools[strTool])
        return this._ctrlSculpt.setValue(strTool);

      var cur = GuiSculptingTools[this.getSelectedTool()];

      switch (key) {
      case 46: // DEL
        main.deleteCurrentSelection();
        break;
      case 67: // C
        this._modalBrushIntensity = main._focusGui = true;
        break;
      case 78: // N
        if (cur.toggleNegative) cur.toggleNegative();
        break;
      case 83: // S
        var ctrlPicker = cur._ctrlPicker;
        if (ctrlPicker && !ctrlPicker.getValue()) ctrlPicker.setValue(true);
        break;
      case 88: // X
        if (!this._modalBrushRadius) this._startModalBrushRadius(this._lastPageX, this._lastPageY);
        this._modalBrushRadius = main._focusGui = true;
        break;
      default:
        event.handled = false;
      }
    },
    onKeyUp: function (event) {
      var releaseTool = this._main._action === 'NOTHING' && this._toolOnRelease !== -1 && !event.ctrlKey && !event.shiftKey;
      if (!event.altKey || releaseTool)
        this.releaseInvertSign();

      if (releaseTool) {
        this._ctrlSculpt.setValue(this._toolOnRelease);
        this._toolOnRelease = -1;
      }

      var main = this._main;
      switch (event.which) {
      case 88: // X
        this._modalBrushRadius = main._focusGui = false;
        main.getSelectionRadius().setOffsetX(0.0);
        event.pageX = this._lastPageX;
        event.pageY = this._lastPageY;
        main.setMousePosition(event);
        main.getPicking().intersectionMouseMeshes();
        main.renderSelectOverRtt();
        break;
      case 83: // S
        var cur = GuiSculptingTools[this.getSelectedTool()];
        var ctrlPicker = cur._ctrlPicker;
        if (ctrlPicker && ctrlPicker.getValue()) ctrlPicker.setValue(false);
        break;
      case 67: // C
        this._modalBrushIntensity = main._focusGui = false;
        break;
      }
    },
    ////////////////
    // MOUSE EVENTS
    ////////////////
    onMouseUp: function (event) {
      if (this._toolOnRelease !== -1 && !event.ctrlKey && !event.shiftKey) {
        this.releaseInvertSign();
        this._ctrlSculpt.setValue(this._toolOnRelease);
        this._toolOnRelease = -1;
      }
    },
    onMouseMove: function (event) {
      var wid = GuiSculptingTools[this.getSelectedTool()];

      if (this._modalBrushRadius && wid._ctrlRadius) {
        var dx = event.pageX - this._refX;
        var dy = event.pageY - this._refY;
        wid._ctrlRadius.setValue(Math.sqrt(dx * dx + dy * dy));
        this._main.renderSelectOverRtt();
      }

      if (this._modalBrushIntensity && wid._ctrlIntensity) {
        wid._ctrlIntensity.setValue(wid._ctrlIntensity.getValue() + event.pageX - this._lastPageX);
      }

      this._lastPageX = event.pageX;
      this._lastPageY = event.pageY;
    },
    onMouseOver: function (event) {
      if (this._modalBrushRadius)
        this._startModalBrushRadius(event.pageX, event.pageY);
    }
  };

  module.exports = GuiSculpting;
});
define('states/StateAddRemove',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var StateAddRemove = function (main, addedMeshes, removedMeshes) {
    this._main = main; // main application
    this._addedMeshes = addedMeshes.length !== undefined ? addedMeshes : [addedMeshes]; // the added meshes
    this._removedMeshes = removedMeshes.length !== undefined ? removedMeshes : [removedMeshes]; // the deleted meshes
    this._selectMeshes = main.getSelectedMeshes().slice();
  };

  StateAddRemove.prototype = {
    isNoop: function () {
      return this._addedMeshes.length === 0 && this._removedMeshes.length === 0;
    },
    undo: function () {
      var main = this._main;
      var meshesMain = main.getMeshes();
      var addMeshes = this._addedMeshes;
      var i, l;
      for (i = 0, l = addMeshes.length; i < l; ++i)
        meshesMain.splice(main.getIndexMesh(addMeshes[i]), 1);
      var remMeshes = this._removedMeshes;
      for (i = 0, l = remMeshes.length; i < l; ++i)
        meshesMain.push(remMeshes[i]);
      // re link the mesh's render to the current mesh
      for (i = 0, l = meshesMain.length; i < l; ++i) {
        var mesh = meshesMain[i];
        mesh.getRender()._mesh = mesh;
        mesh.initRender();
      }

      var sel = this._selectMeshes;
      main.setMesh(sel[0] ? sel[0] : null);
      var sMeshes = main.getSelectedMeshes();
      sMeshes.length = 0;
      for (i = 0, l = sel.length; i < l; ++i)
        sMeshes.push(sel[i]);
    },
    redo: function () {
      this.undo();
    },
    createRedo: function () {
      return new StateAddRemove(this._main, this._removedMeshes, this._addedMeshes);
    }
  };

  module.exports = StateAddRemove;
});
define('states/StateColorAndMaterial',['require','exports','module','misc/Utils'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');

  var StateColorAndMaterial = function (main, mesh) {
    this._main = main; // main application
    this._mesh = mesh; // the mesh
    this._idVertState = []; // ids of vertices
    this._cArState = []; // copies of color vertices
    this._mArState = []; // copies of material vertices
  };

  StateColorAndMaterial.prototype = {
    isNoop: function () {
      return this._idVertState.length === 0;
    },
    undo: function (skipUpdate) {
      this.pullVertices();
      if (skipUpdate) return;
      var mesh = this._mesh;
      mesh.updateDuplicateColorsAndMaterials();
      mesh.updateDrawArrays();
      mesh.updateColorBuffer();
      mesh.updateMaterialBuffer();
      this._main.setMesh(mesh);
    },
    redo: function () {
      this.undo();
    },
    createRedo: function () {
      var redo = new StateColorAndMaterial(this._main, this._mesh);
      this.pushRedoVertices(redo);
      return redo;
    },
    pushVertices: function (iVerts) {
      var idVertState = this._idVertState;
      var cArState = this._cArState;
      var mArState = this._mArState;

      var mesh = this._mesh;
      var cAr = mesh.getColors();
      var mAr = mesh.getMaterials();
      var vertStateFlags = mesh.getVerticesStateFlags();

      var stateFlag = Utils.STATE_FLAG;
      var nbVerts = iVerts.length;
      for (var i = 0; i < nbVerts; ++i) {
        var id = iVerts[i];
        if (vertStateFlags[id] === stateFlag)
          continue;
        vertStateFlags[id] = stateFlag;
        idVertState.push(id);
        id *= 3;
        cArState.push(cAr[id], cAr[id + 1], cAr[id + 2]);
        mArState.push(mAr[id], mAr[id + 1], mAr[id + 2]);
      }
    },
    pushRedoVertices: function (redoState) {
      var mesh = redoState._mesh;
      var cAr = mesh.getColors();
      var mAr = mesh.getMaterials();

      var idVertUndoState = this._idVertState;
      var nbVerts = idVertUndoState.length;

      var cArRedoState = redoState._cArState = new Float32Array(nbVerts * 3);
      var mArRedoState = redoState._mArState = new Float32Array(nbVerts * 3);
      var idVertRedoState = redoState._idVertState = new Uint32Array(nbVerts);
      for (var i = 0; i < nbVerts; ++i) {
        var id = idVertRedoState[i] = idVertUndoState[i];
        id *= 3;
        var j = i * 3;
        cArRedoState[j] = cAr[id];
        cArRedoState[j + 1] = cAr[id + 1];
        cArRedoState[j + 2] = cAr[id + 2];
        mArRedoState[j] = mAr[id];
        mArRedoState[j + 1] = mAr[id + 1];
        mArRedoState[j + 2] = mAr[id + 2];
      }
    },
    pullVertices: function () {
      var cArState = this._cArState;
      var mArState = this._mArState;
      var idVertState = this._idVertState;
      var nbVerts = idVertState.length;

      var mesh = this._mesh;
      var cAr = mesh.getColors();
      var mAr = mesh.getMaterials();
      for (var i = 0; i < nbVerts; ++i) {
        var id = idVertState[i] * 3;
        var j = i * 3;
        cAr[id] = cArState[j];
        cAr[id + 1] = cArState[j + 1];
        cAr[id + 2] = cArState[j + 2];
        mAr[id] = mArState[j];
        mAr[id + 1] = mArState[j + 1];
        mAr[id + 2] = mArState[j + 2];
      }
    }
  };

  module.exports = StateColorAndMaterial;
});
define('states/StateGeometry',['require','exports','module','lib/glMatrix','misc/Utils'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Utils = require('misc/Utils');

  var vec3 = glm.vec3;

  var StateGeometry = function (main, mesh) {
    this._main = main; // main application
    this._mesh = mesh; // the mesh
    this._center = vec3.copy([0.0, 0.0, 0.0], mesh.getCenter());

    this._idVertState = []; // ids of vertices
    this._vArState = []; // copies of vertices coordinates
  };

  StateGeometry.prototype = {
    isNoop: function () {
      return this._idVertState.length === 0;
    },
    undo: function (skipUpdate) {
      this.pullVertices();
      if (skipUpdate) return;
      var mesh = this._mesh;
      mesh.updateGeometry(mesh.getFacesFromVertices(this._idVertState), this._idVertState);
      mesh.updateGeometryBuffers();
      vec3.copy(mesh.getCenter(), this._center);
      this._main.setMesh(mesh);
    },
    redo: function () {
      this.undo();
    },
    createRedo: function () {
      var redo = new StateGeometry(this._main, this._mesh);
      this.pushRedoVertices(redo);
      return redo;
    },
    pushVertices: function (iVerts) {
      var idVertState = this._idVertState;
      var vArState = this._vArState;

      var mesh = this._mesh;
      var vAr = mesh.getVertices();
      var vertStateFlags = mesh.getVerticesStateFlags();

      var stateFlag = Utils.STATE_FLAG;
      var nbVerts = iVerts.length;
      for (var i = 0; i < nbVerts; ++i) {
        var id = iVerts[i];
        if (vertStateFlags[id] === stateFlag)
          continue;
        vertStateFlags[id] = stateFlag;
        idVertState.push(id);
        id *= 3;
        vArState.push(vAr[id], vAr[id + 1], vAr[id + 2]);
      }
    },
    pushRedoVertices: function (redoState) {
      var mesh = redoState._mesh;
      var vAr = mesh.getVertices();

      var idVertUndoState = this._idVertState;
      var nbVerts = idVertUndoState.length;

      var vArRedoState = redoState._vArState = new Float32Array(nbVerts * 3);
      var idVertRedoState = redoState._idVertState = new Uint32Array(nbVerts);
      for (var i = 0; i < nbVerts; ++i) {
        var id = idVertRedoState[i] = idVertUndoState[i];
        id *= 3;
        var j = i * 3;
        vArRedoState[j] = vAr[id];
        vArRedoState[j + 1] = vAr[id + 1];
        vArRedoState[j + 2] = vAr[id + 2];
      }
    },
    pullVertices: function () {
      var vArState = this._vArState;
      var idVertState = this._idVertState;
      var nbVerts = idVertState.length;

      var mesh = this._mesh;
      var vAr = mesh.getVertices();
      for (var i = 0; i < nbVerts; ++i) {
        var id = idVertState[i] * 3;
        var j = i * 3;
        vAr[id] = vArState[j];
        vAr[id + 1] = vArState[j + 1];
        vAr[id + 2] = vArState[j + 2];
      }
    }
  };

  module.exports = StateGeometry;
});
define('states/StateDynamic',['require','exports','module','lib/glMatrix','misc/Utils'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Utils = require('misc/Utils');

  var vec3 = glm.vec3;

  var StateDynamic = function (main, mesh) {
    this._main = main; // main application
    this._mesh = mesh; // the mesh
    this._center = vec3.copy([0.0, 0.0, 0.0], mesh.getCenter());

    this._nbFacesState = mesh.getNbFaces(); // number of faces
    this._nbVerticesState = mesh.getNbVertices(); // number of vertices

    this._idVertState = []; // ids of vertices
    this._fRingState = []; // ring of faces around vertices
    this._vRingState = []; // ring of faces around vertices
    this._vArState = []; // copies of vertices coordinates
    this._cArState = []; // copies of color vertices
    this._mArState = []; // copies of material vertices

    this._idFaceState = []; // ids of faces
    this._fArState = []; // copies of face indices
  };

  StateDynamic.prototype = {
    isNoop: function () {
      return this._idVertState.length === 0 && this._idFaceState.length === 0;
    },
    undo: function (skipUpdate) {
      this.pullVertices();
      this.pullFaces();
      var mesh = this._mesh;
      // mesh.getVerticesRingFace().length = this._nbVerticesState;
      // mesh.getVerticesRingVert().length = this._nbVerticesState;
      mesh.setNbVertices(this._nbVerticesState);
      mesh.setNbFaces(this._nbFacesState);

      if (skipUpdate)
        return;
      mesh.updateGeometry( /*this._idFaceState, this._idVertState*/ ); // TODO local update ?
      mesh.updateTopology( /*this._idFaceState*/ ); // TODO local update ?
      mesh.updateDuplicateColorsAndMaterials();
      mesh.updateDrawArrays();
      mesh.updateColorBuffer();
      mesh.updateMaterialBuffer();
      mesh.updateBuffers();
      vec3.copy(mesh.getCenter(), this._center);
      this._main.setMesh(mesh);
    },
    redo: function () {
      this.undo();
    },
    createRedo: function () {
      var redo = new StateDynamic(this._main, this._mesh);
      this.pushRedoVertices(redo);
      this.pushRedoFaces(redo);
      return redo;
    },
    pushVertices: function (iVerts) {
      var idVertState = this._idVertState;
      var fRingState = this._fRingState;
      var vRingState = this._vRingState;
      var vArState = this._vArState;
      var cArState = this._cArState;
      var mArState = this._mArState;

      var mesh = this._mesh;
      var fRing = mesh.getVerticesRingFace();
      var vRing = mesh.getVerticesRingVert();
      var vAr = mesh.getVertices();
      var cAr = mesh.getColors();
      var mAr = mesh.getMaterials();
      var vStateFlags = mesh.getVerticesStateFlags();

      var stateFlag = Utils.STATE_FLAG;
      var nbVerts = iVerts.length;
      for (var i = 0; i < nbVerts; ++i) {
        var id = iVerts[i];
        if (vStateFlags[id] === stateFlag)
          continue;
        vStateFlags[id] = stateFlag;
        fRingState.push(fRing[id].slice());
        vRingState.push(vRing[id].slice());
        idVertState.push(id);
        id *= 3;
        vArState.push(vAr[id], vAr[id + 1], vAr[id + 2]);
        cArState.push(cAr[id], cAr[id + 1], cAr[id + 2]);
        mArState.push(mAr[id], mAr[id + 1], mAr[id + 2]);
      }
    },
    pushFaces: function (iFaces) {
      var idFaceState = this._idFaceState;
      var fArState = this._fArState;

      var mesh = this._mesh;
      var fAr = mesh.getFaces();
      var fStateFlags = mesh.getFacesStateFlags();

      var stateFlag = Utils.STATE_FLAG;
      var nbFaces = iFaces.length;
      for (var i = 0; i < nbFaces; ++i) {
        var id = iFaces[i];
        if (fStateFlags[id] === stateFlag)
          continue;
        fStateFlags[id] = stateFlag;
        idFaceState.push(id);
        id *= 4;
        fArState.push(fAr[id], fAr[id + 1], fAr[id + 2], fAr[id + 3]);
      }
    },
    pushRedoVertices: function (redoState) {
      var mesh = redoState._mesh;
      var nbMeshVertices = mesh.getNbVertices();
      var fRing = mesh.getVerticesRingFace();
      var vRing = mesh.getVerticesRingVert();
      var vAr = mesh.getVertices();
      var cAr = mesh.getColors();
      var mAr = mesh.getMaterials();

      var i = 0;
      var id = 0;
      var acc = 0;
      var idVertUndoState = this._idVertState;
      var nbVerts = idVertUndoState.length;
      var nbVerticesState = this._nbVerticesState;
      var nbMin = Math.min(nbVerticesState, nbMeshVertices);
      var idVertRedoState = new Uint32Array(Utils.getMemory(nbMeshVertices * 4), 0, nbMeshVertices);
      for (i = 0; i < nbVerts; ++i) {
        id = idVertUndoState[i];
        if (id < nbMin)
          idVertRedoState[acc++] = id;
      }
      for (i = nbVerticesState; i < nbMeshVertices; ++i) {
        idVertRedoState[acc++] = i;
      }

      nbVerts = acc;
      idVertRedoState = redoState._idVertState = new Uint32Array(idVertRedoState.subarray(0, nbVerts));
      var fRingRedoState = redoState._fRingState = new Array(nbVerts);
      var vRingRedoState = redoState._vRingState = new Array(nbVerts);
      var vArRedoState = redoState._vArState = new Float32Array(nbVerts * 3);
      var cArRedoState = redoState._cArState = new Float32Array(nbVerts * 3);
      var mArRedoState = redoState._mArState = new Float32Array(nbVerts * 3);
      for (i = 0; i < nbVerts; ++i) {
        id = idVertRedoState[i];
        fRingRedoState[i] = fRing[id].slice();
        vRingRedoState[i] = vRing[id].slice();
        id *= 3;
        var j = i * 3;
        vArRedoState[j] = vAr[id];
        vArRedoState[j + 1] = vAr[id + 1];
        vArRedoState[j + 2] = vAr[id + 2];
        cArRedoState[j] = cAr[id];
        cArRedoState[j + 1] = cAr[id + 1];
        cArRedoState[j + 2] = cAr[id + 2];
        mArRedoState[j] = mAr[id];
        mArRedoState[j + 1] = mAr[id + 1];
        mArRedoState[j + 2] = mAr[id + 2];
      }
    },
    pushRedoFaces: function (redoState) {
      var mesh = redoState._mesh;
      var nbMeshFaces = mesh.getNbFaces();
      var fAr = mesh.getFaces();

      var i = 0;
      var id = 0;
      var acc = 0;
      var idFaceUndoState = this._idFaceState;
      var nbFaces = idFaceUndoState.length;
      var nbFacesState = this._nbFacesState;
      var nbMin = Math.min(nbFacesState, nbMeshFaces);
      var idFaceRedoState = new Uint32Array(Utils.getMemory(nbMeshFaces * 4), 0, nbMeshFaces);
      for (i = 0; i < nbFaces; ++i) {
        id = idFaceUndoState[i];
        if (id < nbMin)
          idFaceRedoState[acc++] = id;
      }
      for (i = nbFacesState; i < nbMeshFaces; ++i) {
        idFaceRedoState[acc++] = i;
      }

      nbFaces = acc;
      idFaceRedoState = redoState._idFaceState = new Uint32Array(idFaceRedoState.subarray(0, nbFaces));
      var fArRedoState = redoState._fArState = new Int32Array(nbFaces * 4);
      for (i = 0; i < nbFaces; ++i) {
        id = idFaceRedoState[i];
        id *= 4;
        var j = i * 4;
        fArRedoState[j] = fAr[id];
        fArRedoState[j + 1] = fAr[id + 1];
        fArRedoState[j + 2] = fAr[id + 2];
        fArRedoState[j + 3] = fAr[id + 3];
      }
    },
    pullVertices: function () {
      var nbMeshVertices = this._nbVerticesState;
      var fRingState = this._fRingState;
      var vRingState = this._vRingState;
      var vArState = this._vArState;
      var cArState = this._cArState;
      var mArState = this._mArState;
      var idVertState = this._idVertState;
      var nbVerts = idVertState.length;

      var mesh = this._mesh;
      var fRing = mesh.getVerticesRingFace();
      var vRing = mesh.getVerticesRingVert();
      var vAr = mesh.getVertices();
      var cAr = mesh.getColors();
      var mAr = mesh.getMaterials();
      for (var i = 0; i < nbVerts; ++i) {
        var id = idVertState[i];
        if (id >= nbMeshVertices)
          continue;
        fRing[id] = fRingState[i].slice();
        vRing[id] = vRingState[i].slice();
        id *= 3;
        var j = i * 3;
        vAr[id] = vArState[j];
        vAr[id + 1] = vArState[j + 1];
        vAr[id + 2] = vArState[j + 2];
        cAr[id] = cArState[j];
        cAr[id + 1] = cArState[j + 1];
        cAr[id + 2] = cArState[j + 2];
        mAr[id] = mArState[j];
        mAr[id + 1] = mArState[j + 1];
        mAr[id + 2] = mArState[j + 2];
      }
    },
    pullFaces: function () {
      var nbMeshFaces = this._nbFacesState;
      var fArState = this._fArState;
      var idFaceState = this._idFaceState;
      var nbFaces = idFaceState.length;

      var mesh = this._mesh;
      var fAr = mesh.getFaces();
      for (var i = 0; i < nbFaces; ++i) {
        var id = idFaceState[i];
        if (id >= nbMeshFaces)
          continue;
        id *= 4;
        var j = i * 4;
        fAr[id] = fArState[j];
        fAr[id + 1] = fArState[j + 1];
        fAr[id + 2] = fArState[j + 2];
        fAr[id + 3] = fArState[j + 3];
      }
    }
  };

  module.exports = StateDynamic;
});
define('states/StateCustom',['require','exports','module'],function (require, exports, module) {

  'use strict';

  var StateCustom = function (undocb, redocb) {
    this._undocb = undocb;
    this._redocb = redocb ? redocb : undocb;
  };

  StateCustom.prototype = {
    isNoop: function () {
      return !this._undocb;
    },
    undo: function () {
      this._undocb();
    },
    redo: function () {
      this._redocb();
    },
    createRedo: function () {
      return new StateCustom(this._undocb, this._redocb);
    }
  };

  module.exports = StateCustom;
});
define('states/States',['require','exports','module','misc/Utils','states/StateAddRemove','states/StateColorAndMaterial','states/StateGeometry','states/StateDynamic','states/StateMultiresolution','states/StateCustom'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var StAddRemove = require('states/StateAddRemove');
  var StColorAndMaterial = require('states/StateColorAndMaterial');
  var StGeometry = require('states/StateGeometry');
  var StDynamic = require('states/StateDynamic');
  var StMultiresolution = require('states/StateMultiresolution');
  var StCustom = require('states/StateCustom');

  var States = function (main) {
    this._main = main; // main
    this._undos = []; // undo actions
    this._redos = []; // redo actions
    this._curUndoIndex = -1; // current index in undo
  };

  States.STACK_LENGTH = 15;

  States.prototype = {
    pushStateCustom: function (undocb, redocb, squash) {
      var st = new StCustom(undocb, redocb);
      st.squash = squash;
      this.pushState(st);
    },
    pushStateAddRemove: function (addMesh, remMesh, squash) {
      var st = new StAddRemove(this._main, addMesh, remMesh);
      st.squash = squash;
      this.pushState(st);
    },
    pushStateRemove: function (remMesh) {
      this.pushState(new StAddRemove(this._main, [], remMesh));
    },
    pushStateAdd: function (addMesh) {
      this.pushState(new StAddRemove(this._main, addMesh, []));
    },
    pushStateColorAndMaterial: function (mesh) {
      if (mesh.getDynamicTopology)
        this.pushState(new StDynamic(this._main, mesh));
      else
        this.pushState(new StColorAndMaterial(this._main, mesh));
    },
    pushStateGeometry: function (mesh) {
      if (mesh.getDynamicTopology)
        this.pushState(new StDynamic(this._main, mesh));
      else
        this.pushState(new StGeometry(this._main, mesh));
    },
    pushStateMultiresolution: function (multimesh, type) {
      this.pushState(new StMultiresolution(this._main, multimesh, type));
    },
    setNewMaxStack: function (maxStack) {
      States.STACK_LENGTH = maxStack;
      var undos = this._undos;
      var redos = this._redos;
      while (this._curUndoIndex >= maxStack) {
        undos.shift();
        --this._curUndoIndex;
      }
      while (undos.length > maxStack) {
        undos.pop();
        redos.shift();
      }
    },
    pushState: function (state) {
      ++Utils.STATE_FLAG;
      var undos = this._undos;
      if (this._curUndoIndex === -1) undos.length = 0;
      else if (undos.length >= States.STACK_LENGTH) {
        undos.shift();
        --this._curUndoIndex;
      }
      this._redos.length = 0;
      ++this._curUndoIndex;
      if (undos.length > 0)
        undos.length = this._curUndoIndex;
      undos.push(state);
    },
    getCurrentState: function () {
      return this._undos[this._curUndoIndex];
    },
    pushVertices: function (iVerts) {
      if (iVerts && iVerts.length > 0)
        this.getCurrentState().pushVertices(iVerts);
    },
    pushFaces: function (iFaces) {
      if (iFaces && iFaces.length > 0)
        this.getCurrentState().pushFaces(iFaces);
    },
    undo: function () {
      if (!this._undos.length || this._curUndoIndex < 0)
        return;

      var state = this.getCurrentState();
      var redoState = state.createRedo();
      redoState.squash = state.squash;
      this._redos.push(redoState);
      state.undo();

      this._curUndoIndex--;
      if (state.squash === true)
        this.undo();
    },
    redo: function () {
      if (!this._redos.length)
        return;

      var state = this._redos[this._redos.length - 1];
      state.redo();
      this._curUndoIndex++;
      this._redos.pop();
      if (state.squash === true)
        this.redo();
    },
    reset: function () {
      this._undos.length = 0;
      this._redos.length = 0;
      this._curUndoIndex = -1;
    },
    cleanNoop: function () {
      while (this._curUndoIndex >= 0 && this.getCurrentState().isNoop()) {
        this._undos.length--;
        this._curUndoIndex--;
        this._redos.length = 0;
      }
    },
  };

  module.exports = States;
});
define('gui/GuiStates',['require','exports','module','gui/GuiTR','states/States'],function (require, exports, module) {

  'use strict';

  var TR = require('gui/GuiTR');
  var States = require('states/States');

  var GuiTablet = function (guiParent, ctrlGui) {
    this._ctrlGui = ctrlGui; // main gui controller
    this._main = ctrlGui._main; // main application
    this._menu = null; // ui menu
    this.init(guiParent);
  };

  GuiTablet.prototype = {
    init: function (guiParent) {
      var menu = this._menu = guiParent.addMenu(TR('stateTitle'));
      menu.addButton(TR('stateUndo'), this, 'onUndo', 'CTRL+Z');
      menu.addButton(TR('stateRedo'), this, 'onRedo', 'CTRL+Y');
      menu.addTitle(TR('stateMaxStack'));
      var states = this._main.getStates();
      menu.addSlider('', States.STACK_LENGTH, states.setNewMaxStack.bind(states), 3, 50, 1);
    },
    onUndo: function () {
      this._main.getStates().undo();
      this._main.render();
      this._ctrlGui.updateMesh();
    },
    onRedo: function () {
      this._main.getStates().redo();
      this._main.render();
      this._ctrlGui.updateMesh();
    },
    ////////////////
    // KEY EVENTS
    ////////////////
    onKeyDown: function (event) {
      if (event.handled === true)
        return;

      event.stopPropagation();
      if (!this._main._focusGui)
        event.preventDefault();

      var key = event.which;
      if (event.ctrlKey && key === 90) { // z key
        this.onUndo();
        event.handled = true;
      } else if (event.ctrlKey && key === 89) { // y key
        this.onRedo();
        event.handled = true;
      }
    }
  };

  module.exports = GuiTablet;
});

define('gui/GuiTablet',['require','exports','module','gui/GuiTR','misc/Tablet'],function (require, exports, module) {

  'use strict';

  var TR = require('gui/GuiTR');
  var Tablet = require('misc/Tablet');

  var GuiTablet = function (guiParent) {
    this._menu = null; // ui menu
    this.init(guiParent);
  };

  GuiTablet.prototype = {
    /** Initialize */
    init: function (guiParent) {
      // Pen tablet ui stuffs
      var menu = this._menu = guiParent.addMenu(TR('wacomTitle'));
      menu.addCheckbox(TR('wacomRadius'), Tablet, 'useOnRadius');
      menu.addCheckbox(TR('wacomIntensity'), Tablet, 'useOnIntensity');
    }
  };

  module.exports = GuiTablet;
});
define('gui/Gui',['require','exports','module','lib/yagui','gui/GuiTR','gui/GuiBackground','gui/GuiCamera','gui/GuiConfig','gui/GuiFiles','gui/GuiMesh','gui/GuiTopology','gui/GuiRendering','gui/GuiScene','gui/GuiSculpting','gui/GuiStates','gui/GuiTablet','render/shaders/ShaderContour','misc/getOptionsURL'],function (require, exports, module) {

  'use strict';

  var yagui = require('lib/yagui');
  var TR = require('gui/GuiTR');
  var GuiBackground = require('gui/GuiBackground');
  var GuiCamera = require('gui/GuiCamera');
  var GuiConfig = require('gui/GuiConfig');
  var GuiFiles = require('gui/GuiFiles');
  var GuiMesh = require('gui/GuiMesh');
  var GuiTopology = require('gui/GuiTopology');
  var GuiRendering = require('gui/GuiRendering');
  var GuiScene = require('gui/GuiScene');
  var GuiSculpting = require('gui/GuiSculpting');
  var GuiStates = require('gui/GuiStates');
  var GuiTablet = require('gui/GuiTablet');
  var ShaderContour = require('render/shaders/ShaderContour');
  var getOptionsURL = require('misc/getOptionsURL');

  var Gui = function (main) {
    this._main = main;

    this._guiMain = null;
    this._sidebar = null;
    this._topbar = null;

    this._ctrlTablet = null;
    this._ctrlFiles = null;
    this._ctrlScene = null;
    this._ctrlStates = null;
    this._ctrlCamera = null;
    this._ctrlBackground = null;

    this._ctrlSculpting = null;
    this._ctrlTopology = null;
    this._ctrlRendering = null;

    this._ctrlNotification = null;

    this._ctrls = []; // list of controllers
  };

  Gui.prototype = {
    initGui: function () {
      this.deleteGui();

      this._guiMain = new yagui.GuiMain(this._main.getViewport(), this._main.onCanvasResize.bind(this._main));

      var ctrls = this._ctrls;
      ctrls.length = 0;
      var idc = 0;

      // Initialize the topbar
      this._topbar = this._guiMain.addTopbar();
      ctrls[idc++] = this._ctrlFiles = new GuiFiles(this._topbar, this);
      ctrls[idc++] = this._ctrlScene = new GuiScene(this._topbar, this);
      ctrls[idc++] = this._ctrlStates = new GuiStates(this._topbar, this);
      ctrls[idc++] = this._ctrlBackground = new GuiBackground(this._topbar, this);
      ctrls[idc++] = this._ctrlCamera = new GuiCamera(this._topbar, this);
      // TODO find a way to get pressure event
      if (getOptionsURL().wacom) ctrls[idc++] = this._ctrlTablet = new GuiTablet(this._topbar, this);
      ctrls[idc++] = this._ctrlConfig = new GuiConfig(this._topbar, this);
      ctrls[idc++] = this._ctrlMesh = new GuiMesh(this._topbar, this);

      // Initialize the sidebar
      this._sidebar = this._guiMain.addRightSidebar();
      ctrls[idc++] = this._ctrlRendering = new GuiRendering(this._sidebar, this);
      ctrls[idc++] = this._ctrlTopology = new GuiTopology(this._sidebar, this);
      ctrls[idc++] = this._ctrlSculpting = new GuiSculpting(this._sidebar, this);

      // gui extra
      // var extra = this._topbar.addExtra();
      // Extra : Настройка интерфейса
      // extra.addTitle(TR('contour'));
      // extra.addColor(TR('contourColor'), ShaderContour.color, this.onContourColor.bind(this));

      var extra = this._topbar.addMenu('Resolution');
      extra.addTitle('Ratio');
      extra.addSlider('', this._main._pixelRatio, this.onPixelRatio.bind(this), 0.1, 1.5, 0.02);

      this.addAboutButton();

      this.updateMesh();
      this.setVisibility(true);
    },
    onPixelRatio: function (val) {
      this._main._pixelRatio = val;
      this._main.onCanvasResize();
    },
    onContourColor: function (col) {
      ShaderContour.color[0] = col[0];
      ShaderContour.color[1] = col[1];
      ShaderContour.color[2] = col[2];
      ShaderContour.color[3] = col[3];
      this._main.render();
    },
    addAboutButton: function () {
      var ctrlAbout = this._topbar.addMenu();
      ctrlAbout.domContainer.innerHTML = TR('about');
      ctrlAbout.domContainer.addEventListener('mousedown', function () {
        window.open('http://stephaneginier.com', '_blank');
      });
    },
    getWidgetNotification: function () {
      if (!this._ctrlNotification) {
        this._ctrlNotification = this._topbar.addMenu();
        this._ctrlNotification.setVisibility(false);
      }
      return this._ctrlNotification;
    },
    updateMesh: function () {
      this._ctrlRendering.updateMesh();
      this._ctrlTopology.updateMesh();
      this._ctrlSculpting.updateMesh();
      this._ctrlScene.updateMesh();
      this.updateMeshInfo();
    },
    updateMeshInfo: function () {
      this._ctrlMesh.updateMeshInfo();
    },
    getFlatShading: function () {
      return this._ctrlRendering.getFlatShading();
    },
    getWireframe: function () {
      return this._ctrlRendering.getWireframe();
    },
    getShaderName: function () {
      return this._ctrlRendering.getShaderName();
    },
    addAlphaOptions: function (opts) {
      this._ctrlSculpting.addAlphaOptions(opts);
    },
    deleteGui: function () {
      if (!this._guiMain || !this._guiMain.domMain.parentNode)
        return;
      this.callFunc('removeEvents');
      this.setVisibility(false);
      this._guiMain.domMain.parentNode.removeChild(this._guiMain.domMain);
    },
    setVisibility: function (bool) {
      this._guiMain.setVisibility(bool);
    },
    callFunc: function (func, event) {
      for (var i = 0, ctrls = this._ctrls, nb = ctrls.length; i < nb; ++i) {
        var ct = ctrls[i];
        if (ct && ct[func]) {
          ct[func](event);
	  	}
      }
    }
  };

  module.exports = Gui;
});

define('math3d/Camera',['require','exports','module','lib/glMatrix','misc/getOptionsURL','misc/Utils','math3d/Geometry'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var getOptionsURL = require('misc/getOptionsURL');
  var Utils = require('misc/Utils');
  var Geometry = require('math3d/Geometry');

  var vec2 = glm.vec2;
  var vec3 = glm.vec3;
  var mat3 = glm.mat3;
  var mat4 = glm.mat4;
  var quat = glm.quat;

  var easeOutQuart = function (r) {
    r = Math.min(1.0, r) - 1.0;
    return -(r * r * r * r - 1.0);
  };

  var DELAY_SNAP = 200;
  var DELAY_ROTATE = -1;
  var DELAY_TRANSLATE = -1;
  var DELAY_MOVE_TO = 200;

  var Camera = function (main) {
    this._main = main;

    var opts = getOptionsURL();
    this._mode = opts.cameramode || 'ORBIT'; // SPHERICAL / PLANE
    this._projectionType = opts.projection || 'PERSPECTIVE'; // ORTHOGRAPHIC

    this._quatRot = [0.0, 0.0, 0.0, 1.0]; // quaternion rotation
    this._view = mat4.create(); // view matrix
    this._proj = mat4.create(); // projection matrix
    this._viewport = mat4.create(); // viewport matrix

    this._lastNormalizedMouseXY = [0.0, 0.0]; // last mouse position ( 0..1 )
    this._width = 0.0; // viewport width
    this._height = 0.0; // viewport height

    this._speed = 0.0; // solve scale issue
    this._fov = Math.min(opts.fov, 150); // vertical field of view

    // translation stuffs
    this._trans = [0.0, 0.0, 30.0];
    this._moveX = 0; // free look (strafe), possible values : -1, 0, 1
    this._moveZ = 0; // free look (strafe), possible values : -1, 0, 1

    // pivot stuffs
    this._usePivot = opts.pivot; // if rotation is centered around the picked point
    this._center = [0.0, 0.0, 0.0]; // center of rotation
    this._offset = [0.0, 0.0, 0.0];

    // orbit camera
    this._rotX = 0.0; // x rot for orbit camera
    this._rotY = 0.0; // y rot for orbit camera

    // near far
    this._near = 0.05;
    this._far = 5000.0;

    this._timers = {}; // animation timers

    this.resetView();
  };

  Camera.prototype = {
    setProjectionType: function (type) {
      this._projectionType = type;
      this.updateProjection();
      this.updateView();
    },
    setMode: function (mode) {
      this._mode = mode;
      if (mode === 'ORBIT')
        this.resetViewFront();
    },
    setFov: function (fov) {
      this._fov = fov;
      this.updateView();
      this.optimizeNearFar();
    },
    setUsePivot: function (bool) {
      this._usePivot = bool;
    },
    toggleUsePivot: function () {
      this._usePivot = !this._usePivot;
    },
    getView: function () {
      return this._view;
    },
    getProjection: function () {
      return this._proj;
    },
    getProjectionType: function () {
      return this._projectionType;
    },
    isOrthographic: function () {
      return this._projectionType === 'ORTHOGRAPHIC';
    },
    getMode: function () {
      return this._mode;
    },
    getFov: function () {
      return this._fov;
    },
    getUsePivot: function () {
      return this._usePivot;
    },
    getConstantScreen: function () {
      if (this._projectionType === 'ORTHOGRAPHIC')
        return 1.0 / this.getOrthoZoom();
      return Math.min(this._proj[0], this._proj[5] * 0.5);
    },
    start: (function () {
      var pivot = [0.0, 0.0, 0.0];
      return function (mouseX, mouseY) {
        this._lastNormalizedMouseXY = Geometry.normalizedMouse(mouseX, mouseY, this._width, this._height);
        if (!this._usePivot)
          return;
        var main = this._main;
        var picking = main.getPicking();
        picking.intersectionMouseMeshes(main.getMeshes(), mouseX, mouseY);
        if (picking.getMesh()) {
          vec3.transformMat4(pivot, picking.getIntersectionPoint(), picking.getMesh().getMatrix());
          this.setPivot(pivot);
        }
      };
    })(),
    setPivot: (function () {
      var qTmp = [0.0, 0.0, 0.0, 1.0];
      return function (pivot) {
        vec3.transformQuat(this._offset, this._offset, quat.invert(qTmp, this._quatRot));
        vec3.sub(this._offset, this._offset, this._center);

        // set new pivot
        vec3.copy(this._center, pivot);
        vec3.add(this._offset, this._offset, this._center);
        vec3.transformQuat(this._offset, this._offset, this._quatRot);

        // adjust zoom
        if (this._projectionType === 'PERSPECTIVE') {
          var oldZoom = this.getTransZ();
          this._trans[2] = vec3.dist(this.computePosition(), this._center) * this._fov / 45;
          this._offset[2] += this.getTransZ() - oldZoom;
        } else {
          this._offset[2] = 0.0;
        }
      };
    })(),
    /** Compute rotation values (by updating the quaternion) */
    rotate: (function () {
      var diff = [0.0, 0.0];
      var axisRot = [0.0, 0.0, 0.0];
      var quatTmp = [0.0, 0.0, 0.0, 0.0];

      return function (mouseX, mouseY) {

        var normalizedMouseXY = Geometry.normalizedMouse(mouseX, mouseY, this._width, this._height);
        if (this._mode === 'ORBIT') {
          vec2.sub(diff, normalizedMouseXY, this._lastNormalizedMouseXY);
          this.setOrbit(this._rotX - diff[1] * 2, this._rotY + diff[0] * 2);

          this.rotateDelay([-diff[1] * 6, diff[0] * 6], DELAY_ROTATE);
        } else if (this._mode === 'PLANE') {
          var length = vec2.dist(this._lastNormalizedMouseXY, normalizedMouseXY);
          vec2.sub(diff, normalizedMouseXY, this._lastNormalizedMouseXY);
          vec3.normalize(axisRot, vec3.set(axisRot, -diff[1], diff[0], 0.0));
          quat.mul(this._quatRot, quat.setAxisAngle(quatTmp, axisRot, length * 2.0), this._quatRot);

          this.rotateDelay([axisRot[0], axisRot[1], axisRot[2], length * 6], DELAY_ROTATE);
        } else if (this._mode === 'SPHERICAL') {
          var mouseOnSphereBefore = Geometry.mouseOnUnitSphere(this._lastNormalizedMouseXY);
          var mouseOnSphereAfter = Geometry.mouseOnUnitSphere(normalizedMouseXY);
          var angle = Math.acos(Math.min(1.0, vec3.dot(mouseOnSphereBefore, mouseOnSphereAfter)));
          vec3.normalize(axisRot, vec3.cross(axisRot, mouseOnSphereBefore, mouseOnSphereAfter));
          quat.mul(this._quatRot, quat.setAxisAngle(quatTmp, axisRot, angle * 2.0), this._quatRot);

          this.rotateDelay([axisRot[0], axisRot[1], axisRot[2], angle * 6], DELAY_ROTATE);
        }
        this._lastNormalizedMouseXY = normalizedMouseXY;
        this.updateView();
      };
    })(),
    setOrbit: function (rx, ry) {
      var radLimit = Math.PI * 0.49;
      this._rotX = Math.max(Math.min(rx, radLimit), -radLimit);
      this._rotY = ry;
      var qrt = this._quatRot;
      quat.identity(qrt);
      quat.rotateX(qrt, qrt, this._rotX);
      quat.rotateY(qrt, qrt, this._rotY);
    },
    getTransZ: function () {
      return this._projectionType === 'PERSPECTIVE' ? this._trans[2] * 45 / this._fov : 1000.0;
    },
    updateView: (function () {
      var up = [0.0, 1.0, 0.0];
      var eye = [0.0, 0.0, 0.0];
      var center = [0.0, 0.0, 0.0];
      var matTmp = mat4.create();
      var vecTmp = [0.0, 0.0, 0.0];

      return function () {
        var view = this._view;
        var tx = this._trans[0];
        var ty = this._trans[1];

        var off = this._offset;
        vec3.set(eye, tx - off[0], ty - off[1], this.getTransZ() - off[2]);
        vec3.set(center, tx - off[0], ty - off[1], -off[2]);
        mat4.lookAt(view, eye, center, up);

        mat4.mul(view, view, mat4.fromQuat(matTmp, this._quatRot));
        mat4.translate(view, view, vec3.negate(vecTmp, this._center));

		window.viewmat = view;
      };
    })(),
    optimizeNearFar: (function () {
      var eye = [0.0, 0.0, 0.0];
      var tmp = [0.0, 0.0, 0.0];
      return function (bb) {
        if (!bb) bb = this._lastBBox;
        if (!bb) return;
        this._lastBBox = bb;
        vec3.set(eye, this._trans[0], this._trans[1], this.getTransZ());
        var diag = vec3.dist(bb, vec3.set(tmp, bb[3], bb[4], bb[5]));
        var dist = vec3.dist(eye, vec3.set(tmp, (bb[0] + bb[3]) * 0.5, (bb[1] + bb[4]) * 0.5, (bb[2] + bb[5]) * 0.5));
        this._near = Math.max(0.01, dist - diag);
        this._far = diag + dist;
        this.updateProjection();
      };
    })(),
    updateProjection: function () {
      if (this._projectionType === 'PERSPECTIVE') {
        mat4.perspective(this._proj, this._fov * Math.PI / 180.0, this._width / this._height, this._near, this._far);
        this._proj[10] = -1.0;
        this._proj[14] = -2 * this._near;
      } else {
        this.updateOrtho();
      }
    },
    updateTranslation: function () {
      var trans = this._trans;
      trans[0] += this._moveX * this._speed * trans[2] / 50 / 400.0;
      trans[2] = Math.max(0.00001, trans[2] + this._moveZ * this._speed / 400.0);
      if (this._projectionType === 'ORTHOGRAPHIC')
        this.updateOrtho();
      this.updateView();
    },
    translate: function (dx, dy) {
      var factor = this._speed * this._trans[2] / 54;
      var delta = [-dx * factor, dy * factor, 0.0];
      this.setTrans(vec3.add(this._trans, this._trans, delta));

      vec3.scale(delta, delta, 5);
      this.translateDelay(delta, DELAY_TRANSLATE);
    },
    zoom: function (df) {
      var delta = [0.0, 0.0, 0.0];
      vec3.sub(delta, this._offset, this._trans);
      vec3.scale(delta, delta, df * this._speed / 54);
      if (df < 0.0)
        delta[0] = delta[1] = 0.0;
      this.setTrans(vec3.add(this._trans, this._trans, delta));

      vec3.scale(delta, delta, 5);
      this.translateDelay(delta, DELAY_TRANSLATE);
    },
    setAndFocusOnPivot: function (pivot, zoom) {
      this.setPivot(pivot);
      this.moveToDelay(this._offset[0], this._offset[1], this._offset[2] + zoom);
    },
    moveToDelay: function (x, y, z) {
      var delta = [x, y, z];
      this.translateDelay(vec3.sub(delta, delta, this._trans), DELAY_MOVE_TO);
    },
    setTrans: function (trans) {
      vec3.copy(this._trans, trans);
      if (this._projectionType === 'ORTHOGRAPHIC')
        this.updateOrtho();
      this.updateView();
    },
    getOrthoZoom: function () {
      return Math.abs(this._trans[2]) * 0.00055;
    },
    updateOrtho: function () {
      var delta = this.getOrthoZoom();
      var w = this._width * delta;
      var h = this._height * delta;
      mat4.ortho(this._proj, -w, w, -h, h, -this._near, this._far);
    },
    computePosition: function () {
      var view = this._view;
      var pos = [-view[12], -view[13], -view[14]];
      var rot = mat3.create();
      mat3.fromMat4(rot, view);
      return vec3.transformMat3(pos, pos, mat3.transpose(rot, rot));
    },
    resetView: function () {
      this._speed = Utils.SCALE * 0.9;
      this.centerDelay([0.0, 0.0, 0.0], DELAY_MOVE_TO);
      this.offsetDelay([0.0, 0.0, 0.0], DELAY_MOVE_TO);
      var delta = [0.0, 0.0, 3.0 + this._speed / 30.0];
      vec3.sub(delta, delta, this._trans);
      this.translateDelay(delta, DELAY_MOVE_TO);
      this.quatDelay([0.0, 0.0, 0.0, 1.0], DELAY_MOVE_TO);
    },
    resetViewFront: function () {
      this.quatDelay([0.0, 0.0, 0.0, 1.0], DELAY_SNAP);
    },
    resetViewBack: function () {
      this.quatDelay([0.0, 1.0, 0.0, 0.0], DELAY_SNAP);
    },
    resetViewTop: function () {
      this.quatDelay([Math.SQRT1_2, 0.0, 0.0, Math.SQRT1_2], DELAY_SNAP);
    },
    resetViewBottom: function () {
      this.quatDelay([-Math.SQRT1_2, 0.0, 0.0, Math.SQRT1_2], DELAY_SNAP);
    },
    resetViewLeft: function () {
      this.quatDelay([0.0, -Math.SQRT1_2, 0.0, Math.SQRT1_2], DELAY_SNAP);
    },
    resetViewRight: function () {
      this.quatDelay([0.0, Math.SQRT1_2, 0.0, Math.SQRT1_2], DELAY_SNAP);
    },
    toggleViewFront: function () {
      if (Math.abs(this._quatRot[3]) > 0.99) this.resetViewBack();
      else this.resetViewFront();
    },
    toggleViewTop: function () {
      var dot = this._quatRot[0] * Math.SQRT1_2 + this._quatRot[3] * Math.SQRT1_2;
      if (dot * dot > 0.99) this.resetViewBottom();
      else this.resetViewTop();
    },
    toggleViewLeft: function () {
      var dot = -this._quatRot[1] * Math.SQRT1_2 + this._quatRot[3] * Math.SQRT1_2;
      if (dot * dot > 0.99) this.resetViewRight();
      else this.resetViewLeft();
    },
    computeWorldToScreenMatrix: function (mat) {
      mat = mat || mat4.create();
      return mat4.mul(mat, mat4.mul(mat, this._viewport, this._proj), this._view);
    },
    /** Project the mouse coordinate into the world coordinate at a given z */
    unproject: (function () {
      var mat = mat4.create();
      return function (mouseX, mouseY, z) {
        var out = [0.0, 0.0, 0.0];
        mat4.invert(mat, this.computeWorldToScreenMatrix(mat));
        return vec3.transformMat4(out, vec3.set(out, mouseX, this._height - mouseY, z), mat);
      };
    })(),
    /** Project a vertex onto the screen */
    project: (function () {
      var mat = mat4.create();
      return function (vector) {
        var out = [0.0, 0.0, 0.0];
        vec3.transformMat4(out, vector, this.computeWorldToScreenMatrix(mat));
        out[1] = this._height - out[1];
        return out;
      };
    })(),
    onResize: (function () {
      var tmp = [0.0, 0.0, 0.0];
      return function (width, height) {
        this._width = width;
        this._height = height;

        var vp = this._viewport;
        mat4.identity(vp);
        mat4.scale(vp, vp, vec3.set(tmp, 0.5 * width, 0.5 * height, 0.5));
        mat4.translate(vp, vp, vec3.set(tmp, 1.0, 1.0, 1.0));

        this.updateProjection();
      };
    })(),
    snapClosestRotation: (function () {
      var sq = Math.SQRT1_2;
      var d = 0.5;
      var qComp = [
        quat.fromValues(1, 0, 0, 0),
        quat.fromValues(0, 1, 0, 0),
        quat.fromValues(0, 0, 1, 0),
        quat.fromValues(0, 0, 0, 1),
        quat.fromValues(sq, sq, 0, 0),
        quat.fromValues(sq, -sq, 0, 0),
        quat.fromValues(sq, 0, sq, 0),
        quat.fromValues(sq, 0, -sq, 0),
        quat.fromValues(sq, 0, 0, sq),
        quat.fromValues(sq, 0, 0, -sq),
        quat.fromValues(0, sq, sq, 0),
        quat.fromValues(0, sq, -sq, 0),
        quat.fromValues(0, sq, 0, sq),
        quat.fromValues(0, sq, 0, -sq),
        quat.fromValues(0, 0, sq, sq),
        quat.fromValues(0, 0, sq, -sq),
        quat.fromValues(d, d, d, d),
        quat.fromValues(d, d, d, -d),
        quat.fromValues(d, d, -d, d),
        quat.fromValues(d, d, -d, -d),
        quat.fromValues(d, -d, d, d),
        quat.fromValues(d, -d, d, -d),
        quat.fromValues(d, -d, -d, d),
        quat.fromValues(-d, d, d, d),
      ];
      var nbQComp = qComp.length;
      return function () {
        var qrot = this._quatRot;
        var min = Infinity;
        var id = 0;
        for (var i = 0; i < nbQComp; ++i) {
          var dot = quat.dot(qrot, qComp[i]);
          dot = 1 - dot * dot;
          if (min < dot)
            continue;
          min = dot;
          id = i;
        }
        this.quatDelay(qComp[id], DELAY_SNAP);
      };
    })(),
    clearTimerN: function (n) {
      window.clearInterval(this._timers[n]);
      this._timers[n] = 0;
    },
    delay: function (cb, duration, name) {
      var nTimer = name || 'default';
      if (this._timers[nTimer])
        this.clearTimerN(nTimer);

      if (duration === 0.0)
        return cb(1.0);
      else if (duration < 0.0)
        return;

      var lastR = 0;
      var tStart = (new Date()).getTime();
      this._timers[nTimer] = window.setInterval(function () {
        var r = ((new Date()).getTime() - tStart) / duration;
        r = easeOutQuart(r);
        cb(r - lastR, r);
        lastR = r;
        if (r >= 1.0)
          this.clearTimerN(nTimer);
      }.bind(this), 16.6);
    },
    _translateDelta: function (delta, dr) {
      var trans = this._trans;
      vec3.scaleAndAdd(trans, trans, delta, dr);
      this.setTrans(trans);
      this._main.render();
    },
    translateDelay: function (delta, duration) {
      var cb = this._translateDelta.bind(this, delta);
      this.delay(cb, duration, 'translate');
    },
    _rotDelta: (function () {
      var qTmp = [0.0, 0.0, 0.0, 0.0];
      return function (delta, dr) {
        if (this._mode === 'ORBIT') {
          var rx = this._rotX + delta[0] * dr;
          var ry = this._rotY + delta[1] * dr;
          this.setOrbit(rx, ry);
        } else {
          quat.mul(this._quatRot, quat.setAxisAngle(qTmp, delta, delta[3] * dr), this._quatRot);
        }
        this.updateView();
        this._main.render();
      };
    })(),
    rotateDelay: function (delta, duration) {
      var cb = this._rotDelta.bind(this, delta);
      this.delay(cb, duration, 'rotate');
    },
    _quatDelta: (function () {
      var qr = [0.0, 0.0, 0.0, 0.0];
      return function (qDelta, dr) {
        quat.identity(qr);
        quat.slerp(qr, qr, qDelta, dr);
        var qrt = this._quatRot;
        quat.mul(this._quatRot, this._quatRot, qr);

        if (this._mode === 'ORBIT') {
          var qx = qrt[0];
          var qy = qrt[1];
          var qz = qrt[2];
          var qw = qrt[3];
          // find back euler values
          this._rotY = Math.atan2(2 * (qw * qy + qz * qx), 1 - 2 * (qy * qy + qz * qz));
          this._rotX = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qz * qz + qx * qx));
        }

        this.updateView();
        this._main.render();
      };
    })(),
    quatDelay: function (target, duration) {
      var qDelta = [0.0, 0.0, 0.0, 0.0];
      quat.conjugate(qDelta, this._quatRot);
      quat.mul(qDelta, qDelta, target);
      quat.normalize(qDelta, qDelta);

      var cb = this._quatDelta.bind(this, qDelta);
      this.delay(cb, duration, 'quat');
    },
    _centerDelta: function (delta, dr) {
      vec3.scaleAndAdd(this._center, this._center, delta, dr);
      this.updateView();
      this._main.render();
    },
    centerDelay: function (target, duration) {
      var delta = [0.0, 0.0, 0.0];
      vec3.sub(delta, target, this._center);
      var cb = this._centerDelta.bind(this, delta);
      this.delay(cb, duration, 'center');
    },
    _offsetDelta: function (delta, dr) {
      vec3.scaleAndAdd(this._offset, this._offset, delta, dr);
      this.updateView();
      this._main.render();
    },
    offsetDelay: function (target, duration) {
      var delta = [0.0, 0.0, 0.0];
      vec3.sub(delta, target, this._offset);
      var cb = this._offsetDelta.bind(this, delta);
      this.delay(cb, duration, 'offset');
    },
    computeFrustumFit: function () {
      var near = this._near;

      if (this._projectionType === 'ORTHOGRAPHIC') {
        return 1.0 / Math.sin(Math.atan2(Math.min(this._width, this._height) / near * 0.5, 1));
      }

      var proj = this._proj;
      var left = near * (proj[8] - 1.0) / proj[0];
      var right = near * (1.0 + proj[8]) / proj[0];
      var top = near * (1.0 + proj[9]) / proj[5];
      var bottom = near * (proj[9] - 1.0) / proj[5];
      var vertical2 = Math.abs(right - left);
      var horizontal2 = Math.abs(top - bottom);

      return (this._fov / 45.0) / Math.sin(Math.atan2(Math.min(horizontal2, vertical2) / near * 0.5, 1));
    }
  };

  module.exports = Camera;
});

define('drawables/Background',['require','exports','module','render/Buffer','render/ShaderLib'],function (require, exports, module) {

  'use strict';

  var Buffer = require('render/Buffer');
  var Shader = require('render/ShaderLib');

  var Background = function (gl, main) {
    this._main = main;
    this._gl = gl; // webgl context

    this._vertexBuffer = new Buffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW); // vertices buffer
    this._texCoordBuffer = new Buffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW); // tex coord buffer
    this._fill = true; // if the canvas should be fille by the background

    this._monoTex = null;
    this._texture = null; // texture background
    this._texWidth = 1;
    this._texHeight = 1;

    this.init();
  };

  Background.prototype = {
    init: function () {
      this.getTexCoordBuffer().update(new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0]));
      this._monoTex = this.createOnePixelTexture(50, 50, 50, 255);
      document.getElementById('backgroundopen').addEventListener('change', this.loadBackground.bind(this), false);
    },
    loadBackground: function (event) {
      if (event.target.files.length === 0)
        return;

      var file = event.target.files[0];
      if (!file.type.match('image.*'))
        return;

      var self = this;
      var reader = new FileReader();
      reader.onload = function (evt) {
        var bg = new Image();
        bg.src = evt.target.result;

        bg.onload = function () {

          var canvas = self._main.getCanvas();
          self.loadBackgroundTexture(bg);
          self.onResize(canvas.width, canvas.height);
          self._main.render();
        };
      };

      document.getElementById('backgroundopen').value = '';
      reader.readAsDataURL(file);
    },
    getGL: function () {
      return this._gl;
    },
    getVertexBuffer: function () {
      return this._vertexBuffer;
    },
    getTexCoordBuffer: function () {
      return this._texCoordBuffer;
    },
    release: function () {
      this.deleteTexture();
      this.getVertexBuffer().release();
      this.getTexCoordBuffer().release();
    },
    onResize: function (width, height) {
      var ratio = (width / height) / (this._texWidth / this._texHeight);
      var comp = this._fill ? 1.0 / ratio : ratio;
      var x = comp < 1.0 ? 1.0 : 1.0 / ratio;
      var y = comp < 1.0 ? ratio : 1.0;
      this.getVertexBuffer().update(new Float32Array([-x, -y, x, -y, -x, y, x, y]));
    },
    getTexture: function () {
      return this._texture ? this._texture : this._monoTex;
    },
    createOnePixelTexture: function (r, g, b, a) {
      var gl = this._gl;
      var tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([r, g, b, a]));
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return tex;
    },
    loadBackgroundTexture: function (tex) {
      var gl = this._gl;
      this.deleteTexture();

      this._texWidth = tex.width;
      this._texHeight = tex.height;
      this._texture = gl.createTexture();

      gl.bindTexture(gl.TEXTURE_2D, this._texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
    },
    deleteTexture: function () {
      if (this._texture) {
        this._texWidth = this._texHeight = 1;
        this._gl.deleteTexture(this._texture);
        this._texture = null;
      }
    },
    render: function () {
      Shader.BACKGROUND.getOrCreate(this._gl).draw(this);
    }
  };

  module.exports = Background;
});

define('drawables/Selection',['require','exports','module','lib/glMatrix','render/Buffer','render/ShaderLib'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Buffer = require('render/Buffer');
  var Shader = require('render/ShaderLib');

  var mat3 = glm.mat3;
  var mat4 = glm.mat4;
  var vec3 = glm.vec3;

  var Selection = function (gl) {
    this._gl = gl;

    this._circleBuffer = new Buffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
    this._dotBuffer = new Buffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW);

    this._cacheDotMVP = mat4.create();
    this._cacheDotSymMVP = mat4.create();
    this._cacheCircleMVP = mat4.create();
    this._color = new Float32Array([0.8, 0.0, 0.0]);

    this._offsetX = 0.0; // horizontal offset (when editing the radius)

    this.init();
  };

  var DOT_RADIUS = 50.0; // in pixels

  Selection.prototype = {
    getGL: function () {
      return this._gl;
    },
    getCircleBuffer: function () {
      return this._circleBuffer;
    },
    getDotBuffer: function () {
      return this._dotBuffer;
    },
    getCircleMVP: function () {
      return this._cacheCircleMVP;
    },
    getDotMVP: function () {
      return this._cacheDotMVP;
    },
    getDotSymmetryMVP: function () {
      return this._cacheDotSymMVP;
    },
    getColor: function () {
      return this._color;
    },
    setOffsetX: function (offset) {
      this._offsetX = offset;
    },
    getOffsetX: function () {
      return this._offsetX;
    },
    init: function () {
      this.getCircleBuffer().update(this._getCircleVertices(1.0));
      this.getDotBuffer().update(this._getDotVertices(0.05, 10));
    },
    release: function () {
      this.getCircleBuffer().release();
      this.getDotBuffer().release();
    },
    _getCircleVertices: function (r, nb, full) {
      var nbVertices = nb || 50;
      var radius = r || 1.0;
      var arc = Math.PI * 2;

      var start = full ? 1 : 0;
      var end = full ? nbVertices + 2 : nbVertices;
      var vertices = new Float32Array(end * 3);
      for (var i = start; i < end; ++i) {
        var j = i * 3;
        var segment = (arc * i) / nbVertices;
        vertices[j] = Math.cos(segment) * radius;
        vertices[j + 1] = Math.sin(segment) * radius;
      }
      return vertices;
    },
    _getDotVertices: function (r, nb) {
      return this._getCircleVertices(r, nb, true);
    },
    _updateMatricesBackground: (function () {

      var matPV = mat4.create();
      var tmpMat = mat4.create();
      var tra = [0.0, 0.0, 0.0];

      return function (camera, main) {

        var screenRadius = main.getSculpt().getCurrentTool().getScreenRadius();

        var w = camera._width * 0.5;
        var h = camera._height * 0.5;
        // no need to recompute the ortho proj each time though
        mat4.ortho(matPV, -w, w, -h, h, -10.0, 10.0);

        mat4.identity(tmpMat);
        mat4.translate(tmpMat, tmpMat, vec3.set(tra, -w + main._mouseX + this._offsetX, h - main._mouseY, 0.0));
        // circle mvp
        mat4.scale(this._cacheCircleMVP, tmpMat, vec3.set(tra, screenRadius, screenRadius, screenRadius));
        mat4.mul(this._cacheCircleMVP, matPV, this._cacheCircleMVP);
        // dot mvp
        mat4.scale(this._cacheDotMVP, tmpMat, vec3.set(tra, DOT_RADIUS, DOT_RADIUS, DOT_RADIUS));
        mat4.mul(this._cacheDotMVP, matPV, this._cacheDotMVP);
        // symmetry mvp
        mat4.scale(this._cacheDotSymMVP, this._cacheDotSymMVP, [0.0, 0.0, 0.0]);
      };

    })(),
    _updateMatricesMesh: (function () {

      var matPV = mat4.create();
      var tmpMat = mat4.create();
      var base = [0.0, 0.0, 1.0];
      var axis = [0.0, 0.0, 0.0];
      var tra = [0.0, 0.0, 0.0];

      return function (camera, main) {

        var picking = main.getPicking();
        var pickingSym = main.getPickingSymmetry();
        var worldRadius = Math.sqrt(picking.computeWorldRadius2(true));
        var screenRadius = main.getSculpt().getCurrentTool().getScreenRadius();

        var mesh = picking.getMesh();
        var constRadius = DOT_RADIUS * (worldRadius / screenRadius);

        picking.polyLerp(mesh.getNormals(), axis);
        vec3.transformMat3(axis, axis, mat3.normalFromMat4(tmpMat, mesh.getMatrix()));
        vec3.normalize(axis, axis);
        var rad = Math.acos(vec3.dot(base, axis));
        vec3.cross(axis, base, axis);

        mat4.identity(tmpMat);
        mat4.translate(tmpMat, tmpMat, vec3.transformMat4(tra, picking.getIntersectionPoint(), mesh.getMatrix()));
        mat4.rotate(tmpMat, tmpMat, rad, axis);

        mat4.mul(matPV, camera.getProjection(), camera.getView());

        // circle mvp
        mat4.scale(this._cacheCircleMVP, tmpMat, vec3.set(tra, worldRadius, worldRadius, worldRadius));
        mat4.mul(this._cacheCircleMVP, matPV, this._cacheCircleMVP);
        // dot mvp
        mat4.scale(this._cacheDotMVP, tmpMat, vec3.set(tra, constRadius, constRadius, constRadius));
        mat4.mul(this._cacheDotMVP, matPV, this._cacheDotMVP);
        // symmetry mvp
        vec3.transformMat4(tra, pickingSym.getIntersectionPoint(), mesh.getMatrix());
        mat4.identity(tmpMat);
        mat4.translate(tmpMat, tmpMat, tra);
        mat4.rotate(tmpMat, tmpMat, rad, axis);

        mat4.scale(tmpMat, tmpMat, vec3.set(tra, constRadius, constRadius, constRadius));
        mat4.mul(this._cacheDotSymMVP, matPV, tmpMat);
      };
    })(),
    render: function (main) {
      if (main.getSculpt().getToolName() === 'TRANSFORM')
        return;

      // if there's an offset then it means we are editing the tool radius
      var pickedMesh = main.getPicking().getMesh() && this._offsetX === 0.0;
      if (pickedMesh) this._updateMatricesMesh(main.getCamera(), main);
      else this._updateMatricesBackground(main.getCamera(), main);

      var drawCircle = main._action === 'NOTHING';
      vec3.set(this._color, 0.8, drawCircle && pickedMesh ? 0.0 : 0.4, 0.0);
      Shader.SELECTION.getOrCreate(this._gl).draw(this, drawCircle, main.getSculpt().getSymmetry());
    }
  };

  module.exports = Selection;
});
define('render/WebGLCaps',['require','exports','module'],function (require, exports, module) {

  'use strict';

  // see osgjs WebGLCaps
  var WebGLCaps = {};
  WebGLCaps._gl = null;
  WebGLCaps._checkRTT = {};
  WebGLCaps._webGLExtensions = {};

  WebGLCaps.HALF_FLOAT = WebGLCaps.HALF_FLOAT_OES = 0x8D61;

  WebGLCaps.checkRTTSupport = function (typeFloat, typeTexture) {
    var gl = WebGLCaps._gl;
    if (gl === undefined)
      return false;
    var key = typeFloat + ',' + typeTexture;
    if (WebGLCaps._checkRTT[key] !== undefined)
      return WebGLCaps._checkRTT[key];
    // from http://codeflow.org/entries/2013/feb/22/how-to-write-portable-webgl/#how-can-i-detect-if-i-can-render-to-floating-point-textures

    // setup the texture
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, typeFloat, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, typeTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, typeTexture);

    // setup the framebuffer
    var framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

    // check the framebuffer
    var status = WebGLCaps._checkRTT[key] = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;

    // cleanup
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(framebuffer);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    return status;
  };
  WebGLCaps.hasRTTLinearHalfFloat = function () {
    return WebGLCaps._webGLExtensions.OES_texture_half_float_linear && WebGLCaps.checkRTTSupport(WebGLCaps.HALF_FLOAT, WebGLCaps._gl.LINEAR);
  };
  WebGLCaps.hasRTTLinearFloat = function () {
    return WebGLCaps._webGLExtensions.OES_texture_float_linear && WebGLCaps.checkRTTSupport(WebGLCaps._gl.FLOAT, WebGLCaps._gl.LINEAR);
  };
  WebGLCaps.hasRTTHalfFloat = function () {
    return WebGLCaps._webGLExtensions.OES_texture_half_float && WebGLCaps.checkRTTSupport(WebGLCaps.HALF_FLOAT, WebGLCaps._gl.NEAREST);
  };
  WebGLCaps.hasRTTFloat = function () {
    return WebGLCaps._webGLExtensions.OES_texture_float && WebGLCaps.checkRTTSupport(WebGLCaps._gl.FLOAT, WebGLCaps._gl.NEAREST);
  };
  WebGLCaps.getWebGLExtension = function (str) {
    return WebGLCaps._webGLExtensions[str];
  };
  WebGLCaps.getWebGLExtensions = function () {
    return WebGLCaps._webGLExtensions;
  };
  WebGLCaps.initWebGLExtensions = function (gl) {
    WebGLCaps._gl = gl;
    var supported = gl.getSupportedExtensions();
    var ext = WebGLCaps._webGLExtensions;
    // we load all the extensions
    for (var i = 0, len = supported.length; i < len; ++i) {
      var sup = supported[i];
      ext[sup] = gl.getExtension(sup);
    }
  };

  module.exports = WebGLCaps;
});
define('drawables/Rtt',['require','exports','module','render/Buffer','render/ShaderLib','render/WebGLCaps'],function (require, exports, module) {

  'use strict';

  var Buffer = require('render/Buffer');
  var Shader = require('render/ShaderLib');
  var WebGLCaps = require('render/WebGLCaps');

  var singletonBuffer;

  var Merge = function (gl, shaderName, depth, halfFloat) {
    this._gl = gl; // webgl context

    this._texture = gl.createTexture();
    this._depth = depth === undefined ? gl.createRenderbuffer() : depth;
    this._framebuffer = gl.createFramebuffer();

    this._shaderName = shaderName || '';
    this._invSize = new Float32Array(2);
    this._vertexBuffer = null;

    if (halfFloat && WebGLCaps.hasRTTHalfFloat()) this._type = WebGLCaps.HALF_FLOAT_OES;
    else if (halfFloat && WebGLCaps.hasRTTFloat()) this._type = gl.FLOAT;
    else this._type = gl.UNSIGNED_BYTE;

    this.init();
  };

  Merge.prototype = {
    getGL: function () {
      return this._gl;
    },
    getVertexBuffer: function () {
      return this._vertexBuffer;
    },
    getFramebuffer: function () {
      return this._framebuffer;
    },
    getTexture: function () {
      return this._texture;
    },
    getDepth: function () {
      return this._depth;
    },
    getInverseSize: function () {
      return this._invSize;
    },
    init: function () {
      var gl = this._gl;

      if (!singletonBuffer) {
        singletonBuffer = new Buffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
        singletonBuffer.update(new Float32Array([-1.0, -1.0, 4.0, -1.0, -1.0, 4.0]));
      }

      this._vertexBuffer = singletonBuffer;
    },
    onResize: function (width, height) {
      var gl = this._gl;

      this._invSize[0] = 1.0 / width;
      this._invSize[1] = 1.0 / height;

      gl.bindTexture(gl.TEXTURE_2D, this._texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, this._type, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      if (this._depth) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, this._depth);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._texture, 0);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._depth);

      gl.bindTexture(gl.TEXTURE_2D, null);
    },
    release: function () {
      if (this._texture) this._gl.deleteTexture(this._texture);
      this.getVertexBuffer().release();
    },
    render: function (main) {
      Shader[this._shaderName].getOrCreate(this._gl).draw(this, main);
    }
  };

  module.exports = Merge;
});

define('text!sdf/SDF.glsl',[],function () { return '#define PI 3.141592653589793\n#define PI_2 1.5707963267948966\n#define SQRT1_2 0.7071067811865476\n#define SQRT2 1.4142135623730951\n\n// raymarching code from https://www.shadertoy.com/view/Xds3zN\n\n// blend color for chamfer and round operators (sd is simple operator distance)\nvec3 colorBlending(const in float sd, const in vec4 a, const in vec4 b) {\n  float ra = clamp(sd / a.x, 0.0, 1.0);\n  float rb = clamp(sd / b.x, 0.0, 1.0);\n  return (a.yzw * ra + b.yzw * rb) / (ra + rb);\n}\n\nvec3 colorUnion(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(min(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec3 colorInter(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(max(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec2 pR45(const in vec2 p) {\n  return (p + vec2(p.y, -p.x)) * SQRT1_2;\n}\n\n/////////////\n// PRIMITIVES\n/////////////\n\nfloat cullPlane(const in vec3 p) {\n  return p.y >= -0.502 ? p.y + 0.5 : 20.0;\n}\n\nfloat sdSphere(const in vec3 p, const in float s) {\n  return length(p) - s;\n}\n\nfloat sdBox(const in vec3 p, const in vec4 b) {\n  vec3 d = abs(p) - b.xyz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;\n}\n\nfloat sdTorus(const in vec3 p, const in vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nfloat sdCapsule(const in vec3 p, const in vec2 rh) {\n  return mix(length(p.xz) - rh.x, length(vec3(p.x, abs(p.y) - rh.y, p.z)) - rh.x, step(rh.y, abs(p.y)));\n}\n\nfloat sdEllipsoid(const in  vec3 p, const in vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n///////////////\n// COMBINATIONS\n///////////////\n\n// UNION\nfloat opUnion(const in float a, const in float b) {\n  return min(a, b);\n}\nvec4 opUnion(const in vec4 a, const in vec4 b) {\n  return (a.x < b.x) ? a : b;\n}\n\n// INTER\nfloat opInter(const in float a, const in float b) {\n  return max(a, b);\n}\nvec4 opInter(const in vec4 a, const in vec4 b) {\n  return (a.x > b.x) ? a : b;\n}\n\n// SUB\nfloat opSub(const in float a, const in float b) {\n  return max(-b, a);\n}\nvec4 opSub(const in vec4 a, const in vec4 b) {\n  // to keep b material on diff intersection instead of a mat\n  // return (-b.x > a.x) ? vec4(-b.x, b.yzw) : a);\n  return vec4(max(-b.x, a.x), a.yzw);\n}\n\n// see hg_sdf.glsl\n/////////////////////\n// COMBINATIONS ROUND\n/////////////////////\n\n// UNION ROUND (soft media mol version)\nfloat opUnionRound(const in float a, const in float b, const in float r) {\n  float e = max(r - abs(a - b), 0.0);\n  return min(a, b) - e * e * 0.25 / r;\n}\nvec4 opUnionRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionRound(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER ROUND\nfloat opInterRound(const in float a, const in float b, const in float r) {\n  vec2 u = max(vec2(r + a, r + b), vec2(0.0));\n  return min(-r, max(a, b)) + length(u);\n}\nvec4 opInterRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB ROUND\nfloat opSubRound(const in float a, const in float b, const in float r) {\n  return opInterRound(a, -b, r);\n}\nvec4 opSubRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, -b.x, r), a.yzw);\n}\n\n///////////////////////\n// COMBINATIONS CHAMFER\n///////////////////////\n\n// UNION CHAMFER\nfloat opUnionChamfer(const in float a, const in float b, const in float r) {\n  return min(min(a, b), (a - r + b) * SQRT1_2);\n}\nvec4 opUnionChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionChamfer(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER CHAMFER\nfloat opInterChamfer(const in float a, const in float b, const in float r) {\n  return max(max(a, b), (a + r + b) * SQRT1_2);\n}\nvec4 opInterChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB CHAMFER\nfloat opSubChamfer(const in float a, const in float b, const in float r) {\n  return opInterChamfer(a, -b, r);\n}\nvec4 opSubChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, -b.x, r), a.yzw);\n}\n\n//////////////////////\n// COMBINATION COLUMNS\n//////////////////////\n\n// UNION COLUMNS\nfloat opUnionColumns(const in float a, const in  float b, const in vec2 rn) {\n  float r = rn.x;\n  float n = rn.y;\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n    p = pR45(p);\n    p.x -= SQRT1_2 * r;\n    p.x += columnradius * SQRT2;\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    // At this point, we have turned 45 degrees and moved at a point on the\n    // diagonal that we want to place the columns on.\n    // Now, repeat the domain along this direction and place a circle.\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n    float result = length(p) - columnradius;\n    result = min(result, p.x);\n    result = min(result, a);\n    return min(result, b);\n  }\n\n  return min(a, b);\n}\nvec4 opUnionColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionColumns(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// SUB COLUMNS\nfloat opSubColumns(const in float ain, const float b, const vec2 rn) {\n  float a = -ain;\n  float r = rn.x;\n  float n = rn.y;\n  float m = min(a, b);\n  //avoid the expensive computation where not needed (produces discontinuity though)\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / n / 2.0;\n    columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n\n    p = pR45(p);\n    p.y += columnradius;\n    p.x -= SQRT1_2 * (r + columnradius);\n\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n\n    float result = -length(p) + columnradius;\n    result = max(result, p.x);\n    result = min(result, a);\n    return -min(result, b);\n  }\n\n  return -m;\n}\nvec4 opSubColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, b.x, rn), a.yzw);\n}\n\n// INTER COLUMNS\nfloat opInterColumns(const in float a, const in float b, const in vec2 rn) {\n  return opSubColumns(a, -b, rn);\n}\nvec4 opInterColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, -b.x, rn), colorInter(a, b));\n}\n\n/////////////////////\n// COMBINATION STAIRS\n/////////////////////\n// UNION STAIRS\nfloat opUnionStairs(const in float a, const in float b, const in vec2 rn) {\n  float s = rn.x / rn.y;\n  float u = b - rn.x;\n  return min(min(a, b), 0.5 * (u + a + abs((mod(u - a + s, 2.0 * s)) - s)));\n}\nvec4 opUnionStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionStairs(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// INTER STAIRS\nfloat opInterStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, -b, rn);\n}\nvec4 opInterStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, -b.x, rn), colorInter(a, b));\n}\n\n// SUB STAIRS\nfloat opSubStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, b, rn);\n}\nvec4 opSubStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, b.x, rn), a.yzw);\n}\n\n/////////////\n// REPETITION\n/////////////\n\nvec3 pMod(const in vec3 p, const in vec3 size) {\n  vec3 pmod = p;\n  if(size.x > 0.0) pmod.x = mod(p.x + size.x * 0.5, size.x) - size.x * 0.5;\n  if(size.y > 0.0) pmod.y = mod(p.y + size.y * 0.5, size.y) - size.y * 0.5;\n  if(size.z > 0.0) pmod.z = mod(p.z + size.z * 0.5, size.z) - size.z * 0.5;\n  return pmod;\n}\n\n////////////\n// HELPERS\n////////////\nvec4 mapDistanceColor(const in vec3 point) {\n  %ID_MAP_DISTANCE_COLOR\n}\n\nfloat mapDistance(const in vec3 point) {\n  %ID_MAP_DISTANCE\n}\n\nvec4 castRay(const in vec3 ro, const in vec3 rd) {\n  float t = 1.0;\n  float tmax = 50.0;\n\n  float precis = 0.002;\n  for(int i = 0; i < 50; i++) {\n    float dist = mapDistance(ro + rd * t);\n    if(dist < precis || t > tmax)\n      break;\n    t += dist;\n  }\n\n  vec3 m = t > tmax ? vec3(-1.0) : mapDistanceColor(ro + rd * t).yzw;\n  return vec4(t, m);\n}\n\nfloat softshadow(const in vec3 ro, const in vec3 rd) {\n  float t = 0.02;\n  float tmax = 2.5;\n  float precis = 0.001;\n  float res = 1.0;\n  for(int i = 0; i < 16; i++) {\n    float h = mapDistance(ro + rd * t);\n    res = min(res, 20.0 * h / t);\n    t += clamp( h, 0.02, 0.10 );\n    if(h < 0.001 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(const in vec3 pos) {\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  vec3 nor = vec3(\n      mapDistance(pos + eps.xyy) - mapDistance(pos - eps.xyy),\n      mapDistance(pos + eps.yxy) - mapDistance(pos - eps.yxy),\n      mapDistance(pos + eps.yyx) - mapDistance(pos - eps.yyx));\n  return normalize(nor);\n}\n\nfloat calcAO(const in vec3 pos, const in vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for(int i = 0; i < 5; i++) {\n      float hr = 0.01 + 0.03 * float(i);\n      vec3 aopos = nor * hr + pos;\n      occ += (hr - mapDistance(aopos)) * sca;\n      sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );\n}\n\n#ifdef TOON\nvec3 render(const in vec3 ro, const in vec3 rd) {\n  vec3 col = vec3(0.5, 0.5, 0.5);\n  vec4 res = castRay(ro, rd);\n\n  if(res.y >= 0.0) {\n    vec3 pos = ro + res.x * rd;\n    vec3 nor = calcNormal(pos);\n\n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize(vec3(-0.6, 0.7, -0.5));\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 ) * clamp( 1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y);\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n    float spe = pow(clamp(dot(ref, lig), 0.0, 1.0),16.0);\n\n    dif *= softshadow(pos, lig);\n    dom *= softshadow(pos, ref);\n\n    vec3 lin = vec3(0.0);\n\tif (dif < 0.3) {\n\t\tlin += 0.8 * vec3(1.00, 0.85, 0.55);\n\t} else if (dif < 0.7) {\n\t\tlin += 1.0 * vec3(1.00, 0.85, 0.55);\n\t} else {\n\t\tlin += 1.20 * vec3(1.00, 0.85, 0.55);\n\t}\n    //lin += 1.20 * dif * vec3(1.00, 0.85, 0.55) * occ;\n    //lin += 1.20 * spe * vec3(1.00, 0.85, 0.55) * dif;\n    lin += 0.20 * amb * vec3(0.50, 0.70, 1.00) * occ;\n    //lin += 0.30 * dom * vec3(0.50, 0.70, 1.00) * occ;\n    //lin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    //lin += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n    col = res.yzw * lin;\n  }\n\n#else  // TOON\n\nvec3 render(const in vec3 ro, const in vec3 rd) {\n  vec3 col = vec3(0.5, 0.5, 0.5);\n  vec4 res = castRay(ro, rd);\n\n  if(res.y >= 0.0) {\n    vec3 pos = ro + res.x * rd;\n    vec3 nor = calcNormal(pos);\n\n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize(vec3(-0.6, 0.7, -0.5));\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 ) * clamp( 1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y);\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n    float spe = pow(clamp(dot(ref, lig), 0.0, 1.0),16.0);\n\n    dif *= softshadow(pos, lig);\n    dom *= softshadow(pos, ref);\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * vec3(1.00, 0.85, 0.55);\n    lin += 1.20 * spe * vec3(1.00, 0.85, 0.55) * dif;\n    lin += 0.20 * amb * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * dom * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n    col = res.yzw * lin;\n  }\n\n  return clamp(col, 0.0, 1.0);\n}\n\n#endif // TOON\n\n#ifdef SHADERTOY\nmat3 setCamera( const in vec3 ro, const in vec3 ta, const float cr ){\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= iResolution.x / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.xy;\n  float time = 15.0 + iGlobalTime;\n\n  // camera\n  vec3 ro = SHADERTOY_ZOOM * vec3( -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x), 1.0 + 2.0 * mo.y, 0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n  vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, 0.0);\n\n  // ray direction\n  vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n  fragColor = vec4(render(ro, rd), 1.0);\n}\n\n#else\n\nvec3 raymarch(const in vec3 origin, const in mat3 view, const in vec2 uv, const in vec2 invSize) {\n  vec2 p = -1.0 + 2.0 * uv;\n  p.x *= invSize.y / invSize.x;\n  vec3 rd = normalize(view * vec3(p, 2.0));\n  return render(origin, rd);\n}\n\nvoid main() {\n  gl_FragColor = vec4(raymarch(uOrigin, uView, vUV, uInvSize), 1.0);\n}\n\n#endif\n';});

define('sdf/Shader',['require','exports','module','render/shaders/ShaderBase','render/Attribute','text!sdf/SDF.glsl','lib/glMatrix'],function (require, exports, module) {

  'use strict';

  var ShaderBase = require('render/shaders/ShaderBase');
  var Attribute = require('render/Attribute');
  var sdfGLSL = require('text!sdf/SDF.glsl');
  var glm = require('lib/glMatrix');

  var mat3 = glm.mat3;

  var ShaderSDF = ShaderBase.getCopy();
  ShaderSDF.vertexName = ShaderSDF.fragmentName = 'SDF';

  ShaderSDF.BLEND_COLOR = true;

  ShaderSDF.uniforms = {};
  ShaderSDF.attributes = {};

  ShaderSDF.uniformNames = ['uInvSize', 'uOrigin', 'uView'];

  ShaderSDF.vertex = [
    'precision mediump float;',
    'attribute vec2 aVertex;',
    'varying vec2 vUV;',
    'void main() {',
    '  vUV = aVertex * 0.5 + 0.5;',
    '  gl_Position = vec4(aVertex, 0.5, 1.0);',
    '}'
  ].join('\n');

  ShaderSDF.fragment = [
    'precision mediump float;',
    'uniform vec3 uOrigin;',
    'uniform mat3 uView;',
    'uniform vec2 uInvSize;',
    'varying vec2 vUV;',
    '%ID_UNIFORM',
    sdfGLSL
  ].join('\n');

  ShaderSDF.createFragment = function (mainSDF) {

    var glsl = ShaderSDF.fragment;

    if (ShaderSDF.BLEND_COLOR)
      glsl = '#define BLEND_COLOR\n' + glsl;

    ///////////
    // SDF VEC2
    ///////////
    var string = [''];
    var res = mainSDF._rootSDF.shaderDistanceMat(string);
    // add a culled plane
    string[0] += 'return ' + res + ';';
    glsl = glsl.replace('%ID_MAP_DISTANCE_COLOR', string[0]);

    ////////////
    // SDF FLOAT
    ////////////
    string = [''];
    res = mainSDF._rootSDF.shaderDistance(string);
    // add a culled plane
    string[0] += 'return ' + res + ';';
    glsl = glsl.replace('%ID_MAP_DISTANCE', string[0]);

    ///////////
    // UNIFORMS
    ///////////
    var mesh = mainSDF._main.getMesh();
    glsl = glsl.replace('%ID_UNIFORM', mesh ? mesh.declareUniforms() : '\n');

    return glsl;
  };

  ShaderSDF.getOrCreate = function () {
    return this;
  };

  ShaderSDF.generateProgram = function (mainSDF) {
    var gl = mainSDF._gl;

    if (this.program)
      gl.deleteProgram(this.program);

    if (!this.vShader) {
      this.vShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(this.vShader, this.vertex);
      gl.compileShader(this.vShader);
    }

    var fShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fShader, ShaderSDF.createFragment(mainSDF));
    gl.compileShader(fShader);

    var program = this.program = gl.createProgram();

    gl.attachShader(program, this.vShader);
    gl.attachShader(program, fShader);
    gl.linkProgram(program);
    gl.useProgram(program);

    var logV = gl.getShaderInfoLog(this.vShader);
    var logF = gl.getShaderInfoLog(fShader);
    var logP = gl.getProgramInfoLog(program);
    var err;
    if (logV) {
      err = this.vertexName + ' (vertex)\n' + logV;
      console.groupCollapsed(err);
      console.log(this.vertex);
      console.groupEnd(err);
    }
    if (logF) {
      err = this.fragmentName + ' (fragment)\n' + logF;
      console.groupCollapsed(err);
      console.log(this.fragment);
      console.groupEnd(err);
    }
    if (logP) {
      err = this.vertexName + ',' + this.fragmentName + ' (program)\n' + logP;
      console.groupCollapsed(err);
      console.log(this.vertex);
      console.log(this.fragment);
      console.groupEnd(err);
    }

    if (!this.attributes.aVertex)
      this.initAttributes(gl);

    ShaderSDF.uniformNames.length = 0;
    ShaderSDF.uniformNames.push('uInvSize', 'uOrigin', 'uView');

    var mesh = mainSDF._main.getMesh();
    if (mesh)
      ShaderSDF.uniformNames.push.apply(ShaderSDF.uniformNames, mesh.getUniformNames());

    this.initUniforms(gl);

    return program;
  };

  ShaderSDF.draw = function (rtt, main) {
    var gl = rtt.getGL();

    if (main._mainSDF._dirtyScene) {
      main._mainSDF._dirtyScene = false;

      if (main.getMesh())
        main.getMesh().setSelected(true);

      ShaderSDF.generateProgram(main._mainSDF);

      if (main.getMesh())
        main.getMesh().setSelected(false);
    }

    gl.useProgram(this.program);

    ShaderSDF.attributes.aVertex.bindToBuffer(rtt.getVertexBuffer());

    gl.uniform2fv(this.uniforms.uInvSize, rtt.getInverseSize());

    var camera = main.getCamera();
    var origin = camera.unproject(camera._width * 0.5, camera._height * 0.5, 0.0);
    gl.uniform3fv(this.uniforms.uOrigin, origin);

    var view = camera._sdfView;
    mat3.normalFromMat4(view, camera.getView());
    mat3.invert(view, view);
    view[6] *= -1.0;
    view[7] *= -1.0;
    view[8] *= -1.0;
    gl.uniformMatrix3fv(this.uniforms.uView, false, view);

    if (main.getMesh())
      main.getMesh().updateUniforms(gl, this.uniforms);

    gl.drawArrays(gl.TRIANGLES, 0, 3);
  };
  ShaderSDF.initAttributes = function (gl) {
    ShaderSDF.attributes.aVertex = new Attribute(gl, ShaderSDF.program, 'aVertex', 2, gl.FLOAT);
  };

  module.exports = ShaderSDF;
});
define('sdf/NodeAbstract',['require','exports','module'],function (require, exports, module) {

  'use strict';

  /////////////////
  // BASE PRIMITIVE
  /////////////////
  var NodeAbstract = function () {
    this._uniformNames = [];
    this._selected = false;
  };
  NodeAbstract.prototype = {
    initObjectJSON: function (obj) {
      var keys = Object.keys(obj);
      for (var i = 0, nbKeys = keys.length; i < nbKeys; ++i) {
        var key = keys[i];
        if (key[0] === 'u') {
          this[key] = obj[key];
        }
      }
    },
    toJSON: function () {
      // serialize keys that start with u
      var json = {};
      json.type = this.type;

      var keys = Object.keys(this);
      for (var i = 0, nbKeys = keys.length; i < nbKeys; ++i) {
        var key = keys[i];
        if (key[0] === 'u') {
          var val = this[key];
          if (val.length) val = Array.apply([], val); // in case of typed array
          json[key] = val;
        }
      }

      return json;
    },
    _prettyFloat: function (val) {
      var str = val.toString();
      return str.indexOf('.') !== -1.0 ? str : str + '.0';
    },
    toStr: function (val) {
      if (!val.length) return this._prettyFloat(val);

      var str = this._prettyFloat(val[0]);
      for (var i = 1, nbElt = val.length; i < nbElt; ++i) str += ',' + this._prettyFloat(val[i]);

      if (val.length < 5) return 'vec' + val.length + '(' + str + ')';
      return 'mat4(' + str + ')';
    },
    getSelected: function () {
      return this._selected;
    },
    setSelected: function (bool) {
      this._selected = bool;
    },
    getParam: function (name) {
      return this[name];
    },
    getParamStr: function (name) {
      if (this._selected) return name;
      return this.toStr(this.getParam(name));
    },
    getParamType: function (name) {
      var val = this[name];
      if (!val.length) return 'float';
      if (val.length < 5) return 'vec' + val.length;
      return 'mat' + Math.sqrt(val.length);
    },
    declareUniforms: function () {
      var uNames = this._uniformNames;
      var unifs = [];
      for (var i = 0, nbNames = uNames.length; i < nbNames; ++i) {
        var uName = uNames[i];
        unifs.push('uniform ' + this.getParamType(uName) + ' ' + uName + ';');
      }
      return unifs.join('\n');
    },
    updateUniforms: function (gl, uniforms) {
      var uNames = this._uniformNames;
      for (var i = 0, nbNames = uNames.length; i < nbNames; ++i) {
        var uName = uNames[i];
        var len = this[uName].length;
        if (!len) gl.uniform1f(uniforms[uName], this.getParam(uName));
        else if (len < 5) gl['uniform' + len + 'fv'](uniforms[uName], this.getParam(uName));
        else gl['uniformMatrix' + Math.sqrt(len) + 'fv'](uniforms[uName], false, this.getParam(uName));
      }
    },
    getUniformNames: function () {
      return this._uniformNames;
    }
  };

  module.exports = NodeAbstract;
});
define('sdf/Combinations',['require','exports','module','misc/Utils','sdf/NodeAbstract'],function (require, exports, module) {

  'use strict';

  var Utils = require('misc/Utils');
  var NodeAbstract = require('sdf/NodeAbstract');

  var Combinations = {};
  Combinations.SHADER_UID_VAR = 1;

  var declare = function (type, strVal, string) {
    var varName = 'tmpComb_' + (Combinations.SHADER_UID_VAR++);
    string[0] += type + ' ' + varName + ' = ' + strVal + ';\n';
    return varName;
  };

  ///////////////////
  // BASE COMBINATION
  ///////////////////
  var BaseCombination = function (op1, op2) {
    NodeAbstract.call(this);
    this.op1 = op1;
    this.op2 = op2;

    if (op1.setCombinator) op1.setCombinator(this);
    if (op2.setCombinator) op2.setCombinator(this);

    this.uRoundRadius = 0.3;
    this.uChamferRadius = 0.3;
    this.uColumns = [0.2, 3.0];
    this.uStairs = [0.2, 3.0];
    this._uniformNames.push('uRoundRadius', 'uChamferRadius', 'uColumns', 'uStairs');
  };
  BaseCombination.prototype = {
    type: 'BaseCombination',
    shaderName: 'shaderName',
    toJSON: function () {
      var json = NodeAbstract.prototype.toJSON.call(this);
      json.op1 = this.op1.toJSON();
      json.op2 = this.op2.toJSON();
      return json;
    },
    shaderMaterialColor: function (string) {
      this.op1.shaderMaterialColor(string);
      this.op2.shaderMaterialColor(string);
    },
    shaderDistanceMat: function (string) {
      return this.combinationDistance(string, 'shaderDistanceMat', 'vec4');
    },
    shaderDistance: function (string) {
      return this.combinationDistance(string, 'shaderDistance', 'float');
    },
    resetTransitions: function (name) {
      this.uRoundRadius = Math.abs(this.uRoundRadius) * (name === 'ROUND' ? 1.0 : -1.0);
      this.uChamferRadius = Math.abs(this.uChamferRadius) * (name === 'CHAMFER' ? 1.0 : -1.0);
      this.uColumns[0] = Math.abs(this.uColumns[0]) * (name === 'COLUMNS' ? 1.0 : -1.0);
      this.uStairs[0] = Math.abs(this.uStairs[0]) * (name === 'STAIRS' ? 1.0 : -1.0);
    },
    getShaderFunc: function () {
      if (this.uRoundRadius > 0.0) return this.shaderName + 'Round';
      if (this.uChamferRadius > 0.0) return this.shaderName + 'Chamfer';
      if (this.uColumns[0] > 0.0) return this.shaderName + 'Columns';
      if (this.uStairs[0] > 0.0) return this.shaderName + 'Stairs';
      return this.shaderName;
    },
    extraParameter: function () {
      var isSelected = this.op1._selected || this.op2._selected;
      if (this.uRoundRadius > 0.0) return [isSelected ? 'uRoundRadius' : this.toStr(this.uRoundRadius)];
      if (this.uChamferRadius > 0.0) return [isSelected ? 'uChamferRadius' : this.toStr(this.uChamferRadius)];
      if (this.uColumns[0] > 0.0) return [isSelected ? 'uColumns' : this.toStr(this.uColumns)];
      if (this.uStairs[0] > 0.0) return [isSelected ? 'uStairs' : this.toStr(this.uStairs)];
      return [''];
    },
    combinationDistance: function (string, func, type) {
      var op1 = this.op1[func](string);
      var op2 = this.op2[func](string);

      if (!!this.op1.op1) op1 = declare(type, op1, string);
      if (!!this.op2.op1) op2 = declare(type, op2, string);

      var params = this.extraParameter().join(',');
      if (params.length > 1) params = ', ' + params;

      return declare(type, this.getShaderFunc() + '(' + op1 + ', ' + op2 + params + ')', string);
    }
  };
  Utils.makeProxy(NodeAbstract, BaseCombination);

  ////////
  // UNION
  ////////
  Combinations.UNION = function (op1, op2) {
    BaseCombination.call(this, op1, op2);
  };
  Combinations.UNION.prototype = {
    type: 'UNION',
    shaderName: 'opUnion'
  };
  Utils.makeProxy(BaseCombination, Combinations.UNION);

  ////////
  // INTER
  ////////
  Combinations.INTER = function (op1, op2) {
    BaseCombination.call(this, op1, op2);
  };
  Combinations.INTER.prototype = {
    type: 'INTER',
    shaderName: 'opInter'
  };
  Utils.makeProxy(BaseCombination, Combinations.INTER);

  //////
  // SUB
  //////
  Combinations.SUB = function (op1, op2) {
    BaseCombination.call(this, op1, op2);
  };
  Combinations.SUB.prototype = {
    type: 'SUB',
    shaderName: 'opSub'
  };
  Utils.makeProxy(BaseCombination, Combinations.SUB);

  Combinations.SUB_INV = function (op1, op2) {
    BaseCombination.call(this, op2, op1);
  };
  Combinations.SUB_INV.prototype = Combinations.SUB.prototype;

  module.exports = Combinations;
});
define('sdf/Primitives',['require','exports','module','lib/glMatrix','misc/Utils','sdf/NodeAbstract'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var Utils = require('misc/Utils');
  var NodeAbstract = require('sdf/NodeAbstract');

  var mat4 = glm.mat4;
  var vec3 = glm.vec3;

  var m4tmp = mat4.create();
  var v3zero = [0.0, 0.0, 0.0];

  var Primitives = {};
  Primitives.SHADER_UID_VAR = 1;

  var declare = function (type, strVal, string) {
    var varName = 'tmpPrim_' + (Primitives.SHADER_UID_VAR++);
    string[0] += type + ' ' + varName + ' = ' + strVal + ';\n';
    return varName;
  };

  /////////////////
  // BASE PRIMITIVE
  /////////////////
  var BasePrimitive = function () {
    NodeAbstract.call(this);

    // for transforms
    this._matrix = mat4.create();
    this._editMatrix = mat4.create();

    this.uBaseTransform = mat4.create();
    this.uBaseColor = [1.0, 0.5, 0.5];
    this.uBaseMod = [-5.0, -5.0, -5.0];
    this._uniformNames.push('uBaseTransform', 'uBaseColor', 'uBaseMod');

    this._combinator = undefined;
  };
  BasePrimitive.prototype = {
    type: 'BasePrimitive',
    initObjectJSON: function (obj) {
      NodeAbstract.prototype.initObjectJSON.call(this, obj);
      mat4.invert(this._matrix, this.uBaseTransform);
    },
    setCombinator: function (combinator) {
      this._combinator = combinator;
    },
    getParam: function (name) {
      if (name === 'uBaseTransform') return mat4.invert(this.uBaseTransform, mat4.mul(m4tmp, this._matrix, this._editMatrix));
      return this[name];
    },
    getScale: function () {
      return vec3.len(mat4.mul(m4tmp, this._matrix, this._editMatrix));
    },
    declareUniforms: function () {
      var unifs = NodeAbstract.prototype.declareUniforms.call(this) + '\n';
      if (this._combinator) unifs = unifs.concat(this._combinator.declareUniforms());
      return unifs;
    },
    updateUniforms: function (gl, uniforms) {
      NodeAbstract.prototype.updateUniforms.call(this, gl, uniforms);
      if (this._combinator) this._combinator.updateUniforms(gl, uniforms);
    },
    getUniformNames: function () {
      var unifs = this._uniformNames;
      if (this._combinator) unifs = unifs.concat(this._combinator.getUniformNames());
      return unifs;
    },
    shaderDistanceMat: function (string) {
      var dist = this.shaderDistance(string);
      return declare('vec4', 'vec4(' + dist + ', ' + this.getParamStr('uBaseColor') + ')', string);
    },
    getCenter: function () {
      return v3zero;
    },
    getMatrix: function () {
      return this._matrix;
    },
    getEditMatrix: function () {
      return this._editMatrix;
    },
    getScaleStr: function () {
      if (!this._selected) return this.toStr(this.getScale());
      var uMat = this.getParamStr('uBaseTransform');
      return '1.0 / length(' + uMat + '[0] )';
    },
    getTransformPointStr: function () {
      return 'pMod((' + this.getParamStr('uBaseTransform') + ' * vec4(point, 1.0)).xyz, ' + this.getParamStr('uBaseMod') + ')';
    }
  };
  Utils.makeProxy(NodeAbstract, BasePrimitive);

  ////////
  // PLANE
  ////////
  Primitives.PLANE = function () {
    BasePrimitive.call(this);
  };
  Primitives.PLANE.prototype = {
    type: 'PLANE',
    getParamStr: function (name) {
      if (name === 'uBaseColor')
        return 'vec3(0.1) * (mod(floor(5.0 * point.z) + floor(5.0 * point.x), 2.0)) + 0.4';
      return BasePrimitive.prototype.getParamStr.call(this, name);
    },
    shaderDistance: function () {
      var pt = this.getTransformPointStr();
      return 'cullPlane(' + pt + ') * ' + this.getScaleStr();
    }
  };
  Utils.makeProxy(BasePrimitive, Primitives.PLANE);

  /////////
  // SPHERE
  /////////
  Primitives.SPHERE = function () {
    BasePrimitive.call(this);
    this.uSphereRadius = 0.4;
    this._uniformNames.push('uSphereRadius');
  };
  Primitives.SPHERE.prototype = {
    type: 'SPHERE',
    shaderDistance: function () {
      var pt = this.getTransformPointStr();
      var radius = this.getParamStr('uSphereRadius');
      return 'sdSphere(' + pt + ', ' + radius + ') * ' + this.getScaleStr();
    }
  };
  Utils.makeProxy(BasePrimitive, Primitives.SPHERE);

  //////
  // BOX
  //////
  Primitives.BOX = function () {
    BasePrimitive.call(this);
    this.uBoxSides = [0.2, 0.4, 0.8, 0.1];
    this._uniformNames.push('uBoxSides');
  };
  Primitives.BOX.prototype = {
    type: 'BOX',
    shaderDistance: function () {
      var pt = this.getTransformPointStr();
      var sides = this.getParamStr('uBoxSides');
      return 'sdBox(' + pt + ', ' + sides + ') * ' + this.getScaleStr();
    }
  };
  Utils.makeProxy(BasePrimitive, Primitives.BOX);

  ////////
  // TORUS
  ////////
  Primitives.TORUS = function () {
    BasePrimitive.call(this);
    this.uTorusRadii = [0.4, 0.05];
    this._uniformNames.push('uTorusRadii');
  };
  Primitives.TORUS.prototype = {
    type: 'TORUS',
    shaderDistance: function () {
      var pt = this.getTransformPointStr();
      var radii = this.getParamStr('uTorusRadii');
      return 'sdTorus(' + pt + ', ' + radii + ') * ' + this.getScaleStr();
    }
  };
  Utils.makeProxy(BasePrimitive, Primitives.TORUS);

  //////////
  // CAPSULE
  //////////
  Primitives.CAPSULE = function () {
    BasePrimitive.call(this);
    this.uCapsuleRH = [0.2, 0.5];
    this._uniformNames.push('uCapsuleRH');
  };
  Primitives.CAPSULE.prototype = {
    type: 'CAPSULE',
    shaderDistance: function () {
      var pt = this.getTransformPointStr();
      var rh = this.getParamStr('uCapsuleRH');
      return 'sdCapsule(' + pt + ', ' + rh + ') * ' + this.getScaleStr();
    }
  };
  Utils.makeProxy(BasePrimitive, Primitives.CAPSULE);

  ////////////
  // ELLIPSOID
  ////////////
  Primitives.ELLIPSOID = function () {
    BasePrimitive.call(this);
    this.uEllipsoidSides = [0.2, 0.4, 0.8];
    this._uniformNames.push('uEllipsoidSides');
  };
  Primitives.ELLIPSOID.prototype = {
    type: 'ELLIPSOID',
    shaderDistance: function () {
      var pt = this.getTransformPointStr();
      var sides = this.getParamStr('uEllipsoidSides');
      return 'sdEllipsoid(' + pt + ', ' + sides + ') * ' + this.getScaleStr();
    }
  };
  Utils.makeProxy(BasePrimitive, Primitives.ELLIPSOID);

  module.exports = Primitives;
});
define('sdf/Gui',['require','exports','module','lib/FileSaver','sdf/Shader','sdf/Combinations','sdf/Primitives','lib/glMatrix'],function (require, exports, module) {

  'use strict';

  var saveAs = require('lib/FileSaver');
  var Shader = require('sdf/Shader');
  var Combinations = require('sdf/Combinations');
  var Primitives = require('sdf/Primitives');
  var glm = require('lib/glMatrix');

  var vec3 = glm.vec3;

  var GuiSDF = function (mainSDF) {
    this._main = mainSDF._main;
    this._mainSDF = mainSDF;
    this.initGui();
  };

  GuiSDF.prototype = {
    importFile: function () {
      document.getElementById('fileopen').click();
    },
    exportFile: function () {
      var scene = {
        root: this._mainSDF._rootSDF.toJSON(),
        blendColor: Shader.BLEND_COLOR,
        version: 1,
		undoBuffer : this.undoBuffer
      };
      var json = JSON.stringify(scene);
      saveAs(new Blob([json]), 'scene.json');
    },
    exportShader: function () {
      var shader = '#define SHADERTOY\n#define SHADERTOY_ZOOM 2.0\n' + Shader.createFragment(this._mainSDF);
      saveAs(new Blob([shader]), 'shadertoy.glsl');
    },
    showCredits: function () {

    },
    initGui: function () {

      // import export
      var topbar = this._main._gui._topbar;
      var files = topbar.addMenu('Export/Import');
      files.addButton('Import (json)', this, 'importFile');
      files.addButton('Export (json)', this, 'exportFile');
      files.addButton('Shadertoy (glsl)', this, 'exportShader');

      // credits
      var credits = topbar.addMenu('Credits', this, 'showCredits');
      credits.addTitle('Raymarch template');
      credits.addButton('Inigo Quilez (iq)', window.open.bind(window, 'https://www.shadertoy.com/view/Xds3zN', '_blank'));
      credits.addTitle('Combination op');
      credits.addButton('Mercuy', window.open.bind(window, 'http://mercury.sexy/hg_sdf/', '_blank'));

      // sidebar stuffs
      var sidebar = this._main._gui._sidebar;
      var menu = sidebar.addMenu('SDF');

      var optPrim = {
        PRIMITIVE: 'Select a primitive',
        SPHERE: 'Sphere',
        BOX: 'Box',
        TORUS: 'Torus',
        CAPSULE: 'Capsule',
        ELLIPSOID: 'Ellipsoid'
      };
      this._ctrlPrimitive = menu.addCombobox('Primitive', 'PRIMITIVE', this.onPrimitive.bind(this), optPrim);

      // hideable ctrls
      this._ctrls = [];

	  this.undoBuffer = [];
	  this.redoBuffer = [];
	  this.isInitialRedo = true;
	  this.isInitialUndo = true;

      var apply = menu.addButton('Apply', this, 'applyPrimitive');
      apply.domButton.style.background = 'rgba(120, 230, 0, 0.8)';
      this._ctrls.push(apply);

	  menu.addButton('Undo', this, 'onUndo', 'CTRL+Z');
	  menu.addButton('Redo', this, 'onRedo', 'CTRL+Y');

      this._ctrlBlendColor = menu.addCheckbox('Blend Color', Shader.BLEND_COLOR, this.onBlendColor.bind(this));

      this._initGuiCombination(menu);
      this._initGuiRepetition(menu);
      this._initGuiPrimitive(menu);

      this.setCtrlVisibility(false);
      this._ctrlPrimitive.setValue('BOX');
    },
    _initGuiRepetition: function (menu) {
      var ctrls = this._ctrls;

      ctrls.push(menu.addTitle('Domain repetition'));

      this._ctrlRepeat = [];
      this._ctrlRepeat[0] = menu.addCheckbox('Repeat in X', false, this.onRepeat.bind(this, 0));
      ctrls.push(menu.addSlider('X dist', 5.0, this.onRepeatDist.bind(this, 0), 0.1, 10.0, 0.01));

      this._ctrlRepeat[1] = menu.addCheckbox('Repeat in Y', false, this.onRepeat.bind(this, 1));
      ctrls.push(menu.addSlider('Y dist', 5.0, this.onRepeatDist.bind(this, 1), 0.1, 10.0, 0.01));

      this._ctrlRepeat[2] = menu.addCheckbox('Repeat in Z', false, this.onRepeat.bind(this, 2));
      ctrls.push(menu.addSlider('Z dist', 5.0, this.onRepeatDist.bind(this, 2), 0.1, 10.0, 0.01));

      ctrls.push(this._ctrlRepeat[0]);
      ctrls.push(this._ctrlRepeat[1]);
      ctrls.push(this._ctrlRepeat[2]);
    },
    _initGuiPrimitive: function (menu) {
      var ctrls = this._ctrls;

      ctrls.push(menu.addTitle('Primitive'));
      this._ctrlColor = menu.addColor('Color', [0.5, 0.5, 1.0], this.onColor.bind(this));
      ctrls.push(this._ctrlColor);

      // box sides
      this._ctrlBoxX = menu.addSlider('Side X', 0.2, this.onBoxSides.bind(this, 0), 0.01, 2.0, 0.01);
      this._ctrlBoxY = menu.addSlider('Side Y', 0.4, this.onBoxSides.bind(this, 1), 0.01, 2.0, 0.01);
      this._ctrlBoxZ = menu.addSlider('Side Z', 0.8, this.onBoxSides.bind(this, 2), 0.01, 2.0, 0.01);
      this._ctrlBoxW = menu.addSlider('Radius', 0.2, this.onBoxSides.bind(this, 3), 0.0, 1.0, 0.01);
      this._ctrlBoxX._primitive = 'BOX';
      this._ctrlBoxY._primitive = 'BOX';
      this._ctrlBoxZ._primitive = 'BOX';
      this._ctrlBoxW._primitive = 'BOX';
      ctrls.push(this._ctrlBoxX);
      ctrls.push(this._ctrlBoxY);
      ctrls.push(this._ctrlBoxZ);
      ctrls.push(this._ctrlBoxW);

      // sphere radius
      this._ctrlSphereR = menu.addSlider('Radius', 4.0, this.onSphereRadius.bind(this), 0.01, 2.0, 0.01);
      this._ctrlSphereR._primitive = 'SPHERE';
      ctrls.push(this._ctrlSphereR);

      // torus radii
      this._ctrlTorusR1 = menu.addSlider('Radius', 4.0, this.onTorusRadii.bind(this, 0), 0.1, 4.0, 0.01);
      this._ctrlTorusR2 = menu.addSlider('Thickness radius', 0.5, this.onTorusRadii.bind(this, 1), 0.01, 0.5, 0.01);
      this._ctrlTorusR1._primitive = 'TORUS';
      this._ctrlTorusR2._primitive = 'TORUS';
      ctrls.push(this._ctrlTorusR1);
      ctrls.push(this._ctrlTorusR2);

      // capsule radii
      this._ctrlCapsuleR = menu.addSlider('Radius', 0.2, this.onCapsule.bind(this, 0), 0.01, 2.0, 0.01);
      this._ctrlCapsuleH = menu.addSlider('Height', 0.5, this.onCapsule.bind(this, 1), 0.01, 2.0, 0.01);
      this._ctrlCapsuleR._primitive = 'CAPSULE';
      this._ctrlCapsuleH._primitive = 'CAPSULE';
      ctrls.push(this._ctrlCapsuleR);
      ctrls.push(this._ctrlCapsuleH);

      // ellipsoid
      this._ctrlEllipsoidX = menu.addSlider('X', 0.2, this.onEllipsoid.bind(this, 0), 0.05, 2.0, 0.01);
      this._ctrlEllipsoidY = menu.addSlider('Y', 0.4, this.onEllipsoid.bind(this, 1), 0.05, 2.0, 0.01);
      this._ctrlEllipsoidZ = menu.addSlider('Z', 0.8, this.onEllipsoid.bind(this, 2), 0.05, 2.0, 0.01);
      this._ctrlEllipsoidX._primitive = 'ELLIPSOID';
      this._ctrlEllipsoidY._primitive = 'ELLIPSOID';
      this._ctrlEllipsoidZ._primitive = 'ELLIPSOID';
      ctrls.push(this._ctrlEllipsoidX);
      ctrls.push(this._ctrlEllipsoidY);
      ctrls.push(this._ctrlEllipsoidZ);
    },
    _initGuiCombination: function (menu) {
      var ctrls = this._ctrls;

      ctrls.push(menu.addTitle('Operator'));

      // boolean
      var optBool = {
        UNION: 'Union',
        SUB: 'Difference',
        SUB_INV: 'Difference Inverse',
        INTER: 'Intersection'
      };
      this._ctrlCombination = menu.addCombobox('Combination', 'UNION', this.onCombination.bind(this), optBool);
      ctrls.push(this._ctrlCombination);

      // transition
      var optTrans = {
        NONE: 'None',
        ROUND: 'Round',
        CHAMFER: 'Chamfer',
        COLUMNS: 'Columns',
        STAIRS: 'Stairs'
      };
      this._ctrlTransition = menu.addCombobox('Transition', 'ROUND', this.onTransition.bind(this), optTrans);
      ctrls.push(this._ctrlTransition);

      // round
      this._ctrlRoundRadius = menu.addSlider('Roundness', 1.0, this.onRoundRadius.bind(this), 0.01, 4.0, 0.01);
      this._ctrlRoundRadius._transition = 'ROUND';
      ctrls.push(this._ctrlRoundRadius);

      // chamfer
      this._ctrlChamferRadius = menu.addSlider('Chamfer', 1.0, this.onChamferRadius.bind(this), 0.01, 2.0, 0.01);
      this._ctrlChamferRadius._transition = 'CHAMFER';
      ctrls.push(this._ctrlChamferRadius);

      // columns
      this._ctrlColumnsR = menu.addSlider('Radius', 0.3, this.onColumns.bind(this, 0), 0.01, 4.0, 0.01);
      this._ctrlColumnsR._transition = 'COLUMNS';
      this._ctrlColumnsN = menu.addSlider('Nb repeat', 3.0, this.onColumns.bind(this, 1), 0.0, 10.0, 0.01);
      this._ctrlColumnsN._transition = 'COLUMNS';
      ctrls.push(this._ctrlColumnsR);
      ctrls.push(this._ctrlColumnsN);

      // stairs
      this._ctrlStairsR = menu.addSlider('Radius', 0.3, this.onStairs.bind(this, 0), 0.01, 4.0, 0.01);
      this._ctrlStairsR._transition = 'STAIRS';
      this._ctrlStairsN = menu.addSlider('Nb repeat', 3.0, this.onStairs.bind(this, 1), 0.0, 10.0, 0.01);
      this._ctrlStairsN._transition = 'STAIRS';
      ctrls.push(this._ctrlStairsR);
      ctrls.push(this._ctrlStairsN);
    },
    setCtrlVisibility: function (bool, primName, transName) {
      var ctrls = this._ctrls;
      for (var i = 0, nbCtrls = ctrls.length; i < nbCtrls; ++i) {
        var visible = bool;

        if (bool) {
          if (ctrls[i]._primitive !== undefined && ctrls[i]._primitive !== primName)
            visible = false;
          else if (ctrls[i]._transition !== undefined && ctrls[i]._transition !== transName)
            visible = false;
        }

        ctrls[i].setVisibility(visible);
      }
    },
    applyPrimitive: function () {
      this._lastRoot = undefined;
      this._mainSDF._lastPrim = undefined;
      this._ctrlPrimitive.setValue('PRIMITIVE');
      this._main.render();
	  if (!this.isUndoRedo) {
		  if (this.isInitialRedo && this.redoBuffer.length > 0) {
			  this.undoBuffer.push(this.redoBuffer.pop());
		  }
		  this.redoBuffer = [];
		  this.undoBuffer.push({
			  root : this._mainSDF._rootSDF.toJSON(),
	          blendColor: Shader.BLEND_COLOR,
	          version: 1
		  });
		  this.isInitialUndo = true;
	  }
    },
	onUndo : function () {
		var data;
		if (!this.isUndoRedo && this.undoBuffer.length > 0) {
			if (this.redoBuffer.length === 0) {
				data = this.undoBuffer.pop();
				this.redoBuffer.push(data);
			}
			data = this.undoBuffer.pop();
			this.redoBuffer.push(data);
			this.isUndoRedo = true;
			this._mainSDF.createRootFromJSON(JSON.stringify(data));
			this.isUndoRedo = false;
			this.isInitialRedo = true;
			this.isInitialUndo = false;
		}
	},
	onRedo : function () {
		var data;
		if (!this.isUndoRedo && this.redoBuffer.length > 0) {
			if (this.isInitialRedo) {
				data = this.redoBuffer.pop();
				this.undoBuffer.push(data);
				this.isInitialRedo = false;
			}
			data = this.redoBuffer.pop();
			this.undoBuffer.push(data);
			this.isUndoRedo = true;
			this._mainSDF.createRootFromJSON(JSON.stringify(data));
			this.isUndoRedo = false;
		}
	},
    onPrimitive: function (name) {
      this._main.render();
      this._mainSDF._dirtyScene = true;

      // remove last inserted primitive
      if (this._lastRoot)
        this._mainSDF._rootSDF = this._lastRoot;

      var isReset = !Primitives[name];
      // display/hide ui
      this.setCtrlVisibility(!isReset, name, this._ctrlTransition.getValue());

      if (isReset) {
        this._mainSDF._lastPrim = undefined;
        this._main.setMesh(null);
        return;
      }

      var prim = new Primitives[name]();
      vec3.copy(prim.getParam('uBaseColor'), this._ctrlColor.getValue());
      if (this._mainSDF._lastPrim) vec3.copy(prim.getCenter(), this._mainSDF._lastPrim.getCenter());

      this._lastRoot = this._mainSDF._rootSDF;
      this._mainSDF._lastPrim = prim;

      this._mainSDF._rootSDF = new Combinations[this._ctrlCombination.getValue()](this._mainSDF._rootSDF, prim);
      this.updateTransiton();

      this._main.setMesh(prim);
    },
    onCombination: function () {
      this._mainSDF._rootSDF = new Combinations[this._ctrlCombination.getValue()](this._lastRoot, this._mainSDF._lastPrim);
      this.updateTransiton();

      this._main.render();
      this._mainSDF._dirtyScene = true;
    },
    // -------- transition ---------
    onTransition: function (name) {
      this.setCtrlVisibility(true, this._ctrlPrimitive.getValue(), name);
      this.updateTransiton();
    },
    updateTransiton: function () {
      var comb = this._mainSDF._rootSDF;

      comb.uRoundRadius = this._ctrlRoundRadius.getValue();
      comb.uChamferRadius = this._ctrlChamferRadius.getValue();

      comb.uColumns[0] = this._ctrlColumnsR.getValue();
      comb.uColumns[1] = this._ctrlColumnsN.getValue();

      comb.uStairs[0] = this._ctrlStairsR.getValue();
      comb.uStairs[1] = this._ctrlStairsN.getValue();

      comb.resetTransitions(this._ctrlTransition.getValue());
      this._mainSDF._dirtyScene = true;
      this._main.render();
    },
    // -------- round ---------
    onRoundRadius: function (val) {
      this._mainSDF._rootSDF.uRoundRadius = val;
      this._main.render();
    },
    // -------- chamfer ---------
    onChamferRadius: function (val) {
      this._mainSDF._rootSDF.uChamferRadius = val;
      this._main.render();
    },
    // -------- columns ---------
    onColumns: function (dim, val) {
      this._mainSDF._rootSDF.uColumns[dim] = val;
      this._main.render();
    },
    // -------- stairs ---------
    onStairs: function (dim, val) {
      this._mainSDF._rootSDF.uStairs[dim] = val;
      this._main.render();
    },
    onColor: function () {
      vec3.copy(this._mainSDF._lastPrim.getParam('uBaseColor'), this._ctrlColor.getValue());
      this._main.render();
    },
    onBlendColor: function (val) {
      Shader.BLEND_COLOR = val;
      this._mainSDF._dirtyScene = true;
      this._main.render();
    },
    // -------- domain repetition ---------
    onRepeat: function (dim, val) {
      this._mainSDF._lastPrim.uBaseMod[dim] = Math.abs(this._mainSDF._lastPrim.uBaseMod[dim]) * (val > 0.0 ? 1.0 : -1.0);
      this._main.render();
    },
    onRepeatDist: function (dim, val) {
      this._ctrlRepeat[dim].setValue(true);
      this._mainSDF._lastPrim.uBaseMod[dim] = val;
      this._main.render();
    },
    // -------- box ---------
    onBoxSides: function (dim, val) {
      this._mainSDF._lastPrim.uBoxSides[dim] = val;
      this._main.render();
    },
    // -------- sphere ---------
    onSphereRadius: function (val) {
      this._mainSDF._lastPrim.uSphereRadius = val;
      this._main.render();
    },
    // -------- torus ---------
    onTorusRadii: function (dim, val) {
      this._mainSDF._lastPrim.uTorusRadii[dim] = val;
      this._main.render();
    },
    // -------- capsule ---------
    onCapsule: function (dim, val) {
      this._mainSDF._lastPrim.uCapsuleRH[dim] = val;
      this._main.render();
    },
    // -------- ellipsoid ---------
    onEllipsoid: function (dim, val) {
      this._mainSDF._lastPrim.uEllipsoidSides[dim] = val;
      this._main.render();
    }
  };

  module.exports = GuiSDF;
});

define('sdf/MainSDF',['require','exports','module','drawables/Rtt','sdf/Shader','render/ShaderLib','gui/GuiCamera','sdf/Combinations','sdf/Primitives','sdf/Gui','editing/Gizmo','lib/glMatrix'],function (require, exports, module) {

  'use strict';

  var Rtt = require('drawables/Rtt');
  var Shader = require('sdf/Shader');
  require('render/ShaderLib').SDF = Shader;
  var GuiCamera = require('gui/GuiCamera');
  var Combinations = require('sdf/Combinations');
  var Primitives = require('sdf/Primitives');
  var Gui = require('sdf/Gui');
  var Gizmo = require('editing/Gizmo');
  var glm = require('lib/glMatrix');

  var mat3 = glm.mat3;
  var mat4 = glm.mat4;

  var MainSDF = function (main) {
    this._main = main;
    this._gl = main._gl;
    this._rttSDF = new Rtt(this._gl, 'SDF', null);

    this._rootSDF = undefined;
    this._lastPrim = undefined; // last selected primitive
    this._dirtyScene = true;

    this._initScene();
    this._hookSculptGL();
    this.onCanvasResize(main._canvasWidth, main._canvasHeight);
  };

  MainSDF.prototype = {
    _initScene: function () {
      var plane = new Primitives.PLANE();
      plane._matrix[13] -= 0.3;
      this._rootSDF = plane;
    },
    _hookSculptGL: function () {
      var main = this._main;
      main.clearScene();

      this._main.applyRender = this._applyRender.bind(this);
      this._main.onDeviceDown = this._onDeviceDown.bind(this);

      this._hookReadFile();
      this._hookCamera();
      this._hookGui();
      this._hookSculpt();
    },
    _hookReadFile: function () {
      var self = this;

      this._main.getFileType = function (name) {
        if (name.toLowerCase().endsWith('.json')) return 'json';
        return;
      };

      this._main.readFile = function (file, ftype) {
        if (ftype !== 'json')
          return;

        var reader = new FileReader();
        reader.onload = function (evt) {
          self.createRootFromJSON(evt.target.result);
          document.getElementById('fileopen').value = '';
        };

        reader.readAsText(file);
      };
    },
    _hookCamera: function () {
      var camera = this._main.getCamera();
      camera.setFov(53);
      camera.updateProjection();
      camera._sdfView = mat3.create();
      camera.setUsePivot(false);
    },
    _onDeviceDown: function (event) {
      var main = this._main;
      if (main._focusGui)
        return;

      main.setMousePosition(event);

      var mouseX = main._mouseX;
      var mouseY = main._mouseY;
      var button = event.which;

      main._sculpt.start(event.shiftKey);
      var pickedMesh = main._picking.getMesh();

      if (pickedMesh)
        main._action = 'SCULPT_EDIT';
      else if (event.ctrlKey)
        main._action = 'CAMERA_ZOOM';
      else if (event.altKey)
        main._action = 'CAMERA_PAN_ZOOM_ALT';
      else if (button === 2)
        main._action = 'CAMERA_PAN';
      else if (button === 3)
        main._action = 'CAMERA_ZOOM';
      else
        main._action = 'CAMERA_ROTATE';

		console.log(mouseX, mouseY);
      if (main._action === 'CAMERA_ROTATE' || main._action === 'CAMERA_ZOOM')
        main._camera.start(mouseX, mouseY);

      main._lastMouseX = mouseX;
      main._lastMouseY = mouseY;
    },
    _hookSculpt: function () {
      var main = this._main;
      var picking = main.getPicking();
      // force transform tool
      var sculpt = this._main.getSculpt();
      sculpt._tool = 'TRANSFORM';

      var transformTool = sculpt.getCurrentTool();
      transformTool._gizmo.setActivatedType(Gizmo.TRANS_XYZ | Gizmo.PLANE_XYZ | Gizmo.ROT_XYZ | Gizmo.ROT_W | Gizmo.SCALE_W);

      transformTool.start = function () {
        var mesh = this.getMesh();
        if (mesh && this._gizmo.onMouseDown()) {
          this.pushState();
          picking._mesh = mesh;
          return;
        }

        picking._mesh = null;
        this._lastMouseX = main._mouseX;
        this._lastMouseY = main._mouseY;
      };

      transformTool.end = function () {
        this._gizmo.onMouseUp();

        var dx = Math.abs(main._mouseX - this._lastMouseX);
        var dy = Math.abs(main._mouseY - this._lastMouseY);
        if (dx * dx + dy * dy < 4.0)
          return;

        var mesh = this.getMesh();
        if (!mesh)
          return;

        if (this.isIdentity(mesh.getEditMatrix()))
          return;

        mat4.mul(mesh.getMatrix(), mesh.getMatrix(), mesh.getEditMatrix());
        mat4.identity(mesh.getEditMatrix());
      };
    },
    _hookGui: function () {
      var main = this._main;
      var gui = main.getGui();
      for (var i = 0, ctrls = gui._ctrls, nb = ctrls.length; i < nb; ++i) {
        var ct = ctrls[i];
        // keep camera and config
        if (ct instanceof GuiCamera)
          continue;
        if (ct.removeEvents) ct.removeEvents();
        if (ct._menu) ct._menu.setVisibility(false);
        ctrls[i] = null;
      }

      gui.updateMesh = function () {};

      gui._ctrlCamera._ctrlProjectionTitle.setVisibility(false);
      gui._ctrlCamera._ctrlProjection.setVisibility(false);
      gui._ctrlCamera._ctrlPivot.setVisibility(false);
      gui._ctrlCamera._ctrlFov.setVisibility(false);

      this._sdfGUI = new Gui(this);
    },
    onCanvasResize: function (width, height) {
      this._rttSDF.onResize(width, height);
    },
    _applyRender: function () {
      var main = this._main;
      main._preventRender = false;

      var gl = this._gl;
      if (!gl)
        return;

      gl.disable(gl.DEPTH_TEST);
      gl.bindFramebuffer(gl.FRAMEBUFFER, main._rttMerge.getFramebuffer());
      this._rttSDF.render(main);

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      main._rttOpaque.render(main); // fxaa
      main._selection.render(main);

      gl.enable(gl.DEPTH_TEST);
      main._sculpt.postRender();
    },
    createRootFromJSON: function (json) {
      var scene = JSON.parse(json);
      this._rootSDF = this._createNode(scene.root);
      this._dirtyScene = true;
      this._lastPrim = undefined;
      this._sdfGUI.applyPrimitive();
      this._sdfGUI._ctrlBlendColor.setValue(scene.blendColor);

  	  this._sdfGUI.undoBuffer = [];
  	  this._sdfGUI.redoBuffer = [];
  	  this._sdfGUI.isInitialRedo = true;
  	  this._sdfGUI.isInitialUndo = true;
	  if (scene.hasOwnProperty('undoBuffer')) {
		  this._sdfGUI.undoBuffer = scene.undoBuffer;
	  }
      this._main.render();
    },
    _createNode: function (obj) {
      var type = obj.type;
      var node;

      if (Combinations[type]) {
        var op1 = this._createNode(obj.op1);
        var op2 = this._createNode(obj.op2);
        node = new Combinations[type](op1, op2);
        node.initObjectJSON(obj);

      } else if (Primitives[type]) {
        node = new Primitives[type]();
        node.initObjectJSON(obj);

      } else {
        console.error('Unknown type :', type);
      }

      return node;
    }
  };

  module.exports = MainSDF;
});

define('Scene',['require','exports','module','lib/glMatrix','misc/getOptionsURL','misc/Utils','editing/Sculpt','editing/Subdivision','files/Import','gui/Gui','math3d/Camera','math3d/Picking','drawables/Background','drawables/Selection','mesh/Mesh','mesh/multiresolution/Multimesh','drawables/Primitives','states/States','mesh/Render','drawables/Rtt','render/ShaderLib','render/WebGLCaps','sdf/MainSDF'],function (require, exports, module) {

  'use strict';

  var glm = require('lib/glMatrix');
  var getOptionsURL = require('misc/getOptionsURL');
  var Utils = require('misc/Utils');
  var Sculpt = require('editing/Sculpt');
  var Subdivision = require('editing/Subdivision');
  var Import = require('files/Import');
  var Gui = require('gui/Gui');
  var Camera = require('math3d/Camera');
  var Picking = require('math3d/Picking');
  var Background = require('drawables/Background');
  var Selection = require('drawables/Selection');
  var Mesh = require('mesh/Mesh');
  var Multimesh = require('mesh/multiresolution/Multimesh');
  var Primitives = require('drawables/Primitives');
  var States = require('states/States');
  var Render = require('mesh/Render');
  var Rtt = require('drawables/Rtt');
  var Shader = require('render/ShaderLib');
  var WebGLCaps = require('render/WebGLCaps');
  var MainSDF = require('sdf/MainSDF');

  var vec3 = glm.vec3;
  var mat4 = glm.mat4;

  var Scene = function () {
    this._gl = null; // webgl context

    // cache canvas stuffs
    this._pixelRatio = 1.0;
    this._viewport = document.getElementById('viewport');
    this._canvas = document.getElementById('canvas');
    this._canvasWidth = 0;
    this._canvasHeight = 0;
    this._canvasOffsetLeft = 0;
    this._canvasOffsetTop = 0;

    // core of the app
    this._states = new States(this); // for undo-redo
    this._sculpt = null;
    this._camera = new Camera(this);
    this._picking = new Picking(this); // the ray picking
    this._pickingSym = new Picking(this, true); // the symmetrical picking

    // TODO primitive builder
    this._meshPreview = null;
    this._torusLength = 0.5;
    this._torusWidth = 0.1;
    this._torusRadius = Math.PI * 2;
    this._torusRadial = 32;
    this._torusTubular = 128;

    // renderable stuffs
    var opts = getOptionsURL();
    this._showContour = opts.outline;
    this._showGrid = opts.grid;
    this._grid = null;
    this._background = null;
    this._selection = null; // the selection geometry (red hover circle)
    this._meshes = []; // the meshes
    this._selectMeshes = []; // multi selection
    this._mesh = null; // the selected mesh

    this._rttContour = null; // rtt for contour
    this._rttMerge = null; // rtt decode opaque + merge transparent
    this._rttOpaque = null; // rtt half float
    this._rttTransparent = null; // rtt rgbm

    // ui stuffs
    this._focusGui = false; // if the gui is being focused
    this._gui = new Gui(this);

    this._preventRender = false; // prevent multiple render per frame
    this._drawFullScene = false; // render everything on the rtt
    this._autoMatrix = opts.scalecenter; // scale and center the imported meshes
    this._vertexSRGB = true; // srgb vs linear colorspace for vertex color
  };

  Scene.prototype = {
    start: function () {
      this.initWebGL();
      if (!this._gl)
        return;

      this._sculpt = new Sculpt(this);
      this._selection = new Selection(this._gl);
      this._background = new Background(this._gl, this);

      this._rttContour = new Rtt(this._gl, 'CONTOUR', null);
      this._rttMerge = new Rtt(this._gl, 'MERGE', null);
      this._rttOpaque = new Rtt(this._gl, 'FXAA');
      this._rttTransparent = new Rtt(this._gl, '', this._rttOpaque.getDepth(), true);

      this._grid = Primitives.createGrid(this._gl);
      this.initGrid();

      this.loadTextures();
      this._gui.initGui();
      this.onCanvasResize();
      this.addSphere();

      this._mainSDF = new MainSDF(this);
    },
    getBackground: function () {
      return this._background;
    },
    getViewport: function () {
      return this._viewport;
    },
    getCanvas: function () {
      return this._canvas;
    },
    getPixelRatio: function () {
      return this._pixelRatio;
    },
    getCanvasWidth: function () {
      return this._canvasWidth;
    },
    getCanvasHeight: function () {
      return this._canvasHeight;
    },
    getCamera: function () {
      return this._camera;
    },
    getGui: function () {
      return this._gui;
    },
    getMeshes: function () {
      return this._meshes;
    },
    getMesh: function () {
      return this._mesh;
    },
    getSelectionRadius: function () {
      return this._selection;
    },
    getSelectedMeshes: function () {
      return this._selectMeshes;
    },
    getPicking: function () {
      return this._picking;
    },
    getPickingSymmetry: function () {
      return this._pickingSym;
    },
    getSculpt: function () {
      return this._sculpt;
    },
    getStates: function () {
      return this._states;
    },
    setMesh: function (mesh) {
      return this.setOrUnsetMesh(mesh);
    },
    setCanvasCursor: function (style) {
      this._canvas.style.cursor = style;
    },
    initGrid: function () {
      var grid = this._grid;
      grid.normalizeSize();
      var gridm = grid.getMatrix();
      mat4.translate(gridm, gridm, [0.0, -0.45, 0.0]);
      var scale = 2.5;
      mat4.scale(gridm, gridm, [scale, scale, scale]);
      this._grid.setShaderName('FLAT');
      grid.setFlatColor([0.2140, 0.2140, 0.2140]);
    },
    setOrUnsetMesh: function (mesh, multiSelect) {
      if (!mesh) {
        this._selectMeshes.length = 0;
      } else if (!multiSelect) {
        this._selectMeshes.length = 0;
        this._selectMeshes.push(mesh);
      } else {
        var id = this.getIndexSelectMesh(mesh);
        if (id >= 0) {
          if (this._selectMeshes.length > 1) {
            this._selectMeshes.splice(id, 1);
            mesh = this._selectMeshes[0];
          }
        } else {
          this._selectMeshes.push(mesh);
        }
      }

      this._mesh = mesh;
      this.getGui().updateMesh();
      this.render();
      return mesh;
    },
    renderSelectOverRtt: function () {
      if (this._requestRender())
        this._drawFullScene = false;
    },
    _requestRender: function () {
      if (this._preventRender === true)
        return false; // render already requested for the next frame

      window.requestAnimationFrame(this.applyRender.bind(this));
      this._preventRender = true;
      return true;
    },
    render: function () {
      this._drawFullScene = true;
      this._requestRender();
    },
    applyRender: function () {
      this._preventRender = false;
      this.updateMatricesAndSort();

      var gl = this._gl;
      if (!gl) return;

      if (this._drawFullScene) this._drawScene();

      gl.disable(gl.DEPTH_TEST);

      gl.bindFramebuffer(gl.FRAMEBUFFER, this._rttMerge.getFramebuffer());
      this._rttMerge.render(this); // merge + decode

      // render to screen
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);

      this._rttOpaque.render(this); // fxaa
      this._selection.render(this);

      gl.enable(gl.DEPTH_TEST);

      this._sculpt.postRender(); // draw sculpt gizmos
    },
    _drawScene: function () {
      var gl = this._gl;
      var i = 0;
      var meshes = this._meshes;
      var nbMeshes = meshes.length;

      ///////////////
      // CONTOUR 1/2
      ///////////////
      gl.disable(gl.DEPTH_TEST);
      var showContour = this._selectMeshes.length > 0 && this._showContour && Shader.CONTOUR.color[3] > 0.0;
      if (showContour) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._rttContour.getFramebuffer());
        gl.clear(gl.COLOR_BUFFER_BIT);
        for (var s = 0, sel = this._selectMeshes, nbSel = sel.length; s < nbSel; ++s)
          sel[s].renderFlatColor(this);
      }
      gl.enable(gl.DEPTH_TEST);

      ///////////////
      // OPAQUE PASS
      ///////////////
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._rttOpaque.getFramebuffer());
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // grid
      if (this._showGrid) this._grid.render(this);

      // (post opaque pass)
      for (i = 0; i < nbMeshes; ++i) {
        if (meshes[i].isTransparent()) break;
        meshes[i].render(this);
      }
      var startTransparent = i;
      if (this._meshPreview) this._meshPreview.render(this);

      // background
      this._background.render();

      ///////////////
      // TRANSPARENT PASS
      ///////////////
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._rttTransparent.getFramebuffer());
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.enable(gl.BLEND);
      for (i = 0; i < nbMeshes; ++i) {
        if (meshes[i].getShowWireframe())
          meshes[i].renderWireframe(this);
      }

      gl.depthMask(false);
      gl.enable(gl.CULL_FACE);

      for (i = startTransparent; i < nbMeshes; ++i) {
        gl.cullFace(gl.FRONT); // draw back first
        meshes[i].render(this);
        gl.cullFace(gl.BACK); // ... and then front
        meshes[i].render(this);
      }

      gl.disable(gl.CULL_FACE);

      ///////////////
      // CONTOUR 2/2
      ///////////////
      if (showContour) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._rttOpaque.getFramebuffer());
        this._rttContour.render(this);
      }

      gl.depthMask(true);
      gl.disable(gl.BLEND);
    },
    /** Pre compute matrices and sort meshes */
    updateMatricesAndSort: function () {
      var meshes = this._meshes;
      var cam = this._camera;
      if (meshes.length > 0)
        cam.optimizeNearFar(this.computeBoundingBoxScene());
      for (var i = 0, nb = meshes.length; i < nb; ++i)
        meshes[i].updateMatrices(cam);
      meshes.sort(Mesh.sortFunction);

      if (this._meshPreview)
        this._meshPreview.updateMatrices(cam);
      if (this._grid)
        this._grid.updateMatrices(cam);
    },
    initWebGL: function () {
      var attributes = {
        antialias: false,
        stencil: true
      };

      var canvas = document.getElementById('canvas');
      var gl = this._gl = canvas.getContext('webgl', attributes) || canvas.getContext('experimental-webgl', attributes);
      if (!gl) {
        window.alert('Could not initialise WebGL. No WebGL, no SculptGL. Sorry.');
        return;
      }

      WebGLCaps.initWebGLExtensions(gl);
      if (!WebGLCaps.getWebGLExtension('OES_element_index_uint'))
        Render.ONLY_DRAW_ARRAYS = true;

      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);

      gl.disable(gl.CULL_FACE);
      gl.frontFace(gl.CCW);
      gl.cullFace(gl.BACK);

      gl.disable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

      gl.disable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.depthMask(true);

      gl.clearColor(0.0, 0.0, 0.0, 0.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    },
    /** Load textures (preload) */
    loadTextures: function () {
      var self = this;
      var gl = this._gl;
      var ShaderMatcap = Shader.MATCAP;

      var loadTex = function (path, idMaterial) {
        var mat = new Image();
        mat.src = path;

        mat.onload = function () {
          ShaderMatcap.createTexture(gl, mat, idMaterial);
          self.render();
        };
      };

      for (var i = 0, mats = ShaderMatcap.matcaps, l = mats.length; i < l; ++i)
        loadTex(mats[i].path, i);

      this.initAlphaTextures();
    },
    initAlphaTextures: function () {
      var alphas = Picking.INIT_ALPHAS_PATHS;
      var names = Picking.INIT_ALPHAS_NAMES;
      for (var i = 0, nbA = alphas.length; i < nbA; ++i) {
        var am = new Image();
        am.src = 'resources/alpha/' + alphas[i];
        am.onload = this.onLoadAlphaImage.bind(this, am, names[i]);
      }
    },
    /** Called when the window is resized */
    onCanvasResize: function () {
      var viewport = this._viewport;
      var newWidth = viewport.clientWidth * this._pixelRatio;
      var newHeight = viewport.clientHeight * this._pixelRatio;

      this._canvasOffsetLeft = viewport.offsetLeft;
      this._canvasOffsetTop = viewport.offsetTop;
      this._canvasWidth = newWidth;
      this._canvasHeight = newHeight;

      this._canvas.width = newWidth;
      this._canvas.height = newHeight;

      this._gl.viewport(0, 0, newWidth, newHeight);
      this._camera.onResize(newWidth, newHeight);
      this._background.onResize(newWidth, newHeight);

      this._rttContour.onResize(newWidth, newHeight);
      this._rttMerge.onResize(newWidth, newHeight);
      this._rttOpaque.onResize(newWidth, newHeight);
      this._rttTransparent.onResize(newWidth, newHeight);

      if (this._mainSDF)
        this._mainSDF.onCanvasResize(newWidth, newHeight);

      this.render();
    },
    computeBoundingBoxMeshes: function (meshes) {
      var bound = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity];
      for (var i = 0, l = meshes.length; i < l; ++i) {
        var bi = meshes[i].getWorldBound();
        if (bi[0] < bound[0]) bound[0] = bi[0];
        if (bi[1] < bound[1]) bound[1] = bi[1];
        if (bi[2] < bound[2]) bound[2] = bi[2];
        if (bi[3] > bound[3]) bound[3] = bi[3];
        if (bi[4] > bound[4]) bound[4] = bi[4];
        if (bi[5] > bound[5]) bound[5] = bi[5];
      }
      return bound;
    },
    computeBoundingBoxScene: function () {
      var scene = this._meshes.slice();
      scene.push(this._grid);
      this._sculpt.addSculptToScene(scene);
      return this.computeBoundingBoxMeshes(scene);
    },
    normalizeAndCenterMeshes: function (meshes) {
      var box = this.computeBoundingBoxMeshes(meshes);
      var scale = Utils.SCALE / vec3.dist([box[0], box[1], box[2]], [box[3], box[4], box[5]]);

      var mCen = mat4.create();
      mat4.scale(mCen, mCen, [scale, scale, scale]);
      mat4.translate(mCen, mCen, [-(box[0] + box[3]) * 0.5, -(box[1] + box[4]) * 0.5, -(box[2] + box[5]) * 0.5]);

      for (var i = 0, l = meshes.length; i < l; ++i) {
        var mat = meshes[i].getMatrix();
        mat4.mul(mat, mCen, mat);
      }
    },
    addSphere: function () {
      // make a cube and subdivide it
      var mesh = new Multimesh(Primitives.createCube(this._gl));
      mesh.normalizeSize();
      this.subdivideClamp(mesh);
      return this.addNewMesh(mesh);
    },
    addCube: function () {
      var mesh = new Multimesh(Primitives.createCube(this._gl));
      mesh.normalizeSize();
      mat4.scale(mesh.getMatrix(), mesh.getMatrix(), [0.7, 0.7, 0.7]);
      this.subdivideClamp(mesh, true);
      return this.addNewMesh(mesh);
    },
    addCylinder: function () {
      var mesh = new Multimesh(Primitives.createCylinder(this._gl));
      mesh.normalizeSize();
      mat4.scale(mesh.getMatrix(), mesh.getMatrix(), [0.7, 0.7, 0.7]);
      this.subdivideClamp(mesh);
      return this.addNewMesh(mesh);
    },
    addTorus: function (preview) {
      var mesh = new Multimesh(Primitives.createTorus(this._gl, this._torusLength, this._torusWidth, this._torusRadius, this._torusRadial, this._torusTubular));
      if (preview) {
        mesh.setShowWireframe(true);
        var scale = 0.3 * Utils.SCALE;
        mat4.scale(mesh.getMatrix(), mesh.getMatrix(), [scale, scale, scale]);
        this._meshPreview = mesh;
        return;
      }
      mesh.normalizeSize();
      this.subdivideClamp(mesh);
      this.addNewMesh(mesh);
    },
    subdivideClamp: function (mesh, linear) {
      Subdivision.LINEAR = !!linear;
      while (mesh.getNbFaces() < 50000)
        mesh.addLevel();
      // keep at max 4 multires
      mesh._meshes.splice(0, Math.min(mesh._meshes.length - 4, 4));
      mesh._sel = mesh._meshes.length - 1;
      Subdivision.LINEAR = false;
    },
    addNewMesh: function (mesh) {
      this._meshes.push(mesh);
      this._states.pushStateAdd(mesh);
      this.setMesh(mesh);
      return mesh;
    },
    loadScene: function (fileData, fileType) {
      var newMeshes;
      if (fileType === 'obj') newMeshes = Import.importOBJ(fileData, this._gl);
      else if (fileType === 'sgl') newMeshes = Import.importSGL(fileData, this._gl, this);
      else if (fileType === 'stl') newMeshes = Import.importSTL(fileData, this._gl);
      else if (fileType === 'ply') newMeshes = Import.importPLY(fileData, this._gl);
      var nbNewMeshes = newMeshes.length;
      if (nbNewMeshes === 0)
        return;

      var meshes = this._meshes;
      for (var i = 0; i < nbNewMeshes; ++i) {
        var mesh = newMeshes[i] = new Multimesh(newMeshes[i]);

        if (!this._vertexSRGB)
          Utils.convertArrayVec3toSRGB(mesh.getColors());

        mesh.init();
        mesh.initRender();
        meshes.push(mesh);
      }

      if (this._autoMatrix)
        this.normalizeAndCenterMeshes(newMeshes);

      this._states.pushStateAdd(newMeshes);
      this.setMesh(meshes[meshes.length - 1]);
      this._camera.resetView();
      return newMeshes;
    },
    clearScene: function () {
      this.getStates().reset();
      this.getMeshes().length = 0;
      this.getCamera().resetView();
      this.setMesh(null);
      this._action = 'NOTHING';
    },
    deleteCurrentSelection: function () {
      if (!this._mesh)
        return;

      this.removeMeshes(this._selectMeshes);
      this._states.pushStateRemove(this._selectMeshes.slice());
      this._selectMeshes.length = 0;
      this.setMesh(null);
    },
    removeMeshes: function (rm) {
      var meshes = this._meshes;
      for (var i = 0; i < rm.length; ++i)
        meshes.splice(this.getIndexMesh(rm[i]), 1);
    },
    getIndexMesh: function (mesh, select) {
      var meshes = select ? this._selectMeshes : this._meshes;
      var id = mesh.getID();
      for (var i = 0, nbMeshes = meshes.length; i < nbMeshes; ++i) {
        var testMesh = meshes[i];
        if (testMesh === mesh || testMesh.getID() === id)
          return i;
      }
      return -1;
    },
    getIndexSelectMesh: function (mesh) {
      return this.getIndexMesh(mesh, true);
    },
    /** Replace a mesh in the scene */
    replaceMesh: function (mesh, newMesh) {
      var index = this.getIndexMesh(mesh);
      if (index >= 0) this._meshes[index] = newMesh;
      if (this._mesh === mesh) this.setMesh(newMesh);
    },
    onLoadAlphaImage: function (img, name, tool) {
      var can = document.createElement('canvas');
      can.width = img.width;
      can.height = img.height;

      var ctx = can.getContext('2d');
      ctx.drawImage(img, 0, 0);
      var u8rgba = ctx.getImageData(0, 0, img.width, img.height).data;
      var u8lum = u8rgba.subarray(0, u8rgba.length / 4);
      for (var i = 0, j = 0, n = u8lum.length; i < n; ++i, j += 4)
        u8lum[i] = Math.round((u8rgba[j] + u8rgba[j + 1] + u8rgba[j + 2]) / 3);

      name = Picking.addAlpha(u8lum, img.width, img.height, name)._name;

      var entry = {};
      entry[name] = name;
      this.getGui().addAlphaOptions(entry);
      if (tool && tool._ctrlAlpha)
        tool._ctrlAlpha.setValue(name);
    }
  };

  module.exports = Scene;
});

define('Sculptgl',['require','exports','module','misc/Polyfill','lib/glMatrix','lib/Hammer','misc/Utils','Scene','mesh/multiresolution/Multimesh'],function (require, exports, module) {

  'use strict';

  require('misc/Polyfill');
  var glm = require('lib/glMatrix');
  var Hammer = require('lib/Hammer');
  var Utils = require('misc/Utils');
  var Scene = require('Scene');
  var Multimesh = require('mesh/multiresolution/Multimesh');

    window.sculptgl = Scene;
  var vec3 = glm.vec3;

  // Manage events
  var SculptGL = function () {
    Scene.call(this);

    // all x and y position are canvas based

    // controllers stuffs
    this._mouseX = 0;
    this._mouseY = 0;
    this._lastMouseX = 0;
    this._lastMouseY = 0;
    this._lastScale = 0;
    // NOTHING, MASK_EDIT, SCULPT_EDIT, CAMERA_ZOOM, CAMERA_ROTATE, CAMERA_PAN, CAMERA_PAN_ZOOM_ALT
    this._action = 'NOTHING';
    this._lastNbPointers = 0;
    this._isWheelingIn = false;

    // masking
    this._maskX = 0;
    this._maskY = 0;
    this._hammer = new Hammer.Manager(this._canvas);

    this._eventProxy = {};

    this.initHammer();
    this.addEvents();
  };

  var MOUSE_LEFT = 1;
  var MOUSE_MIDDLE = 2;
  var MOUSE_RIGHT = 3;

  SculptGL.prototype = {
    addEvents: function () {
      var canvas = this._canvas;

      var cbMouseWheel = this.onMouseWheel.bind(this);
      // mouse
      canvas.addEventListener('mousedown', this.onMouseDown.bind(this), false);
      window.addEventListener('mouseup', this.onMouseUp.bind(this), false);
      canvas.addEventListener('mouseout', this.onMouseOut.bind(this), false);
      canvas.addEventListener('mouseover', this.onMouseOver.bind(this), false);
      window.addEventListener('mousemove', Utils.throttle(this.onMouseMove.bind(this), 16.66), false);
      canvas.addEventListener('mousewheel', cbMouseWheel, false);
      canvas.addEventListener('DOMMouseScroll', cbMouseWheel, false);

      //key
      window.addEventListener('keydown', this.onKeyDown.bind(this), false);
      window.addEventListener('keyup', this.onKeyUp.bind(this), false);

      var cbLoadFiles = this.loadFiles.bind(this);
      var cbStopAndPrevent = this.stopAndPrevent.bind(this);
      // misc
      canvas.addEventListener('webglcontextlost', this.onContextLost.bind(this), false);
      canvas.addEventListener('webglcontextrestored', this.onContextRestored.bind(this), false);
      window.addEventListener('dragenter', cbStopAndPrevent, false);
      window.addEventListener('dragover', cbStopAndPrevent, false);
      window.addEventListener('drop', cbLoadFiles, false);
      document.getElementById('fileopen').addEventListener('change', cbLoadFiles, false);
    },
    initHammer: function () {
      this._hammer.options.enable = true;
      this._initHammerRecognizers();
      this._initHammerEvents();
    },
    _initHammerRecognizers: function () {
      var hm = this._hammer;
      // double tap
      hm.add(new Hammer.Tap({
        event: 'doubletap',
        pointers: 1,
        taps: 2,
        time: 250, // def : 250.  Maximum press time in ms.
        interval: 450, // def : 300. Maximum time in ms between multiple taps.
        threshold: 5, // def : 2. While doing a tap some small movement is allowed.
        posThreshold: 50 // def : 30. The maximum position difference between multiple taps.
      }));

      // double tap 2 fingers
      hm.add(new Hammer.Tap({
        event: 'doubletap2fingers',
        pointers: 2,
        taps: 2,
        time: 250,
        interval: 450,
        threshold: 5,
        posThreshold: 50
      }));

      // pan
      hm.add(new Hammer.Pan({
        event: 'pan',
        pointers: 0,
        threshold: 0,
      }));

      // pinch
      hm.add(new Hammer.Pinch({
        event: 'pinch',
        pointers: 2,
        threshold: 0.1 // Set a minimal thresold on pinch event, to be detected after pan
      }));
      hm.get('pinch').recognizeWith(hm.get('pan'));
    },
    _initHammerEvents: function () {
      var hm = this._hammer;
      hm.on('panstart', this.onPanStart.bind(this));
      hm.on('panmove', this.onPanMove.bind(this));
      hm.on('panend pancancel', this.onPanEnd.bind(this));

      hm.on('doubletap', this.onDoubleTap.bind(this));
      hm.on('doubletap2fingers', this.onDoubleTap2Fingers.bind(this));
      hm.on('pinchstart', this.onPinchStart.bind(this));
      hm.on('pinchin pinchout', this.onPinchInOut.bind(this));
    },
    stopAndPrevent: function (event) {
      event.stopPropagation();
      event.preventDefault();
    },
    onContextLost: function () {
      window.alert('Oops... WebGL context lost.');
    },
    onContextRestored: function () {
      window.alert('Wow... Context is restored.');
    },
    ////////////////
    // KEY EVENTS
    ////////////////
    onKeyDown: function (e) {
      this._gui.callFunc('onKeyDown', e);
    },
    onKeyUp: function (e) {
      this._gui.callFunc('onKeyUp', e);
    },
    ////////////////
    // MOBILE EVENTS
    ////////////////
    onPanStart: function (e) {
      if (e.pointerType === 'mouse')
        return;
      this._focusGui = false;
      var evProxy = this._eventProxy;
      evProxy.pageX = e.center.x;
      evProxy.pageY = e.center.y;
      this._lastNbPointers = evProxy.which = Math.min(2, e.pointers.length);
      this.onDeviceDown(evProxy);
    },
    onPanMove: function (e) {
      if (e.pointerType === 'mouse')
        return;
      var evProxy = this._eventProxy;
      evProxy.pageX = e.center.x;
      evProxy.pageY = e.center.y;
      var nbPointers = Math.min(2, e.pointers.length);
      if (nbPointers !== this._lastNbPointers) {
        this.onDeviceUp();
        evProxy.which = nbPointers;
        this.onDeviceDown(evProxy);
        this._lastNbPointers = nbPointers;
      }
      this.onDeviceMove(evProxy);
    },
    onPanEnd: function (e) {
      if (e.pointerType === 'mouse')
        return;
      this.onDeviceUp();
    },
    onDoubleTap: function (e) {
      if (this._focusGui)
        return;
      var evProxy = this._eventProxy;
      evProxy.pageX = e.center.x;
      evProxy.pageY = e.center.y;
      this.setMousePosition(evProxy);

      var picking = this._picking;
      var res = picking.intersectionMouseMeshes();
      var cam = this._camera;
      var pivot = [0.0, 0.0, 0.0];
      if (!res)
        return this.resetCameraScene();

      vec3.transformMat4(pivot, picking.getIntersectionPoint(), picking.getMesh().getMatrix());
      var zoom = cam._trans[2];
      if (!cam.isOrthographic())
        zoom = Math.min(zoom, vec3.dist(pivot, cam.computePosition()));

      cam.setAndFocusOnPivot(pivot, zoom);
      this.render();
    },
    onDoubleTap2Fingers: function () {
      if (this._focusGui)
        return;
      this.resetCameraScene();
    },
    onPinchStart: function (e) {
      this._focusGui = false;
      this._lastScale = e.scale;
    },
    onPinchInOut: function (e) {
      var dir = (e.scale - this._lastScale) * 25;
      this._lastScale = e.scale;
      this.onDeviceWheel(dir);
    },
    resetCameraScene: function () {
      if (this._meshes.length > 0) {
        var pivot = [0.0, 0.0, 0.0];
        var box = this.computeBoundingBoxMeshes(this._meshes);
        var zoom = 0.3 * vec3.dist([box[0], box[1], box[2]], [box[3], box[4], box[5]]);
        zoom *= this._camera.computeFrustumFit();
        vec3.set(pivot, (box[0] + box[3]) * 0.5, (box[1] + box[4]) * 0.5, (box[2] + box[5]) * 0.5);
        this._camera.setAndFocusOnPivot(pivot, zoom);
      } else {
        this._camera.resetView();
      }

      this.render();
    },
    ////////////////
    // LOAD FILES
    ////////////////
    getFileType: function (name) {
      var lower = name.toLowerCase();
      if (lower.endsWith('.obj')) return 'obj';
      if (lower.endsWith('.sgl')) return 'sgl';
      if (lower.endsWith('.stl')) return 'stl';
      if (lower.endsWith('.ply')) return 'ply';
      return;
    },
    loadFiles: function (event) {
      event.stopPropagation();
      event.preventDefault();
      var files = event.dataTransfer ? event.dataTransfer.files : event.target.files;
      for (var i = 0, nb = files.length; i < nb; ++i) {
        var file = files[i];
        var fileType = this.getFileType(file.name);
        this.readFile(file, fileType);
      }
    },
    readFile: function (file, ftype) {
      var fileType = ftype || this.getFileType(file.name);
      if (!fileType)
        return;

      var reader = new FileReader();
      var self = this;
      reader.onload = function (evt) {
        self.loadScene(evt.target.result, fileType);
        document.getElementById('fileopen').value = '';
      };

      if (fileType === 'obj')
        reader.readAsText(file);
      else
        reader.readAsArrayBuffer(file);
    },
    ////////////////
    // MOUSE EVENTS
    ////////////////
    onMouseDown: function (event) {
      event.stopPropagation();
      event.preventDefault();

      this._gui.callFunc('onMouseDown', event);
      this.onDeviceDown(event);
    },
    onMouseMove: function (event) {
      event.stopPropagation();
      event.preventDefault();

      this._gui.callFunc('onMouseMove', event);
      this.onDeviceMove(event);
    },
    onMouseOver: function (event) {
      this._focusGui = false;
      this._gui.callFunc('onMouseOver', event);
    },
    onMouseOut: function (event) {
      this._focusGui = true;
      this._gui.callFunc('onMouseOut', event);
      this.onMouseUp(event);
    },
    onMouseUp: function (event) {
      event.preventDefault();

      this._gui.callFunc('onMouseUp', event);
      this.onDeviceUp();
    },
    onMouseWheel: function (event) {
      event.stopPropagation();
      event.preventDefault();

      this._gui.callFunc('onMouseWheel', event);
      var dir = event.wheelDelta === undefined ? -event.detail : event.wheelDelta;
      this.onDeviceWheel(dir > 0 ? 1 : -1);
    },
    ////////////////
    // HANDLES EVENTS
    ////////////////
    onDeviceUp: function () {
      this.setCanvasCursor('default');
      Multimesh.RENDER_HINT = Multimesh.NONE;
      this._sculpt.end();

      if (this._action === 'MASK_EDIT' && this._mesh) {

        if (this._lastMouseX === this._maskX && this._lastMouseY === this._maskY)
          this.getSculpt().getTool('MASKING').invert();
        else
          this.getSculpt().getTool('MASKING').clear();

      }

      this._action = 'NOTHING';
      this.render();
      this._states.cleanNoop();
    },
    onDeviceWheel: function (dir) {
      if (dir > 0.0 && !this._isWheelingIn) {
        this._isWheelingIn = true;
        this._camera.start(this._mouseX, this._mouseY);
      }
      this._camera.zoom(dir * 0.02);
      Multimesh.RENDER_HINT = Multimesh.CAMERA;
      this.render();
      // workaround for "end mouse wheel" event
      if (this._timerEndWheel)
        window.clearTimeout(this._timerEndWheel);
      this._timerEndWheel = window.setTimeout(this._endWheel.bind(this), 300);
    },
    _endWheel: function () {
      Multimesh.RENDER_HINT = Multimesh.NONE;
      this._isWheelingIn = false;
      this.render();
    },
    setMousePosition: function (event) {
      this._mouseX = this._pixelRatio * (event.pageX - this._canvasOffsetLeft);
      this._mouseY = this._pixelRatio * (event.pageY - this._canvasOffsetTop);
    },
    onDeviceDown: function (event) {
      if (this._focusGui)
        return;

      this.setMousePosition(event);

      var mouseX = this._mouseX;
      var mouseY = this._mouseY;
      var button = event.which;

      var canEdit = false;
      if (button === MOUSE_LEFT)
        canEdit = this._sculpt.start(event.shiftKey);

      if (button === MOUSE_LEFT && canEdit)
        this.setCanvasCursor('none');

      if (button === MOUSE_RIGHT && event.ctrlKey)
        this._action = 'CAMERA_ZOOM';
      else if (button === MOUSE_MIDDLE)
        this._action = 'CAMERA_PAN';
      else if (!canEdit && event.ctrlKey) {
        this._maskX = mouseX;
        this._maskY = mouseY;
        this._action = 'MASK_EDIT';
      } else if ((!canEdit || button === MOUSE_RIGHT) && event.altKey)
        this._action = 'CAMERA_PAN_ZOOM_ALT';
      else if (button === MOUSE_RIGHT || (button === MOUSE_LEFT && !canEdit))
        this._action = 'CAMERA_ROTATE';
      else
        this._action = 'SCULPT_EDIT';

      if (this._action === 'CAMERA_ROTATE' || this._action === 'CAMERA_ZOOM')
        this._camera.start(mouseX, mouseY);

      this._lastMouseX = mouseX;
      this._lastMouseY = mouseY;
    },
    onDeviceMove: function (event) {
      if (this._focusGui)
        return;
      this.setMousePosition(event);

      var mouseX = this._mouseX;
      var mouseY = this._mouseY;
      var action = this._action;

      if (action === 'CAMERA_ZOOM' || (action === 'CAMERA_PAN_ZOOM_ALT' && !event.altKey)) {

        Multimesh.RENDER_HINT = Multimesh.CAMERA;
        this._camera.zoom((mouseX - this._lastMouseX + mouseY - this._lastMouseY) / 1000);
        this.render();

      } else if (action === 'CAMERA_PAN_ZOOM_ALT' || action === 'CAMERA_PAN') {

        Multimesh.RENDER_HINT = Multimesh.CAMERA;
        this._camera.translate((mouseX - this._lastMouseX) / 1000, (mouseY - this._lastMouseY) / 1000);
        this.render();

      } else if (action === 'CAMERA_ROTATE') {

        Multimesh.RENDER_HINT = Multimesh.CAMERA;
        if (!event.shiftKey)
          this._camera.rotate(mouseX, mouseY);
        this.render();

      } else {

        Multimesh.RENDER_HINT = Multimesh.PICKING;
        this._sculpt.preUpdate();

        if (action === 'SCULPT_EDIT') {
          Multimesh.RENDER_HINT = Multimesh.SCULPT;
          this._sculpt.update(this);
          if (this.getMesh().getDynamicTopology)
            this._gui.updateMeshInfo();
        }
      }
      this._lastMouseX = mouseX;
      this._lastMouseY = mouseY;
      this.renderSelectOverRtt();
    }
  };

  Utils.makeProxy(Scene, SculptGL);

  module.exports = SculptGL;
});

